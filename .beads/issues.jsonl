{"id":"nix-openclaw-vm-35e","title":"PROPOSAL: Credential proxy implementation plan","description":"# Credential Proxy Security Layer — Implementation Plan\n\n**Beads**: `nix-openclaw-vm-7xk` (epic), `nix-openclaw-vm-et5` (request), `nix-openclaw-vm-whp` (URE)\n\n---\n\n## Research Findings\n\n### Existing Solutions Evaluated\n\n| Solution | What It Does | Domain Binding | VSOCK | Verdict |\n|----------|-------------|----------------|-------|---------|\n| [Vultrino](https://github.com/zachyking/vultrino) | Rust credential proxy for AI agents. Alias-based refs, MCP server, WASM plugins. 6 stars, Jan 2026. | No (glob scoping only) | No | **Design reference only**. Too immature, Rust (rejected), no domain binding. |\n| [Agent Gateway](https://github.com/agentgateway/agentgateway) | Rust MCP/A2A gateway. Linux Foundation. RBAC, JWT, header manipulation. | No | No | **Wrong purpose**. Inbound agent-to-tool routing, NOT outbound credential injection. |\n| [elazarl/goproxy](https://github.com/elazarl/goproxy) | Go HTTP proxy library. MITM HTTPS, per-host handlers, request/response modification. 6.6k stars, BSD-3, 10+ years. | N/A (library) | Yes (custom `net.Listener`) | **Foundation library**. Implements `http.Handler` — serves on any listener including VSOCK. |\n| Envoy + ext_authz | C++ L7 proxy (CNCF). ext_authz calls external service for auth + header injection. In nixpkgs. | Header-only (ext_authz can't modify bodies) | No (TCP/Unix only) | **Wrong tool.** ext_authz injects headers but cannot modify request/response bodies. MITM HTTPS is experimental (no cert generation). No VSOCK. Would still need custom Go for body substitution, response scrubbing, Temporal, OpenBao — making Envoy pure overhead (3 moving parts instead of 1). |\n| Vault/OpenBao Agent | Proxies requests TO vault, not outbound. | N/A | No | **Backend only**. Use OpenBao for secret storage. |\n| [Secretless Broker](https://github.com/cyberark/secretless-broker) | Go HTTP forward proxy by CyberArk. Injects credentials from Vault/Conjur into outbound HTTP. Plugin arch (Providers + Connectors). Apache 2.0, 366 stars, v1.7.32 Feb 2026, maintained since 2018. 25+ pre-built API configs. | URL regex matching, per-connector-port | No (tcp/unix only) | **Closest existing solution but 3 blockers**: (1) Rejects CONNECT with 405 — cannot MITM HTTPS; (2) No response sanitization — \"app never sees secrets\" model conflicts with our need to scrub credentials from API responses; (3) No VSOCK or Temporal. |\n| [Octelium](https://github.com/octelium/octelium) | Go zero-trust access platform. L7-aware \"secretless access\" — injects API keys, Bearer, OAuth2, Sigv4 per-upstream. CEL/OPA policy-as-code. 3.4k stars, AGPLv3. | Per-service routing + CEL policies | No | **Too heavyweight + AGPLv3**. Full platform (VPN, ZTNA, PaaS, MCP gateway). No response sanitization documented. No VSOCK. |\n| [Envoy credential_injector](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/credential_injector_filter) | Native Envoy filter. Injects credentials from SDS into outbound requests. First-class in Envoy Gateway v1.4+. | Via routing rules / HTTPRouteFilter | No | **Kubernetes-centric, heavyweight**. Requires full Envoy. No response sanitization. |\n| [Ory Oathkeeper](https://www.ory.com/docs/oathkeeper) | Go zero-trust proxy. Per-domain access rules, header/JWT injection, CNCF ecosystem. | Per-rule domain matching | No | **Inbound-focused**. Designed for authenticating users TO your services, not injecting creds into outbound API calls. |\n| [Peta Core](https://github.com/dunialabs/peta-core) | TypeScript MCP gateway. Server-side vault with JIT decryption (30s TTL), short-lived agent tokens, HITL approvals. 28 stars, ELv2. | No | No | **TypeScript (not Go), ELv2 license**. Custom vault (not OpenBao). No domain binding. Design reference for JIT decryption + audit patterns. |\n| [Riptides](https://riptides.io/) | **Proprietary** kernel module for on-the-wire credential injection. kTLS + SPIFFE identity. Go userspace agent for OPA policy evaluation. Intercepts outbound IP sockets before TLS. | Per-process SPIFFE scoping | No (IP sockets only, not AF_VSOCK) | **Proprietary, no VSOCK, no response sanitization.** Core kernel module is closed-source. Plans to open-source \"the core\" but hasn't. Uses Lima VMs (TAP networking) — likely incompatible with VSOCK-only microVMs. No response scrubbing. No Temporal. Design reference for on-the-wire injection timing + SPIFFE identity. |\n| [Boundary](https://developer.hashicorp.com/boundary) (HashiCorp) | Credential brokering + injection for SSH, RDP, databases. Controller+Worker model. BSL 1.1. | Per-target | No | **3 blockers**: (1) BSL license (not truly OSS since 2023); (2) Credential injection is **Enterprise/HCP-only** — community edition only has brokering; (3) HTTP API injection is [not implemented](https://github.com/hashicorp/boundary/issues/5273) — only SSH, RDP, DB targets supported. |\n| [Pomerium](https://www.pomerium.com/) | Zero-trust access proxy. JWT injection + Vault integration. Apache 2.0. | Per-route | No | **Inbound-focused + JWT only.** Authenticates users TO apps. Can inject JWTs but not arbitrary API keys/headers into outbound requests. |\n| [Teleport](https://goteleport.com/) | Secure access platform. REST API access with JWT injection. Elastic v2/AGPL. | Per-app | No | **Restrictive license + JWT only.** Elastic v2 is not OSS. Same JWT-only limitation as Pomerium. |\n\n**Conclusion**: No existing solution provides our required combination (VSOCK + MITM HTTPS + placeholder substitution + response sanitization + domain binding + Temporal audit). CyberArk Secretless Broker was closest but has fundamental conflicts with response sanitization (its \"app never sees secrets\" model means it can't scrub credentials from API responses). Build custom Go proxy using [goproxy](https://github.com/elazarl/goproxy) as the HTTP proxy foundation and [mdlayher/vsock](https://github.com/mdlayher/vsock) as the transport. Borrow design patterns from Secretless (Vault provider, connector configs) and Peta (JIT decryption, audit trail) without taking the dependencies.\n\n### Go Libraries\n\n| Library | Component | Purpose | Status |\n|---------|-----------|---------|--------|\n| [`elazarl/goproxy`](https://github.com/elazarl/goproxy) | (4)(5) Gateway | HTTP/HTTPS forward proxy with MITM | 6.6k stars, BSD-3, 10+ years |\n| [`mdlayher/vsock`](https://github.com/mdlayher/vsock) | (4) Transport | AF_VSOCK `net.Listener` | v1 stable, updated Jan 2025 |\n| [`coreos/go-oidc/v3`](https://github.com/coreos/go-oidc) | (2) Authentication | Keycloak JWT validation via JWKS | Industry standard |\n| [`open-policy-agent/opa/rego`](https://pkg.go.dev/github.com/open-policy-agent/opa/rego) | (3) Authorization | Rego policy evaluation (embedded) | CNCF graduated, \u003c10ms P99 |\n| [`openbao/openbao/api/v2`](https://pkg.go.dev/github.com/openbao/openbao/api) | (1) Secret vault | OpenBao client (Vault API compat) | Official, maintained |\n| [`temporalio/sdk-go`](https://go.temporal.io/sdk) | (5) Audit | Temporal workflows + activities | Tier 1, v1.29+, production-grade |\n| `temporal-cli` | Infrastructure | Temporal dev server | [In nixpkgs](https://www.nixhub.io/packages/temporal-cli) |\n\n### Auth/Authz Tool Evaluation\n\nPomerium, Ory Oathkeeper, and OPA were evaluated for components (2) and (3):\n\n| Tool | Keycloak OIDC | Embeddable | Forward proxy (CONNECT) | Authz model | Verdict |\n|------|--------------|------------|------------------------|-------------|---------|\n| **Pomerium** | Native (redirect flow) | **No** — standalone only | Partial (needs pomerium-cli) | PPL (YAML) + Rego | **Too heavy**. Can't embed, requires separate process. |\n| **Oathkeeper** | JWT validation | **Yes** (gRPC middleware) | **No** | Rules + remote authorizer | **No CONNECT**. Good mutators but wrong proxy mode. |\n| **OPA (embedded)** | JWT decode in Rego | **Yes** (library) | N/A (policy engine) | Rego (very flexible) | **Winner for (3).** \u003c10ms, embeddable, expressive. |\n| **coreos/go-oidc** | JWKS validation | **Yes** (library) | N/A | N/A | **Winner for (2).** Simple, 5 lines of code. |\n\n**Decision:** Use `coreos/go-oidc` for JWT validation + `OPA embedded` for authorization policy. Skip Pomerium and Oathkeeper — they don't handle CONNECT, and their auth can be done more simply with direct libraries.\n\n### Language Elimination\n\n| Language | Temporal SDK | Vault Client | OIDC | VSOCK | Verdict |\n|----------|-------------|-------------|------|-------|---------|\n| **Go** | Tier 1 | First-party | Excellent | `mdlayher/vsock` | **Winner** |\n| Rust | Alpha | Community | Good | Available | User rejected; Temporal experimental |\n| Gleam/Elixir | **None** | Poor | Fair | **None** | Eliminated |\n| Zig | **None** | **None** | **None** | Syscall | Eliminated |\n\n---\n\n## Context\n\nThe openclaw-vm gives an AI agent a sandboxed microVM with VSOCK-only host communication. Currently, the agent needs API credentials passed in directly (via fw_cfg), meaning a compromised agent could exfiltrate secrets. This plan builds a **transparent forward proxy** on the host that:\n\n- Listens on **VSOCK** (hypervisor-level socket — physically cannot reach the internet, no IP routing)\n- Acts as a standard HTTP forward proxy — agent just sets `HTTP_PROXY` / `HTTPS_PROXY` env vars\n- **Intercepts HTTPS** via MITM TLS with a custom CA cert installed in the VM\n- Detects **opaque placeholder strings** (`agent-vault-\u003cuuid\u003e`) in request headers/body\n- **Replaces placeholders with real credentials** fetched from OpenBao\n- Enforces **domain binding** (credential X only works for domain Y, fail-closed)\n- **Scrubs credentials from responses** (replaces real values back with placeholders)\n- Records every credential access as a **Temporal workflow** for audit/replay\n\n**Why VSOCK?** Unlike TAP networking (which relies on nftables rules that could be misconfigured), VSOCK is a direct guest↔host channel provided by the hypervisor. Traffic on VSOCK physically cannot be routed to the internet — it's not an IP socket. This provides defense-in-depth: even if firewall rules are wrong, credentials can only flow through the proxy.\n\n---\n\n## Key Decisions\n\n| Decision | Choice | Rationale |\n|----------|--------|-----------|\n| Language | **Go** | First-party Vault client, tier-1 Temporal SDK, goproxy library, VSOCK support |\n| Architecture | **Composable 5-component gateway** | Separation of concerns: auth, authz, vault, inbound, outbound. Single Go binary. |\n| Proxy foundation | **goproxy, not Secretless Broker** | Secretless rejects CONNECT (405) — no MITM HTTPS. goproxy handles MITM natively. |\n| Authentication | **Keycloak OIDC JWT via `coreos/go-oidc`** | Agent presents JWT in `Proxy-Authorization` header. Proxy validates against Keycloak JWKS. Pomerium/Oathkeeper evaluated but too heavy (can't embed, wrong proxy mode). |\n| Authorization | **OPA embedded (Rego policies)** | Evaluates \"identity X with role Y can use credential Z for domain D\". \u003c10ms P99, embeddable library. |\n| Proxy mode | **Transparent forward proxy** (goproxy) | Agent sets `HTTP_PROXY` env var. Zero agent code changes. |\n| HTTPS handling | **MITM with custom CA** | goproxy's `ConnectMitm` action. CA cert installed in VM at build time. |\n| Credential pattern | **Placeholder substitution** | `agent-vault-\u003cuuid\u003e` strings in headers/body. Proxy replaces outbound, scrubs inbound. |\n| Orchestration | **Temporal from day 1** | Each proxied request = workflow. Audit trail, replay, retries, rate limiting. |\n| Provisioning | **Env vars + fw_cfg** | `ANTHROPIC_API_KEY=agent-vault-abc123` + JSON config listing all placeholders. |\n| Deployment | **Systemd service** on host | Direct VSOCK access, systemd hardening. |\n| Temporal hosting | **temporal-cli dev server** | In nixpkgs. SQLite-backed. Upgrade to PostgreSQL later. |\n| Domain enforcement | **OPA policy + goproxy `DstHostIs()`** | OPA for fine-grained authz, goproxy for fail-closed domain allowlist. |\n\n---\n\n## Architecture (5-Component Composable Gateway)\n\n```\nGuest VM (zero external network)                Host (NixOS)\n┌──────────────────────────────┐    VSOCK     ┌─────────────────────────────────────┐\n│ Agent                        │  CID:4       │ credproxy (Single Go Binary)         │\n│  HTTP_PROXY=localhost:18790  │  port:18790  │                                      │\n│  HTTPS_PROXY=localhost:18790 │ ──────────▶  │  (4) INBOUND HANDLER (goproxy)         │\n│                              │              │     Accept CONNECT, extract JWT       │\n│ Keycloak JWT in              │              │          ↓                            │\n│  Proxy-Authorization header  │              │  (2) AUTHENTICATION (coreos/go-oidc)   │\n│                              │              │     Validate JWT via Keycloak JWKS    │\n│ Makes normal HTTP(S) calls:  │              │          ↓                            │\n│  curl -H \"x-api-key:         │              │  (3) AUTHORIZATION (OPA embedded)      │\n│   agent-vault-abc123\"        │              │     Rego: identity→credential→domain  │\n│   https://api.anthropic.com  │              │          ↓                            │\n│                              │  ◀────────── │  (1) SECRET VAULT (OpenBao client)     │\n│ socat VSOCK↔localhost bridge │   response   │     Fetch real credential values      │\n│ CA cert: /etc/ssl/credproxy  │  (sanitized) │          ↓                            │\n└──────────────────────────────┘              │  (5) OUTBOUND HANDLER (goproxy)        │\n                                              │     MITM TLS → inject creds →        │\n                                              │     forward → scrub response →       │\n                                              │     Temporal audit                    │\n                                              └──────┬──────┬──────────┬─────────────┘\n                                                     │      │          │\n                                                ┌────▼──┐┌──▼───┐┌───▼──────────┐\n                                                │OpenBao││Keyclk││ Temporal     │\n                                                │  (1)    ││  (2)   ││ dev server   │\n                                                └───────┘└──────┘└──────────────┘\n```\n\n---\n\n## Request Flow (Composable Gateway)\n\n```\n1. Agent authenticates to Keycloak, receives JWT.\n   Agent makes normal HTTPS request with JWT:\n     curl -H \"x-api-key: agent-vault-abc123\" \\\n          -H \"Proxy-Authorization: Bearer \u003cjwt\u003e\" \\\n          https://api.anthropic.com/v1/messages\n\n2. curl respects HTTP_PROXY=http://localhost:18790\n   → Sends CONNECT api.anthropic.com:443 to proxy (with Proxy-Authorization header)\n\n3. socat in VM bridges localhost:18790 → VSOCK CID:4 port:18790 → Host\n\n4. (4) INBOUND HANDLER — goproxy receives CONNECT request:\n   a. Extract Proxy-Authorization JWT from CONNECT request headers\n   b. Is api.anthropic.com in domain allowlist?\n      NO  → ConnectReject (403 Domain Not Allowed)\n\n5. (2) AUTHENTICATION — coreos/go-oidc validates JWT:\n   a. Fetch Keycloak JWKS (cached) from well-known endpoint\n   b. Verify JWT signature, issuer, audience, expiry\n   c. Extract claims: { sub, roles, groups, ... }\n   INVALID → 407 Proxy Authentication Required\n\n6. ConnectMitm (MITM intercept with custom CA). goproxy decrypts the request.\n\n7. goproxy runs OnRequest handlers:\n   a. Extract placeholders from headers + body (regex: agent-vault-[a-f0-9-]{36})\n   b. (3) AUTHORIZATION — OPA policy evaluation:\n      Input:  { identity: jwt.claims, placeholders: [...], target_domain: req.Host }\n      Policy: \"Allow if identity.roles contains required role\n               AND each credential is bound to target_domain\"\n      DENY → 403 Forbidden (with reason)\n   c. Start Temporal workflow: ProxyRequest\n\n8. (1) SECRET VAULT + (5) OUTBOUND HANDLER:\n   Temporal Activity: FetchAndForward (sealed — secrets never in event history)\n   - Fetch real credentials from OpenBao: credPath → \"sk-ant-xxx\"\n   - Replace placeholders with real values in request headers/body\n   - goproxy forwards modified request to api.anthropic.com\n   - Receive response\n\n9. goproxy runs OnResponse handlers:\n   a. Scan response body for real credential values\n   b. Replace any found values with their placeholder strings\n   c. Return sanitized response through MITM TLS → VSOCK → Agent\n\n10. Temporal workflow records: agentID (from JWT sub), targetDomain,\n    credentialRefHash, latency, status, OPA decision\n```\n\n---\n\n## goproxy Integration Details\n\n### Handler Registration\n\n```go\nproxy := goproxy.NewProxyHttpServer()\n\n// 1. Domain allowlist — reject unknown hosts\nproxy.OnRequest().HandleConnect(goproxy.FuncHttpsHandler(\n    func(host string, ctx *goproxy.ProxyCtx) (*goproxy.ConnectAction, string) {\n        domain := extractHost(host) // strip port\n        if !config.IsAllowedDomain(domain) {\n            return goproxy.RejectConnect, host\n        }\n        return \u0026goproxy.ConnectAction{\n            Action:    goproxy.ConnectMitm,\n            TLSConfig: goproxy.TLSConfigFromCA(\u0026caCert),\n        }, host\n    }))\n\n// 2. Placeholder substitution on request\nproxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n    placeholders := placeholder.Extract(req)\n    if len(placeholders) == 0 {\n        return req, nil // No placeholders, pass through\n    }\n\n    // Validate domain binding\n    for _, ph := range placeholders {\n        if ph.BoundDomain != req.URL.Hostname() {\n            return req, goproxy.NewResponse(req, goproxy.ContentTypeText,\n                http.StatusForbidden, \"Domain mismatch: credential not bound to this host\")\n        }\n    }\n\n    // Start Temporal workflow (synchronous — blocks until complete)\n    result := temporal.ExecuteProxyWorkflow(ctx, req, placeholders)\n    if result.Error != nil {\n        return req, goproxy.NewResponse(req, goproxy.ContentTypeText,\n            http.StatusBadGateway, result.Error.Error())\n    }\n\n    // Store result for response handler\n    ctx.UserData = result\n    return result.ModifiedRequest, nil\n})\n\n// 3. Credential scrubbing on response\nproxy.OnResponse().DoFunc(func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n    result := ctx.UserData.(*ProxyResult)\n    return sanitizer.ScrubCredentials(resp, result.Credentials)\n})\n\n// Serve on VSOCK listener\nvsockListener, _ := vsock.Listen(vsock.Host, 18790, nil)\nhttp.Serve(vsockListener, proxy)\n```\n\n### Custom CA Certificate\n\nGenerated at NixOS build time:\n```nix\n# In modules/credential-proxy/default.nix\npkgs.runCommand \"credproxy-ca\" { buildInputs = [ pkgs.openssl ]; } ''\n  openssl req -x509 -newkey ec -pkeyopt ec_paramgen_curve:prime256v1 \\\n    -keyout $out/ca.key -out $out/ca.crt -days 3650 -nodes \\\n    -subj '/CN=Credential Proxy CA/O=openclaw-vm'\n''\n```\n\nInstalled in guest VM:\n```nix\n# In guest.nix\nsecurity.pki.certificateFiles = [ \"${credproxyCa}/ca.crt\" ];\n```\n\n---\n\n## File Structure\n\n### Go Service: `credential-proxy/`\n\n```\ncredential-proxy/\n├── go.mod\n├── go.sum\n├── main.go                        # Entry: VSOCK listener, goproxy setup, Temporal worker\n├── config/\n│   └── config.go                  # Config types, YAML loading, domain allowlist\n├── auth/\n│   └── oidc.go                    # (2) Keycloak JWT validation (coreos/go-oidc wrapper)\n├── authz/\n│   ├── engine.go                  # (3) OPA embedded policy evaluator\n│   └── policies/\n│       └── credential_access.rego # Rego policy: identity → credential → domain\n├── proxy/\n│   ├── gateway.go                 # (4) Composable gateway router (CONNECT → outbound)\n│   ├── handlers.go                # (5) goproxy OnRequest/OnResponse handlers\n│   ├── placeholder.go             # Placeholder extraction + substitution (regex)\n│   └── sanitizer.go               # Response credential scrubbing\n├── vault/\n│   └── client.go                  # (1) OpenBao client wrapper (DI-friendly interface)\n├── workflows/\n│   ├── proxy_workflow.go          # ProxyRequest Temporal workflow\n│   └── activities.go              # FetchAndForward sealed activity\n└── audit/\n    └── search_attributes.go       # Temporal search attribute definitions\n```\n\n### NixOS Modules: `modules/credential-proxy/`\n\n```\nmodules/credential-proxy/\n├── default.nix                    # Host: proxy service + Temporal + CA generation\n├── guest.nix                      # Guest: VSOCK bridge, CA cert, HTTP_PROXY env\n└── openbao-policy.nix             # OpenBao read-only policy for proxy\n```\n\n### Modifications to Existing Files\n\n| File | Change |\n|------|--------|\n| `flake.nix` | Add `credential-proxy` Go package (`buildGoModule`), module imports, test-vm config |\n| `modules/openclaw-vm/default.nix` | Add `credentialProxy` option group, VSOCK port 18790, CA cert fw_cfg |\n| `modules/openclaw-vm/guest.nix` | VSOCK bridge for port 18790, `HTTP_PROXY`/`HTTPS_PROXY` env vars, CA cert install |\n\n---\n\n## Temporal Workflow Design\n\n### ProxyRequest Workflow\n\n```\nInput:  { agentID, requestID, targetDomain, method, path, placeholderHashes[] }\nOutput: { status: \"success\"|\"denied\"|\"error\", latencyMs, bytesTransferred }\n\nSearch attributes: AgentID, TargetDomain, CredentialRefHash, Timestamp, Status\n```\n\n### Activities\n\n1. **ValidateAndResolve** (local activity — deterministic, no retries)\n   - Input: request metadata + placeholder list\n   - Validates domain binding for all placeholders\n   - Returns: credential paths (NOT values) + validation result\n   - Safe for event history (no secrets)\n\n2. **FetchAndForward** (sealed activity — secrets stay inside)\n   - Input: original request + credential paths\n   - Fetches real credentials from OpenBao (inside activity)\n   - Replaces placeholders in request\n   - Makes HTTPS request to target\n   - Scrubs credentials from response\n   - Returns: sanitized response\n   - Retries: 3x exponential backoff for transient failures\n   - Timeout: 30s start-to-close\n   - **CRITICAL**: Secret values never appear in Temporal event history\n\n### Secrets Safety\n\nThe `FetchAndForward` activity is \"sealed\" — all credential handling (fetch, inject, forward, scrub) happens within a single activity. The activity input is credential *paths* (safe), and the output is a sanitized response (safe). Real credential values exist only in memory during activity execution.\n\n---\n\n## OpenBao Credential Schema\n\n```\nPath: secret/data/openclaw/credentials/\u003calias\u003e\nData: {\n  \"type\": \"api_key\" | \"bearer\" | \"basic_auth\" | \"header\",\n  \"key\": \"sk-ant-...\",\n  \"domain\": \"api.anthropic.com\",\n  \"header_name\": \"x-api-key\",\n  \"header_prefix\": \"\",\n  \"placeholder\": \"agent-vault-\u003cuuid\u003e\"\n}\n```\n\n---\n\n## Guest VM Configuration\n\n### What changes in the VM:\n\n1. **socat VSOCK bridge** (new systemd service):\n   ```\n   socat TCP-LISTEN:18790,fork,reuseaddr VSOCK-CONNECT:2:18790\n   ```\n\n2. **HTTP proxy env vars** (for all users + services):\n   ```\n   HTTP_PROXY=http://localhost:18790\n   HTTPS_PROXY=http://localhost:18790\n   NO_PROXY=localhost,127.0.0.1,10.88.0.1\n   ```\n\n3. **CA certificate** installed system-wide:\n   ```nix\n   security.pki.certificateFiles = [ credproxyCaCert ];\n   ```\n\n4. **Placeholder env vars** (per credential):\n   ```\n   ANTHROPIC_API_KEY=agent-vault-a1b2c3d4-...\n   GITHUB_TOKEN=agent-vault-e5f6a7b8-...\n   ```\n\n5. **Placeholder config** via fw_cfg (JSON listing available credentials with aliases + domains)\n\n---\n\n## Implementation Phases\n\n### Phase 1: Types, Config, Auth, Authz (no external service deps)\n- `credential-proxy/config/config.go` — Config types, YAML loading, domain allowlist\n- `credential-proxy/auth/oidc.go` — (2) Keycloak JWT validation wrapper (coreos/go-oidc)\n- `credential-proxy/authz/engine.go` — (3) OPA embedded policy evaluator\n- `credential-proxy/authz/policies/credential_access.rego` — Authorization policy\n- `credential-proxy/proxy/placeholder.go` — Placeholder regex extraction + substitution\n- `credential-proxy/proxy/sanitizer.go` — Response credential scrubbing\n\n### Phase 2: Tests (import production code paths)\n- `credential-proxy/auth/oidc_test.go` — JWT validation (valid, expired, wrong issuer)\n- `credential-proxy/authz/engine_test.go` — OPA policy (allow, deny, domain mismatch)\n- `credential-proxy/proxy/placeholder_test.go` — Placeholder detection in headers, body, URLs\n- `credential-proxy/proxy/sanitizer_test.go` — Credential scrubbing from JSON/HTML/text responses\n- `credential-proxy/workflows/activities_test.go` — Activity logic with mocked OpenBao\n\n### Phase 3: Implementation (make tests pass)\n- `credential-proxy/vault/client.go` — (1) OpenBao client with DI interface\n- `credential-proxy/proxy/gateway.go` — (4) Composable gateway router\n- `credential-proxy/proxy/handlers.go` — (5) goproxy OnRequest/OnResponse/HandleConnect\n- `credential-proxy/workflows/proxy_workflow.go` — ProxyRequest Temporal workflow\n- `credential-proxy/workflows/activities.go` — FetchAndForward sealed activity\n- `credential-proxy/main.go` — VSOCK listener, goproxy setup, Temporal worker\n\n### Phase 4: NixOS Integration\n- `modules/credential-proxy/default.nix` — Host module (proxy + Temporal + CA gen)\n- `modules/credential-proxy/guest.nix` — Guest module (VSOCK bridge, CA cert, env vars)\n- `modules/credential-proxy/openbao-policy.nix` — Read-only policy\n- `flake.nix` — `buildGoModule` package, module imports, test-vm config\n- `modules/openclaw-vm/default.nix` — Wire in credentialProxy options, VSOCK port 18790\n- `modules/openclaw-vm/guest.nix` — HTTP_PROXY/HTTPS_PROXY, CA cert, placeholder env vars\n\n### Phase 5: VM Network Lockdown\n- Extend nftables in `modules/openclaw-vm/default.nix` — block all external network when proxy enabled\n- Only VSOCK communication allowed\n\n---\n\n## Verification\n\n1. **Nix evaluation**: `nix flake check --no-build` passes\n2. **Module evaluation**: `nix eval .#nixosConfigurations.test-vm.config.system.build.toplevel --apply 'x: \"ok\"'` → `\"ok\"`\n3. **Go build**: `nix build .#credential-proxy` succeeds\n4. **Go tests**: `cd credential-proxy \u0026\u0026 go test ./...` — all pass\n5. **Placeholder detection**: Unit tests verify extraction from HTTP headers, JSON body, URL query params\n6. **Sanitization**: Unit tests verify credential values scrubbed from responses (JSON, HTML, plaintext)\n7. **Domain binding**: Unit tests verify mismatch → denied (fail-closed), match → allowed\n8. **MITM TLS**: Integration test with custom CA cert — proxy decrypts HTTPS, injects credentials\n9. **Temporal workflow**: Integration test with `go.temporal.io/sdk/testsuite` — workflow completes, search attributes recorded\n10. **Forward proxy**: Integration test — `curl -x http://proxy:18790 https://httpbin.org/get` works with placeholder substitution\n11. **Network lockdown**: Agent cannot reach external network without proxy (no DNS, no TCP out)\n\n---\n\n## Existing Code to Reuse\n\n| Pattern | Source | Reuse |\n|---------|--------|-------|\n| VSOCK socat bridge | `modules/openclaw-vm/guest.nix:466-488` (vsock-gateway-proxy) | Same pattern for credproxy VSOCK bridge |\n| fw_cfg credential injection | `modules/openclaw-vm/default.nix:397-440` (sops.templates + fw_cfg) | Same pattern for placeholder config |\n| systemd hardening | `modules/openclaw-vm/guest.nix:293-370` (openclaw-gateway service) | Copy hardening directives for proxy service |\n| nftables VM isolation | `modules/openclaw-vm/default.nix:190-260` (nftables rules) | Extend for full network lockdown |\n| OpenBao policy gen | `modules/openclaw/openbao.nix:42-70` (per-instance policies) | Same pattern for proxy read-only policy |\n| CA cert install | NixOS `security.pki.certificateFiles` | Standard NixOS pattern for custom CAs |","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T03:25:45.699759213-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T03:25:45.699759213-08:00","labels":["aura:plan:proposal"],"dependencies":[{"issue_id":"nix-openclaw-vm-35e","depends_on_id":"nix-openclaw-vm-whp","type":"blocks","created_at":"2026-02-17T03:25:49.989212432-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-35e","depends_on_id":"nix-openclaw-vm-et5","type":"blocks","created_at":"2026-02-17T03:25:50.010484774-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-7xk","title":"CREDENTIAL-PROXY: Implement credential proxy security layer for openclaw-vm","description":"## Goal\nImplement a credential proxy security layer for the openclaw microVM where:\n- Agent inside VM has zero external network access\n- All auth-required requests delegated to trusted proxy service on host via VSOCK\n- Credentials stored in OpenBao with domain binding enforcement\n- Proxy injects auth headers — agent never sees API keys\n- Full audit trail of all credential access\n\n## Architecture\nHost (NixOS)\n├── OpenBao (secrets store)\n│   └── Credentials with domain binding metadata\n├── Credential Proxy Service (NEW)\n│   ├── Listens on VSOCK\n│   ├── Validates ACP protocol requests\n│   ├── Fetches credential from OpenBao + verifies domain binding\n│   ├── Injects auth headers into outbound HTTPS request\n│   ├── Templates response\n│   └── Audit logs everything\n└── openclaw-vm (microVM)\n    └── Agent (zero network — all via VSOCK → proxy)\n\n## Phases\n1. Protocol \u0026 Types (ACP subset)\n2. Credential Proxy Service (Rust)\n3. NixOS Integration\n4. Guest-Side Client\n5. VM Network Lockdown","status":"in_progress","priority":1,"issue_type":"feature","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T01:12:10.551998339-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T03:11:22.940438395-08:00"}
{"id":"nix-openclaw-vm-et5","title":"REQUEST: Credential proxy security layer for openclaw-vm","description":"Verbatim User Request: Implement a credential proxy security layer for the openclaw microVM where the agent inside the VM has zero external network access, all auth-required requests are delegated to a trusted proxy service on the host via VSOCK, credentials are stored in OpenBao with domain binding enforcement, the proxy injects auth headers (agent never sees API keys), and full audit trail of all credential access. User Clarifications: Does NOT want Rust. Prefers Zig, Gleam/Elixir, or Golang. Does NOT want to re-implement secret-to-domain mapping or the proxy itself if avoidable. Interested in Temporal for backend orchestration (audit trail, event sourcing, event-driven architecture). Wants to evaluate existing solutions before building from scratch. Source Document: ~/dotfiles/docs/agent-sandbox.md","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T01:20:06.451275233-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T01:20:06.451275233-08:00","labels":["aura:user:request"],"dependencies":[{"issue_id":"nix-openclaw-vm-et5","depends_on_id":"nix-openclaw-vm-7xk","type":"blocks","created_at":"2026-02-17T01:20:12.017952753-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-whp","title":"URE: Credential proxy scope and MVP","description":"## User Requirements Elicitation — Credential Proxy Security Layer\n\n### Session 1: Initial Requirements Interview\n\n#### URE Q1: MVP Scope\n**Q:** \"What is the MVP scope? Should Phase 1 focus on just the proxy + OpenBao domain binding, or do you also want Temporal orchestration in the MVP?\"\n- (1) Proxy + domain binding only — MVP: VSOCK listener, OpenBao credential fetch, domain binding check, header injection, JSONL audit. Add Temporal later.\n- (2) Include Temporal from start — Build on Temporal from day 1: each proxy request = workflow execution, audit trail via workflow history, event replay built-in.\n- (3) Temporal for audit only — Simple proxy handles requests directly, but logs events to Temporal for audit trail and replay. Hybrid approach.\n\n**A:** \"Include Temporal from start\"\n\n#### URE Q2: Deployment Model\n**Q:** \"For deployment: should the credential proxy run as a standalone systemd service on the host, or inside a container (Podman) like OpenBao?\"\n- (1) Systemd service (Recommended) — Native binary, systemd hardening (like the existing gateway). Simpler, less overhead, direct VSOCK access.\n- (2) Podman container — Containerized like OpenBao. More isolation but adds complexity for VSOCK passthrough.\n- (3) Decide later — Design the NixOS module to support both, decide during implementation.\n\n**A:** \"Systemd service (Recommended)\"\n\n#### URE Q3: Response Templating\n**Q:** \"How important is response templating (agent requests specific fields, proxy strips the rest) for MVP? The agent-sandbox.md spec includes it but it adds complexity.\"\n- (1) Essential for MVP — Agent should never see fields it didn't request (PII protection, minimizing attack surface).\n- (2) Defer to Phase 2 — MVP passes full response through. Add field filtering later. Domain binding is the critical security layer.\n\n**A:** \"Essential for MVP — Agent should never see fields it didn't request (PII protection, minimizing attack surface). But also, the response should NOT contain any auth / secrets. It should just contain that placeholder string. I imagine something similar to vaultwarden, where the secret has a templated form `agent-vault-\u003cuuid\u003e`, and the proxy searches for this, ingests it, replaces it on the proxy-side, and responses all replace the auth with this string when returned to the agent.\"\n\n#### URE Q4: Guest-Side Client\n**Q:** \"Should the guest-side client be a proper CLI tool, or is a simple shell wrapper (e.g., around socat/curl) sufficient for MVP?\"\n- (1) Shell wrapper (socat+curl) — Minimal: shell script that sends JSON over VSOCK via socat. Quick to build, easy to debug.\n- (2) Proper CLI tool — Compiled binary with arg parsing, error handling, structured output. More robust but more work.\n- (3) Library/SDK — Import-able library the agent's code calls directly. Most ergonomic but heaviest to build.\n\n**A:** \"Shell wrapper (socat+curl)\"\n\n#### URE Q5: Language Preference (Free-form)\n**Q:** (Prompted by initial plan proposing Rust)\n\n**A:** \"Whoa. I don't know about using Rust. Why would that be the case? I think using Zig, Gleam/Elixir, or Golang would be better. Let's consider. Which language has decent support for Keycloak and OpenBao? I also don't want to re-implement this 'secret-to-domain' allowable mapping, or even the proxy itself if I can avoid it. Let's see what exists already. I'm particularly interested in trying to use Temporal on the backend, as this will help with building the audit trail, the event sourcing, and the event-driven system for the proxy.\"\n\n#### URE Q6: Language Confirmation (after research)\n**Q:** \"Given the research, Go is the only language with production-grade support for all three key dependencies (Temporal, OpenBao, OIDC). Are you okay with Go, or do you want to explore a polyglot approach (e.g., Go for the proxy, Gleam/Elixir for something else)?\"\n- (1) Go (Recommended) — Monolingual. First-party Vault client, tier 1 Temporal SDK, excellent OIDC + VSOCK + Nix support.\n- (2) Polyglot approach — Go for the proxy core, but use another language for some component (e.g., Gleam for a future API layer).\n- (3) Need more info — I want to dig deeper into one of the alternatives before deciding.\n\n**A:** \"Go (Recommended)\"\n\n#### URE Q7: Placeholder Pattern\n**Q:** \"For the credential placeholder pattern: should placeholders be per-credential-ref (e.g., `{{vault:openclaw/api/key}}`) or opaque UUIDs (e.g., `agent-vault-a1b2c3d4`) that map to credentials via a separate config?\"\n- (1) Opaque UUIDs — Agent sees `agent-vault-\u003cuuid\u003e`. Mapping from UUID to credential ref + domain is stored in proxy config. Agent can't infer what the credential is.\n- (2) Structured refs — Agent sees `{{vault:path/to/secret}}`. More readable, agent knows what credential it's using, but leaks the secret path.\n- (3) Agent-chosen aliases — Agent uses human-readable aliases like `my-api-key`. Proxy maps alias to credential ref + domain. Flexible but requires alias management.\n\n**A:** \"Opaque UUIDs\"\n\n#### URE Q8: Temporal Deployment\n**Q:** \"For Temporal deployment on NixOS: `temporal-cli` is in nixpkgs and includes a dev server with SQLite. For production, you'd want PostgreSQL-backed. Which path for the MVP?\"\n- (1) temporal-cli dev server — Single binary, SQLite, includes web UI. Simplest. Good enough for single-host with a few VMs. Can migrate to PostgreSQL later.\n- (2) Podman container — Use official temporalio/auto-setup Docker image in Podman. More production-like but adds container dependency.\n- (3) Full PostgreSQL setup — Build a proper NixOS module for Temporal with PostgreSQL backend. Most work upfront but most production-ready.\n\n**A:** \"temporal-cli dev server\"\n\n#### URE Q9: Credential Provisioning\n**Q:** \"How should placeholder-to-credential mappings be provisioned to the agent inside the VM? The agent needs to know which placeholder string to use for which service.\"\n- (1) Environment variables — Inject placeholders as env vars (e.g., ANTHROPIC_API_KEY=agent-vault-abc123). Agent code uses them naturally.\n- (2) Config file via fw_cfg — JSON config file passed through QEMU fw_cfg (like existing openclaw-config). Lists all available placeholders and their target services.\n- (3) Query proxy at boot — Agent asks the proxy 'what credentials do I have?' over VSOCK and gets back a list of placeholder aliases and their allowed domains.\n\n**A:** \"Can do (1) and (2).\"\n\n#### URE Q10: Transport Protocol\n**Q:** \"For the VSOCK transport, should the proxy act as an HTTP forward proxy (agent sets HTTP_PROXY env var, needs MITM TLS for HTTPS) or use a simple JSON RPC (agent sends {url, method, headers, body} and proxy makes the actual request)?\"\n- (1) JSON RPC (Recommended) — Simple POST to proxy with request details as JSON. No TLS MITM needed. Clean placeholder substitution. Matches your shell wrapper preference.\n- (2) HTTP forward proxy — Standard HTTP proxy (CONNECT tunneling). More transparent but requires MITM CA cert for HTTPS inspection. Complex.\n- (3) Both modes — JSON RPC for MVP, add forward proxy mode later for agents that want transparent proxying.\n\n**A:** \"JSON RPC (Recommended)\"\n\n#### URE Q11: User Directive on Solution Research (Free-form)\n\n**A:** \"Agent-native and agentic software / MCP open-source projects are generally terrible. Look for pre-existing and established solutions that were well-accepted by the security community for our problem in a NON-agentic scenario. This is inherently a non-agentic problem.\"\n\n#### URE Q12: Build vs Wrap (Octelium)\n**Q:** \"Given the research, Octelium (Go, 3.4k stars, AGPLv3) is the closest existing solution with 'secretless access' and Go implementation. Should we evaluate integrating/wrapping Octelium, or build custom since our requirements (VSOCK, Temporal, placeholder pattern) diverge enough?\"\n- (1) Build custom (Recommended) — Our requirements (VSOCK, Temporal, placeholder pattern, domain binding) are sufficiently unique. Borrow design patterns from Octelium/Peta/Vultrino but build our own ~500 lines of Go core logic.\n- (2) Evaluate Octelium first — Clone Octelium, read its credential injection code, and assess if we can wrap/extend it. Risk: AGPLv3 license, may not be worth the effort if VSOCK+Temporal don't fit.\n- (3) Evaluate Peta Core first — Clone Peta, read its vault/injection code. Risk: TypeScript (not Go), ELv2 license, may not fit our architecture.\n- (4) Hybrid approach — Use Octelium as the access gateway layer and bolt Temporal + custom VSOCK listener on top. Most integration work but most reuse.\n\n**A:** \"Evaluate Octelium first\"\n\n#### URE Q13: Additional Research\n**Q:** \"Is there anything else you'd like me to research before finalizing the plan? The research confirmed no existing solution covers our needs, and Go + custom proxy is the path.\"\n- (1) Research is sufficient — You've seen enough. Let's finalize the plan and move to implementation.\n- (2) Dig into Vultrino source — Clone zachyking/vultrino and study its architecture in detail — borrow design patterns for our Go implementation.\n- (3) Explore goproxy more — Investigate whether elazarl/goproxy could serve as the proxy foundation (forward proxy mode instead of JSON RPC).\n- (4) Something else — I want to research a specific topic before we proceed.\n\n**A:** \"Explore goproxy more\"\n\n#### URE Q14: Proxy Mode (after goproxy research)\n**Q:** \"Given goproxy's capabilities, should we use it as a transparent forward proxy (agent just sets HTTP_PROXY and makes normal requests) or stick with JSON RPC? The forward proxy approach means zero agent code changes but requires MITM TLS with a custom CA cert installed in the VM.\"\n- (1) Forward proxy (goproxy) — Agent sets HTTP_PROXY env var, makes normal requests. goproxy does MITM TLS, placeholder substitution, domain enforcement. Requires installing custom CA cert in VM.\n- (2) JSON RPC (current plan) — Agent uses credproxy wrapper to send structured JSON. No TLS MITM needed. More explicit but requires agent to use the wrapper.\n- (3) Both modes — Build on goproxy as foundation. Support both forward proxy mode AND a /proxy JSON RPC endpoint. Agent can use whichever suits its needs.\n- (4) Need more info — I want to understand the tradeoffs better before deciding.\n\n**A:** \"Forward proxy (goproxy)\"\n\n#### URE Q15: Credential Pattern + Implementation (Rejected)\n**Q:** \"Secretless Broker uses a 'transparent proxy' pattern where the agent doesn't know about credentials AT ALL (just sets http_proxy). Your placeholder pattern (agent-vault-uuid) gives the agent explicit control over where credentials go. Which approach do you prefer?\" / \"For the proxy implementation: should we wrap/extend Secretless Broker (reuse its Vault provider, connector system, HTTP proxy), or build a custom thin proxy using the Go vault/api client directly (~500 lines)?\"\n\n**A:** (REJECTED — user wanted clarification first)\n\n#### URE Q16: Clarification Request\n**Q:** \"What would you like to clarify about the credential pattern choice (transparent proxy vs placeholder) or the implementation approach (Secretless Broker vs custom)?\"\n- (1) Explain transparent proxy more\n- (2) Explain placeholder pattern more\n- (3) Explain Secretless limitations\n- (4) I have a different idea\n(Multi-select)\n\n**A:** \"Explain transparent proxy more, Explain Secretless limitations, Can I self-host Secretless Broker? This all needs to be self-hostable\"\n\n#### URE Q17: Transport (VSOCK vs TAP)\n**Q:** \"Should the proxy listen on VSOCK (direct hypervisor channel, no IP networking) or on the TAP bridge IP (10.88.0.1:18790, reuse existing network, simpler)? The VM already has a TAP interface for host communication.\"\n- (1) TAP bridge (simpler) — Proxy listens on 10.88.0.1:18790. VM sets HTTP_PROXY=http://10.88.0.1:18790. Reuses existing TAP network. nftables restricts VM to only reach the proxy. No socat needed.\n- (2) VSOCK (more isolated) — Proxy listens on VSOCK CID:4 port:18790. Adds socat bridge in VM. Physically impossible for traffic to escape. But adds the socat bridge complexity.\n- (3) Both (belt and suspenders) — Proxy listens on both. TAP for the forward proxy (HTTP_PROXY). VSOCK as a fallback/admin channel. Maximum flexibility.\n\n**A:** \"VSOCK (more isolated)\"\n\n#### URE Q18: Secretless Broker Approach (Premature)\n**Q:** \"Given Secretless Broker's gaps (no response sanitization, no Temporal, weak domain binding, no rate limiting), which approach do you prefer?\"\n\n**A:** \"So far have been given no details on Secretless Broker, what it is\"\n\n#### URE Q19: Build vs Wrap (after Secretless explanation)\n**Q:** \"Now that you understand Secretless Broker: should we use it as the credential injection layer and build our custom features on top, or build our own proxy that borrows its patterns?\"\n- (1) Use Secretless + add layers — Run Secretless as the credential injection proxy. Build a Go middleware service in front that adds: VSOCK listener, domain binding enforcement, Temporal audit, response sanitization, rate limiting. Two processes, most code reuse.\n- (2) Custom proxy, inspired by SB — Build our own single Go binary (~500 lines core). Use vault/api directly for OpenBao. Borrow Secretless design (connector configs, provider abstraction) but own the full stack. One process, full control.\n- (3) Fork Secretless Broker — Fork the repo, add our features (VSOCK, domain binding, Temporal, response sanitization) directly into the codebase. Most reuse but we maintain a fork.\n- (4) Clone and evaluate first — Before deciding, clone the Secretless Broker repo to ~/codebases/ and read the actual Go code. Understand the architecture hands-on before committing to an approach.\n\n**A:** \"Use Secretless + add layers\"\n\n#### URE Q20: Response Sanitization Conflict\n**Q:** \"Given the response sanitization conflict with Secretless Broker, which tradeoff do you prefer?\"\n- (1) Single Go binary (current plan) — Our proxy fetches creds from OpenBao, injects into requests, AND scrubs from responses. One process, full control. Uses goproxy for HTTP proxy + mdlayher/vsock for transport. This is what the current plan file already describes.\n- (2) Secretless + skip sanitization — Use Secretless for injection. Accept that API responses may leak credentials. Rely on domain binding to limit exposure. Simpler (Secretless handles Vault), but weaker security.\n- (3) Secretless + parallel fetch — Use Secretless for injection AND separately fetch creds from OpenBao in our middleware for sanitization. Two Vault lookups per request (one by Secretless, one by us). Redundant but keeps separation.\n- (4) Clone Secretless, evaluate — Before deciding, clone the Secretless Broker repo and read how its credential provider works. Maybe we can extract the provider interface as a library.\n\n**A:** \"Single Go binary (current plan)\"\n\n### Session 2: Deeper Research and Architecture Refinement\n\n#### ExitPlanMode Rejection 1: Existing Solutions Research\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"Still need to do research about what exists, and how we can avoid re-implementing this. For example, vaultwarden exists. How is it different from OpenBao? Any other auth proxies exist that do NOT expose ANY secrets AT ALL to the clients?\"\n\n#### ExitPlanMode Rejection 2: Online Research Needed\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"Still need to do research. Still have not looked online and seen what exists.\"\n\n#### ExitPlanMode Rejection 3: VSOCK Purpose\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"Why do we even need VSOCK? What's the purpose or point of VSOCK?\"\n\n#### ExitPlanMode Rejection 4: Secretless vs goproxy\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"If we use Secretless Broker, do we need goproxy?\"\n\n#### ExitPlanMode Rejection 5: Envoy Inquiry\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"So, what about Envoy + ext_authz? What is that? What does that do? why was it deemed too heavyweight?\"\n\n### Session 3: Continued Deep Research\n\n#### ExitPlanMode Rejection 6: OpenBao vs Vaultwarden\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"This is looking very good indeed. However, does OpenBao not handle the 'secret-to-domain' mapping already? or does Vaultwarden? Why do we use OpenBao instead of Vaultwarden?\"\n\n#### ExitPlanMode Rejection 7: OpenBao Extensions\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"In some sense, the agent is a human, and it essentially needs a secretless broker-style password manager for use in the CLI and developing applications. OpenBao has nice attributes though. Has there been no attempts at extending OpenBao with this application-level logic?\"\n\n#### URE Q21: Riptides + Boundary Investigation\n**Q:** \"Riptides is the closest existing solution to what you described. Want me to dig deeper into it before we finalize, or are you satisfied that the custom goproxy approach is the right path given our specific requirements (VSOCK, response sanitization, Temporal audit, NixOS)?\"\n- (1) Finalize with goproxy — The research is thorough. Custom Go proxy with goproxy + OpenBao + Temporal is the right call — nothing existing covers all our requirements.\n- (2) Investigate Riptides — Dig deeper into Riptides — licensing, source availability, how kernel-level injection works, whether it could work inside a microVM with VSOCK.\n- (3) Investigate Boundary — Dig deeper into HashiCorp Boundary's credential injection — it's the 'official' Vault ecosystem approach even if HTTP API support is pending.\n\n**A:** \"Investigate deeper into both Riptides and Boundary. Is there an open-source alternative to Boundary? Must be self-hostable. Surprised the security and privacy communities haven't developed anything here yet.\"\n\n#### URE Q22: Ready to Finalize?\n**Q:** \"The research is thorough across 17 solutions. The gap is real — no OSS tool provides outbound HTTPS credential injection + response sanitization + VSOCK + audit. Ready to finalize the custom Go proxy plan, or is there another direction you want explored?\"\n- (1) Finalize plan — Research is complete. The custom Go proxy (goproxy + OpenBao + Temporal over VSOCK) fills a genuine gap. Ready to approve and move to implementation.\n- (2) Explore more — There's another solution category or specific tool I want investigated before committing.\n\n**A:** \"Explore more\"\n\n#### URE Q23: What to Explore\n**Q:** \"What area or tool would you like me to investigate further?\"\n- (1) Riptides deeper — Check if the kernel module could work in our microVM, or if their tokenex/SPIFFE approach is worth adopting without the kernel module.\n- (2) eBPF-based approach — Could we use eBPF (like Cilium, Falco, or custom) for transparent credential injection instead of a userspace proxy? Kernel-level but open source.\n- (3) Secretless Broker fork — Could we fork Secretless Broker and add HTTPS MITM + response sanitization + VSOCK rather than building from scratch?\n- (4) WASM/plugin proxy — Investigate proxy architectures with plugin systems (WASM, Go plugins) for extensibility — e.g., could we build something others could extend?\n(Multi-select)\n\n**A:** \"eBPF-based approach, Well, I think that we don't need a SINGLE tool that does both inbound and outbound secrets management and scrubbing. Couldn't we just have a gateway that delegates its inbound requests to the best-fitting inbound tool, and then outbound requests to the best-fitting outbound tool\"\n\n#### URE Q24: Architecture Decision\n**Q:** \"The composable gateway pattern is a better architecture than the original monolithic proxy. Do you want me to update the plan with this architecture, or dig into anything else?\"\n- (1) Update plan — Adopt composable gateway architecture. Single Go binary with CONNECT-based routing: outbound (goproxy + credential injection) and inbound (pluggable auth handler). Finalize plan.\n- (2) eBPF defense-in-depth — Also add an eBPF enforcement layer spec to the plan — guest-side eBPF program that blocks all outbound traffic except to proxy port.\n- (3) More research — There's something else I want explored before updating the plan.\n(Multi-select)\n\n**A:** \"Update plan, How is Pomerium versus Oathkeeper versus the other tools we've explored? It seems like our application will have 5 components: (1) the secret vault whose access MUST require authentication via (2) Keycloak auth from an OIDC JWT that then MUST be checked for (3) authorization application protocol that determines what secrets the authenticated identity can access and for what domain/protocol/purpose, who receives requests from a (4) inbound handler, and then sends out to a (5) outbound handler?\"\n\n#### URE Q25: Agent Authentication\n**Q:** \"For agent-to-proxy authentication, VSOCK CID gives implicit identity (the hypervisor assigns it, can't be spoofed from inside the VM). Is CID-based identity sufficient for MVP, or do you want full Keycloak OIDC JWT authentication from the agent through the proxy?\"\n- (1) VSOCK CID for MVP (Recommended) — CID is hypervisor-enforced, can't be spoofed. Each VM has a unique CID. Sufficient for single-agent or known-agent scenarios. Add OIDC later if multi-agent with different trust levels.\n- (2) Full OIDC from start — Agent authenticates to Keycloak, gets JWT, presents it in proxy-auth header. More complex but supports multi-agent with fine-grained identity from day 1.\n- (3) Both — CID + OIDC — Use CID for transport-level identity (which VM), OIDC for application-level identity (which agent/role). Defense in depth.\n\n**A:** \"Both — CID + OIDC\"\n\n#### URE Q26: OIDC Revision (Free-form)\n**Q:** (Unprompted user correction following Q25)\n\n**A:** \"Wait actually nevermind, we should only require the Keycloak OIDC JWT\"\n\n---\n\n### Derived Requirements Summary\n\n| Requirement | Decision | Source |\n|------------|----------|--------|\n| Language | Go | Q5, Q6 |\n| Orchestration | Temporal from day 1 (temporal-cli dev server) | Q1, Q8 |\n| Credential pattern | Placeholder substitution (opaque UUIDs: `agent-vault-\u003cuuid\u003e`) | Q3, Q7 |\n| Proxy mode | HTTP forward proxy (goproxy + MITM TLS) | Q14 |\n| Transport | VSOCK (physically isolated) | Q17 |\n| Provisioning | Env vars + fw_cfg config | Q9 |\n| Deployment | Systemd service on host | Q2 |\n| Guest client | Shell wrapper (socat+curl) | Q4 |\n| Domain binding | Fail-closed enforcement | Q3 |\n| Response sanitization | Essential — scrub credentials from responses | Q3, Q20 |\n| Authentication | Keycloak OIDC JWT only (not CID) | Q25, Q26 |\n| Authorization | OPA embedded (Rego policies) | Q24 |\n| Architecture | 5-component composable gateway (single Go binary) | Q23, Q24 |\n| Build vs buy | Custom proxy (no existing solution fits) | Q11, Q12, Q19, Q20, Q21, Q22, Q23 |\n| Self-hostable | Required | Q16, Q21 |\n| Existing solutions | \"Agent-native / MCP projects are generally terrible. Look for pre-existing and established solutions.\" | Q11 |","notes":"URE COMPLETE (26 questions across 3 sessions). All user responses captured verbatim in description. Key decisions: Go language, Temporal from day 1, goproxy forward proxy with MITM TLS, VSOCK transport, opaque UUID placeholders, Keycloak OIDC JWT auth, OPA embedded authz, 5-component composable gateway architecture, single Go binary. 17+ existing solutions evaluated — none fit (VSOCK + MITM HTTPS + placeholder substitution + response sanitization + domain binding + Temporal). User directive: 'Agent-native / MCP projects are generally terrible — look for established security solutions.'","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T01:20:11.995480103-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T03:24:57.692270936-08:00","labels":["aura:user:elicit"],"dependencies":[{"issue_id":"nix-openclaw-vm-whp","depends_on_id":"nix-openclaw-vm-et5","type":"blocks","created_at":"2026-02-17T01:20:15.883143129-08:00","created_by":"David Huu Pham"}]}
