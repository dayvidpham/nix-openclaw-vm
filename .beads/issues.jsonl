{"id":"nix-openclaw-vm-0ei","title":"Fix credproxy-lockdown nftables to allow Tailscale/Headscale SSH traffic","description":"The credproxy-lockdown nftables chain (default.nix:569-584) drops ALL new outbound VM connections when credential proxy is enabled. This also blocks Tailscale/Headscale SSH access which the user needs for remote management.\n\nThe existing openclaw-vm-firewall table already marks VM traffic with Tailscale forwarding bit (0x00044F43). The lockdown chain needs to exempt Tailscale interface traffic.\n\nFix: Add a rule before the final drop:\n```\n# Allow Tailscale/Headscale traffic (SSH and other tailnet services)\niifname \"tailscale0\" accept\noifname \"tailscale0\" accept\n```\n\nOr better, accept traffic matching the Tailscale mark:\n```\nmeta mark \u0026 0x00040000 == 0x00040000 accept\n```\n\nThe cfg.tailscale options (hostname, loginServer, sshAuthorizedKeys, exitNode) are already configured. This is just the nftables exemption that's missing.\n\nFile: modules/openclaw-vm/default.nix (credproxy-lockdown chain, ~line 569)","status":"closed","priority":1,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T12:07:28.58043859-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:11.325922415-08:00","closed_at":"2026-02-17T14:37:11.325922415-08:00","close_reason":"Implemented by wave 2 workers"}
{"id":"nix-openclaw-vm-14h","title":"Fix OPA identity.roles path mismatch with Keycloak JWT","description":"Rego policy checks input.identity.roles but Keycloak JWTs have roles at realm_access.roles. handlers.go passes RawClaims (which has Keycloak structure), but Rego expects top-level roles. Tests mask this by constructing identity with top-level roles key. Will deny all requests in production. Fix: either transform RawClaims before passing to OPA (inject Roles from AgentIdentity), or update Rego to read input.identity.realm_access.roles.","status":"closed","priority":1,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:02.246414471-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T11:30:35.164040617-08:00","closed_at":"2026-02-17T11:30:35.164040617-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-1av","title":"REVIEW W2-3: Elegance and complexity review of wave 2 slices","description":"## Review Axis: Elegance and complexity matching\n\nReview ALL wave 2 slices for proportional complexity:\n\n### General criteria\n- Design the API you KNOW you will need (complete for known use cases)\n- Do not over-engineer (problem with 3 parts → ~3 part solution)\n- Do not under-engineer (genuinely complex problems deserve matching complexity)\n- Complexity proportional to innate problem complexity, not code volume\n\n### Slice 0 (h80): goleak + race detector\n- Are goleak ignores a temporary workaround or a permanent design smell?\n- Is checkPhase the right place for -race, or should it be a separate CI step?\n\n### Slice 1 (glo): Decision pipeline hardening\n- Is the select+timeout approach the right abstraction, or should DecisionCh be redesigned entirely (e.g., context-based cancellation)?\n- Is removing ValidateIdentity activity the right call, or does it lose Temporal retry benefits for JWKS failures?\n- Are the error types (DenialReason enum) complete for known use cases, or will new denial reasons require iota changes?\n- Is the roundtrip test appropriately scoped (not too broad, not too narrow)?\n\n### Slice 2 (5rc): TTL eviction\n- Is the sweeper goroutine the right pattern, or would time.AfterFunc per-entry be simpler (like connTokens)?\n- Is the sweep interval configurable? Should it be?\n- Is the TTL default (120s = 2x signal timeout) well-justified?\n\n### Slice 3 (m1b): nftables\n- Is interface-based (`oifname \"tailscale0\"`) the right approach vs mark-based?\n- Is the rule hardcoded to \"tailscale0\" or configurable via NixOS options?\n- Is conditional on cfg.tailscale.enable sufficient, or should there be a more explicit option?\n\n### Slice 4 (3mu): TLA+ model\n- Is the model at the right abstraction level (not too detailed, not too abstract)?\n- Are the invariants the ones that matter most for this system?\n- Is the model maintainable as the protocol evolves?\n\n### Cross-slice elegance\n- Is the overall architecture (5 slices touching 5 concerns) proportional to the problem?\n- Are there abstractions that should be shared across slices but aren't?\n- Are there premature abstractions that add complexity without value?","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T13:58:44.345735676-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:14.497204612-08:00","closed_at":"2026-02-17T14:37:14.497204612-08:00","close_reason":"Wave 2 reviews completed, findings captured as ruw/d5c/3f9","dependencies":[{"issue_id":"nix-openclaw-vm-1av","depends_on_id":"nix-openclaw-vm-h80","type":"blocks","created_at":"2026-02-17T13:58:51.884498337-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-1av","depends_on_id":"nix-openclaw-vm-glo","type":"blocks","created_at":"2026-02-17T13:58:51.914554243-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-1av","depends_on_id":"nix-openclaw-vm-5rc","type":"blocks","created_at":"2026-02-17T13:58:51.94614871-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-1av","depends_on_id":"nix-openclaw-vm-m1b","type":"blocks","created_at":"2026-02-17T13:58:51.972981239-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-1av","depends_on_id":"nix-openclaw-vm-3mu","type":"blocks","created_at":"2026-02-17T13:58:52.000097803-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-1l8","title":"Bundle Rego policies into Nix package via postInstall","description":"BLOCKING: authz/policies/credential_access.rego not copied into $out/share/policies by buildGoModule. default.nix expects policies at credproxy-pkg/share/policies. Proxy fails at startup because NewOPAEvaluator gets nonexistent directory.","status":"closed","priority":0,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:27:58.119270764-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T11:37:18.679336886-08:00","closed_at":"2026-02-17T11:37:18.679336886-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-2vh","title":"IMPL REVIEW: Credential proxy implementation plan review","description":"# Implementation Plan Review — Tracking Issue\n\nThree independent reviews of the credential-proxy implementation plan (nix-openclaw-vm-7xk) were conducted against three axes:\n\n1. **Correctness** (spirit and technicality to proposal/URD)\n2. **Test quality** (integration coverage, mock discipline, fixtures)\n3. **Elegance and complexity matching** (interface completeness, over/under-engineering)\n\n## Combined Top Findings\n\n| # | Finding | Source | Severity |\n|---|---------|--------|----------|\n| 1 | `vendorHash = null` breaks Nix build | Correctness | Blocking |\n| 2 | Rego policies not bundled in Nix package | Correctness | Blocking |\n| 3 | OPA `roles` path mismatch with Keycloak JWT | Correctness | Likely bug |\n| 4 | `ProxyRequestWorkflow` + `FetchAndForward` are dead code (~600 LOC) | Correctness + Elegance | Significant |\n| 5 | No body size limits — OOM risk | Elegance | High |\n| 6 | Compressed responses bypass scrubbing | Elegance | High |\n| 7 | No vault health check at startup | Elegance | Moderate |\n| 8 | No workflow tests (testsuite.TestWorkflowEnvironment) | Tests | High |\n| 9 | No HTTPS CONNECT integration test | Tests | High |\n| 10 | Mock types duplicated across packages | Tests | Medium |\n| 11 | Phase 5 network lockdown not implemented | Correctness | Security gap |\n| 12 | fw_cfg provisioning not implemented (should source env vars) | Correctness | Missing feature |\n| 13 | No VM testing patterns documented in README/AGENTS | All | Documentation gap |\n\n## Disposition\n\nThis tracking issue is blocked by the three individual review issues, which are in turn blocked by leaf fix tasks.","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:26:44.947132466-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:43:46.75926361-08:00","closed_at":"2026-02-17T14:43:46.75926361-08:00","close_reason":"All review findings fixed: registry.Start wired, dead code removed, scrubCount accuracy fixed, 3 test gaps filled","dependencies":[{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-sil","type":"blocks","created_at":"2026-02-17T09:27:31.124990582-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-na4","type":"blocks","created_at":"2026-02-17T09:27:44.01765733-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-g5f","type":"blocks","created_at":"2026-02-17T09:28:01.671987373-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-h80","type":"blocks","created_at":"2026-02-17T13:39:14.368665117-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-glo","type":"blocks","created_at":"2026-02-17T13:39:14.395982487-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-5rc","type":"blocks","created_at":"2026-02-17T13:39:14.422951379-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-m1b","type":"blocks","created_at":"2026-02-17T13:39:14.450068551-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-3mu","type":"blocks","created_at":"2026-02-17T13:39:14.476860801-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-8te","type":"blocks","created_at":"2026-02-17T13:58:52.027304908-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-ddc","type":"blocks","created_at":"2026-02-17T13:58:52.054787322-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-1av","type":"blocks","created_at":"2026-02-17T13:58:52.083562453-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-ruw","type":"blocks","created_at":"2026-02-17T14:37:19.264372676-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-d5c","type":"blocks","created_at":"2026-02-17T14:37:19.311139406-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-3f9","type":"blocks","created_at":"2026-02-17T14:37:19.340597204-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-32d","title":"Enable -race flag for Go tests in CI and dev workflow","description":"The RequestRegistry uses sync.Map + channels shared between goproxy goroutines and Temporal local activities. The race detector catches data races at runtime.\n\nChanges:\n1. Add `-race` to `go test` invocations in flake.nix checkPhase\n2. Document `go test -race ./...` in AGENTS.md test section\n3. Ensure CI runs tests with -race enabled\n\nNote: -race adds ~2-10x overhead so may want a separate CI step for race-enabled tests.","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T11:43:57.622119254-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:11.314691641-08:00","closed_at":"2026-02-17T14:37:11.314691641-08:00","close_reason":"Implemented by wave 2 workers"}
{"id":"nix-openclaw-vm-34h","title":"Study OpenBao KV v2 API and policy model for credential proxy","description":"Study OpenBao (Vault-compatible) to understand how credential-proxy will store and retrieve secrets. Focus areas: KV v2 secret engine (data envelope structure), policy language (path-based ACLs for read-only proxy access), AppRole auth method for service authentication, token renewal/revocation, secret versioning, and NixOS module integration (openbao service, policy provisioning).","notes":"Research completed. Report written to docs/research/openbao.Rmd. Key findings: KV v2 data.data envelope confirmed working; typed KVv2 API available for upgrade; AppRole auth with periodic tokens recommended for production; LifetimeWatcher provides automatic renewal with backoff; audit logs HMAC-hash all secret values; Transit engine available for future caching; NixOS policy module already provisions credproxy-readonly; OpenBao API endpoints identical to Vault.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:16:28.277963018-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:29:13.334172774-08:00","closed_at":"2026-02-17T08:29:13.334172774-08:00","close_reason":"Research completed, reports written to docs/research/"}
{"id":"nix-openclaw-vm-35e","title":"PROPOSAL: Credential proxy implementation plan","description":"# Credential Proxy Security Layer — Implementation Plan\n\n**Beads**: `nix-openclaw-vm-7xk` (epic), `nix-openclaw-vm-et5` (request), `nix-openclaw-vm-whp` (URE)\n\n---\n\n## Research Findings\n\n### Existing Solutions Evaluated\n\n| Solution | What It Does | Domain Binding | VSOCK | Verdict |\n|----------|-------------|----------------|-------|---------|\n| [Vultrino](https://github.com/zachyking/vultrino) | Rust credential proxy for AI agents. Alias-based refs, MCP server, WASM plugins. 6 stars, Jan 2026. | No (glob scoping only) | No | **Design reference only**. Too immature, Rust (rejected), no domain binding. |\n| [Agent Gateway](https://github.com/agentgateway/agentgateway) | Rust MCP/A2A gateway. Linux Foundation. RBAC, JWT, header manipulation. | No | No | **Wrong purpose**. Inbound agent-to-tool routing, NOT outbound credential injection. |\n| [elazarl/goproxy](https://github.com/elazarl/goproxy) | Go HTTP proxy library. MITM HTTPS, per-host handlers, request/response modification. 6.6k stars, BSD-3, 10+ years. | N/A (library) | Yes (custom `net.Listener`) | **Foundation library**. Implements `http.Handler` — serves on any listener including VSOCK. |\n| Envoy + ext_authz | C++ L7 proxy (CNCF). ext_authz calls external service for auth + header injection. In nixpkgs. | Header-only (ext_authz can't modify bodies) | No (TCP/Unix only) | **Wrong tool.** ext_authz injects headers but cannot modify request/response bodies. MITM HTTPS is experimental (no cert generation). No VSOCK. Would still need custom Go for body substitution, response scrubbing, Temporal, OpenBao — making Envoy pure overhead (3 moving parts instead of 1). |\n| Vault/OpenBao Agent | Proxies requests TO vault, not outbound. | N/A | No | **Backend only**. Use OpenBao for secret storage. |\n| [Secretless Broker](https://github.com/cyberark/secretless-broker) | Go HTTP forward proxy by CyberArk. Injects credentials from Vault/Conjur into outbound HTTP. Plugin arch (Providers + Connectors). Apache 2.0, 366 stars, v1.7.32 Feb 2026, maintained since 2018. 25+ pre-built API configs. | URL regex matching, per-connector-port | No (tcp/unix only) | **Closest existing solution but 3 blockers**: (1) Rejects CONNECT with 405 — cannot MITM HTTPS; (2) No response sanitization — \"app never sees secrets\" model conflicts with our need to scrub credentials from API responses; (3) No VSOCK or Temporal. |\n| [Octelium](https://github.com/octelium/octelium) | Go zero-trust access platform. L7-aware \"secretless access\" — injects API keys, Bearer, OAuth2, Sigv4 per-upstream. CEL/OPA policy-as-code. 3.4k stars, AGPLv3. | Per-service routing + CEL policies | No | **Too heavyweight + AGPLv3**. Full platform (VPN, ZTNA, PaaS, MCP gateway). No response sanitization documented. No VSOCK. |\n| [Envoy credential_injector](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/credential_injector_filter) | Native Envoy filter. Injects credentials from SDS into outbound requests. First-class in Envoy Gateway v1.4+. | Via routing rules / HTTPRouteFilter | No | **Kubernetes-centric, heavyweight**. Requires full Envoy. No response sanitization. |\n| [Ory Oathkeeper](https://www.ory.com/docs/oathkeeper) | Go zero-trust proxy. Per-domain access rules, header/JWT injection, CNCF ecosystem. | Per-rule domain matching | No | **Inbound-focused**. Designed for authenticating users TO your services, not injecting creds into outbound API calls. |\n| [Peta Core](https://github.com/dunialabs/peta-core) | TypeScript MCP gateway. Server-side vault with JIT decryption (30s TTL), short-lived agent tokens, HITL approvals. 28 stars, ELv2. | No | No | **TypeScript (not Go), ELv2 license**. Custom vault (not OpenBao). No domain binding. Design reference for JIT decryption + audit patterns. |\n| [Riptides](https://riptides.io/) | **Proprietary** kernel module for on-the-wire credential injection. kTLS + SPIFFE identity. Go userspace agent for OPA policy evaluation. Intercepts outbound IP sockets before TLS. | Per-process SPIFFE scoping | No (IP sockets only, not AF_VSOCK) | **Proprietary, no VSOCK, no response sanitization.** Core kernel module is closed-source. Plans to open-source \"the core\" but hasn't. Uses Lima VMs (TAP networking) — likely incompatible with VSOCK-only microVMs. No response scrubbing. No Temporal. Design reference for on-the-wire injection timing + SPIFFE identity. |\n| [Boundary](https://developer.hashicorp.com/boundary) (HashiCorp) | Credential brokering + injection for SSH, RDP, databases. Controller+Worker model. BSL 1.1. | Per-target | No | **3 blockers**: (1) BSL license (not truly OSS since 2023); (2) Credential injection is **Enterprise/HCP-only** — community edition only has brokering; (3) HTTP API injection is [not implemented](https://github.com/hashicorp/boundary/issues/5273) — only SSH, RDP, DB targets supported. |\n| [Pomerium](https://www.pomerium.com/) | Zero-trust access proxy. JWT injection + Vault integration. Apache 2.0. | Per-route | No | **Inbound-focused + JWT only.** Authenticates users TO apps. Can inject JWTs but not arbitrary API keys/headers into outbound requests. |\n| [Teleport](https://goteleport.com/) | Secure access platform. REST API access with JWT injection. Elastic v2/AGPL. | Per-app | No | **Restrictive license + JWT only.** Elastic v2 is not OSS. Same JWT-only limitation as Pomerium. |\n\n**Conclusion**: No existing solution provides our required combination (VSOCK + MITM HTTPS + placeholder substitution + response sanitization + domain binding + Temporal audit). CyberArk Secretless Broker was closest but has fundamental conflicts with response sanitization (its \"app never sees secrets\" model means it can't scrub credentials from API responses). Build custom Go proxy using [goproxy](https://github.com/elazarl/goproxy) as the HTTP proxy foundation and [mdlayher/vsock](https://github.com/mdlayher/vsock) as the transport. Borrow design patterns from Secretless (Vault provider, connector configs) and Peta (JIT decryption, audit trail) without taking the dependencies.\n\n### Go Libraries\n\n| Library | Component | Purpose | Status |\n|---------|-----------|---------|--------|\n| [`elazarl/goproxy`](https://github.com/elazarl/goproxy) | (4)(5) Gateway | HTTP/HTTPS forward proxy with MITM | 6.6k stars, BSD-3, 10+ years |\n| [`mdlayher/vsock`](https://github.com/mdlayher/vsock) | (4) Transport | AF_VSOCK `net.Listener` | v1 stable, updated Jan 2025 |\n| [`coreos/go-oidc/v3`](https://github.com/coreos/go-oidc) | (2) Authentication | Keycloak JWT validation via JWKS | Industry standard |\n| [`open-policy-agent/opa/rego`](https://pkg.go.dev/github.com/open-policy-agent/opa/rego) | (3) Authorization | Rego policy evaluation (embedded) | CNCF graduated, \u003c10ms P99 |\n| [`openbao/openbao/api/v2`](https://pkg.go.dev/github.com/openbao/openbao/api) | (1) Secret vault | OpenBao client (Vault API compat) | Official, maintained |\n| [`temporalio/sdk-go`](https://go.temporal.io/sdk) | Full lifecycle orchestration | Workflows, activities, signals, search attributes | Tier 1, v1.29+, production-grade |\n| `temporal-cli` | Infrastructure | Temporal dev server | [In nixpkgs](https://www.nixhub.io/packages/temporal-cli) |\n\n### Auth/Authz Tool Evaluation\n\nPomerium, Ory Oathkeeper, and OPA were evaluated for components (2) and (3):\n\n| Tool | Keycloak OIDC | Embeddable | Forward proxy (CONNECT) | Authz model | Verdict |\n|------|--------------|------------|------------------------|-------------|---------|\n| **Pomerium** | Native (redirect flow) | **No** — standalone only | Partial (needs pomerium-cli) | PPL (YAML) + Rego | **Too heavy**. Can't embed, requires separate process. |\n| **Oathkeeper** | JWT validation | **Yes** (gRPC middleware) | **No** | Rules + remote authorizer | **No CONNECT**. Good mutators but wrong proxy mode. |\n| **OPA (embedded)** | JWT decode in Rego | **Yes** (library) | N/A (policy engine) | Rego (very flexible) | **Winner for (3).** \u003c10ms, embeddable, expressive. |\n| **coreos/go-oidc** | JWKS validation | **Yes** (library) | N/A | N/A | **Winner for (2).** Simple, 5 lines of code. |\n\n**Decision:** Use `coreos/go-oidc` for JWT validation + `OPA embedded` for authorization policy. Skip Pomerium and Oathkeeper — they don't handle CONNECT, and their auth can be done more simply with direct libraries.\n\n### Language Elimination\n\n| Language | Temporal SDK | Vault Client | OIDC | VSOCK | Verdict |\n|----------|-------------|-------------|------|-------|---------|\n| **Go** | Tier 1 | First-party | Excellent | `mdlayher/vsock` | **Winner** |\n| Rust | Alpha | Community | Good | Available | User rejected; Temporal experimental |\n| Gleam/Elixir | **None** | Poor | Fair | **None** | Eliminated |\n| Zig | **None** | **None** | **None** | Syscall | Eliminated |\n\n---\n\n## Context\n\nThe openclaw-vm gives an AI agent a sandboxed microVM with VSOCK-only host communication. Currently, the agent needs API credentials passed in directly (via fw_cfg), meaning a compromised agent could exfiltrate secrets. This plan builds a **transparent forward proxy** on the host that:\n\n- Listens on **VSOCK** (hypervisor-level socket — physically cannot reach the internet, no IP routing)\n- Acts as a standard HTTP forward proxy — agent just sets `HTTP_PROXY` / `HTTPS_PROXY` env vars\n- **Intercepts HTTPS** via MITM TLS with a custom CA cert installed in the VM\n- Detects **opaque placeholder strings** (`agent-vault-\u003cuuid\u003e`) in request headers/body\n- **Replaces placeholders with real credentials** fetched from OpenBao\n- Enforces **domain binding** (credential X only works for domain Y, fail-closed)\n- **Scrubs credentials from responses** (replaces real values back with placeholders)\n- Records every credential access as a **Temporal workflow** for audit/replay\n\n**Why VSOCK?** Unlike TAP networking (which relies on nftables rules that could be misconfigured), VSOCK is a direct guest↔host channel provided by the hypervisor. Traffic on VSOCK physically cannot be routed to the internet — it's not an IP socket. This provides defense-in-depth: even if firewall rules are wrong, credentials can only flow through the proxy.\n\n---\n\n## Key Decisions\n\n| Decision | Choice | Rationale |\n|----------|--------|-----------|\n| Language | **Go** | First-party Vault client, tier-1 Temporal SDK, goproxy library, VSOCK support |\n| Architecture | **Composable 5-component gateway** | Separation of concerns: auth, authz, vault, inbound, outbound. Single Go binary. |\n| Proxy foundation | **goproxy, not Secretless Broker** | Secretless rejects CONNECT (405) — no MITM HTTPS. goproxy handles MITM natively. |\n| Authentication | **Keycloak OIDC JWT via `coreos/go-oidc`** | Agent presents JWT in `Proxy-Authorization` header. Proxy validates against Keycloak JWKS. Pomerium/Oathkeeper evaluated but too heavy (can't embed, wrong proxy mode). |\n| Authorization | **OPA embedded (Rego policies)** | Evaluates \"identity X with role Y can use credential Z for domain D\". \u003c10ms P99, embeddable library. |\n| Proxy mode | **Transparent forward proxy** (goproxy) | Agent sets `HTTP_PROXY` env var. Zero agent code changes. |\n| HTTPS handling | **MITM with custom CA** | goproxy's `ConnectMitm` action. CA cert installed in VM at build time. |\n| Credential pattern | **Placeholder substitution** | `agent-vault-\u003cuuid\u003e` strings in headers/body. Proxy replaces outbound, scrubs inbound. |\n| Orchestration | **Temporal as access decision orchestrator** | Every proxy access attempt = `ProxyAccessDecision` workflow. Authn → authz → credential path resolution are activities. goproxy owns HTTP lifecycle; Temporal owns the decision pipeline. Audit trail, replay, retries, rate limiting. See [temporal-agent-orchestration.Rmd](docs/research/temporal-agent-orchestration.Rmd). |\n| Provisioning | **Env vars + fw_cfg** | `ANTHROPIC_API_KEY=agent-vault-abc123` + JSON config listing all placeholders. |\n| Deployment | **Systemd service** on host | Direct VSOCK access, systemd hardening. |\n| Temporal hosting | **temporal-cli dev server** | In nixpkgs. SQLite-backed. Upgrade to PostgreSQL later. |\n| Domain enforcement | **OPA policy + goproxy `DstHostIs()`** | OPA for fine-grained authz, goproxy for fail-closed domain allowlist. |\n\n---\n\n## Architecture (Temporal-Orchestrated Access Decision Gateway)\n\ngoproxy owns the HTTP lifecycle (CONNECT, MITM TLS, request/response forwarding).\nTemporal owns the access decision pipeline (authn, authz, credential path resolution).\nSecret values never enter Temporal event history — only credential *paths* flow through workflows.\n\n```\nGuest VM (zero external network)                Host (NixOS)\n┌──────────────────────────────┐    VSOCK     ┌──────────────────────────────────────────────┐\n│ Agent                        │  CID:4       │ credproxy (Single Go Binary)                  │\n│  HTTP_PROXY=localhost:18790  │  port:18790  │                                               │\n│  HTTPS_PROXY=localhost:18790 │ ──────────▶  │  GOPROXY (HTTP lifecycle)    TEMPORAL WORKER   │\n│                              │              │  ┌───────────────────┐  ┌──────────────────┐  │\n│ Keycloak JWT in              │              │  │ HandleConnect:    │  │ ProxyRequest WF: │  │\n│  Proxy-Authorization header  │              │  │  domain allowlist │  │  1.ValidateIdent │  │\n│                              │              │  │  + JWT extraction │  │  2.EvaluatePolicy│  │\n│ Makes normal HTTP(S) calls:  │              │  │                   │  │  3.FetchAndInject│  │\n│  curl -H \"x-api-key:         │              │  │ OnRequest:        │  │    (local act,   │  │\n│   agent-vault-abc123\"        │              │  │  register in      │  │    vault fetch,  │  │\n│   https://api.anthropic.com  │              │  │  RequestRegistry ─┼──▶   modify req)   │  │\n│                              │              │  │  start workflow   │  │  4.Wait signal   │  │\n│                              │              │  │  block on ch ◀────┼──┤  \"response_done\" │  │\n│                              │              │  │  forward request  │  │  5.Finalize audit│  │\n│                              │  ◀────────── │  │                   │  └──────────────────┘  │\n│ socat VSOCK↔localhost bridge │   response   │  │ OnResponse:       │                        │\n│ CA cert: /etc/ssl/credproxy  │  (sanitized) │  │  scrub creds      │     RequestRegistry    │\n└──────────────────────────────┘              │  │  signal workflow ──▶    (sync.Map:          │\n                                              │  └───────────────────┘     reqID→*http.Req    │\n                                              │                            + ScrubMap)         │\n                                              └──────┬──────┬──────────┬───────────────────────┘\n                                                     │      │          │\n                                                ┌────▼──┐┌──▼───┐┌───▼──────────┐\n                                                │OpenBao││Keyclk││ Temporal     │\n                                                └───────┘└──────┘└──────────────┘\n```\n\n---\n\n## Request Flow (Temporal Full-Lifecycle Orchestration)\n\n```\n1. Agent authenticates to Keycloak, receives JWT.\n   Agent makes normal HTTPS request with JWT:\n     curl -H \"x-api-key: agent-vault-abc123\" \\\n          -H \"Proxy-Authorization: Bearer \u003cjwt\u003e\" \\\n          https://api.anthropic.com/v1/messages\n\n2. curl respects HTTP_PROXY=http://localhost:18790\n   → Sends CONNECT api.anthropic.com:443 to proxy (with Proxy-Authorization header)\n\n3. socat in VM bridges localhost:18790 → VSOCK CID:4 port:18790 → Host\n\n4. GOPROXY HandleConnect:\n   a. Extract Proxy-Authorization JWT, store in connTokens\n   b. Is api.anthropic.com in domain allowlist?\n      NO  → ConnectReject\n      YES → ConnectMitm (MITM intercept with custom CA)\n\n5. goproxy decrypts the HTTPS request via MITM TLS.\n\n6. GOPROXY OnRequest handler:\n   a. Retrieve JWT from connTokens\n   b. Extract placeholders from headers + body (regex: agent-vault-[a-f0-9-]{36})\n   c. If no placeholders → pass through (no workflow needed)\n   d. Register RequestContext in RequestRegistry (request ID → *http.Request + chan)\n   e. Start Temporal workflow: ProxyRequestWorkflow\n\n7. TEMPORAL WORKFLOW: ProxyRequestWorkflow\n   Input: { requestID, rawJWT, placeholders[], targetDomain }\n   Search attributes set immediately: TargetDomain, Status=in_progress\n\n   7a. Activity: ValidateIdentity (regular — JWKS needs network)\n       - Verify JWT signature, issuer, audience, expiry via Keycloak JWKS\n       - Extract claims: { sub, roles, groups }\n       - Returns: IdentityClaims (safe for event history)\n       INVALID → workflow finalizes as denied, sends denial on DecisionCh\n\n   7b. Local Activity: EvaluatePolicy (OPA is in-process)\n       - Input: { identity claims, placeholders, target_domain }\n       - Resolves credential bindings from config\n       - Evaluates Rego policy: identity.roles → credential → domain\n       DENIED → workflow finalizes as denied, sends denial on DecisionCh\n\n   7c. Local Activity: FetchAndInject (vault fetch + request modification)\n       - Looks up RequestContext from RequestRegistry by requestID\n       - Resolves vault paths from config\n       - Fetches real credentials from OpenBao\n       - Replaces placeholders in *http.Request headers/body (in-place)\n       - Populates RequestContext.ScrubMap (realValue → placeholder)\n       - Sends \"allowed\" decision on DecisionCh (unblocks goproxy)\n       - Returns: InjectResult { credentialCount } (no secrets in output)\n\n   7d. Workflow waits for \"response_complete\" signal (up to 60s timeout)\n\n8. GOPROXY (unblocked by DecisionCh):\n   a. Request was already modified in-place by FetchAndInject\n   b. Forward modified request to api.anthropic.com\n   c. Receive response\n\n9. GOPROXY OnResponse handler:\n   a. Scan response body for real credential values (using ScrubMap from registry)\n   b. Replace any found values with their placeholder strings\n   c. Clean up connTokens entry\n   d. Signal workflow: \"response_complete\" with { statusCode, scrubCount, bytes }\n   e. Return sanitized response through MITM TLS → VSOCK → Agent\n\n10. TEMPORAL WORKFLOW receives signal, updates search attributes, completes.\n    Full audit trail: agentID, targetDomain, credentialCount, scrubCount,\n    statusCode, latencyMs, allowed/denied status — all queryable via\n    Temporal's search attribute API.\n```\n\n---\n\n## goproxy Integration Details\n\n### Responsibility Split: goproxy vs Temporal\n\n| Concern | Owner | Rationale |\n|---------|-------|-----------|\n| CONNECT handling, domain allowlist | goproxy | Must happen before MITM; no benefit from durability |\n| JWT extraction from headers | goproxy | Parsing only — deterministic, no I/O |\n| Placeholder extraction from body/headers | goproxy | Parsing only — deterministic, no I/O |\n| JWT verification (JWKS) | Temporal activity | Network I/O (JWKS fetch), benefits from retry |\n| OPA policy evaluation | Temporal activity | May timeout, benefits from retry + audit |\n| Credential path resolution | Temporal activity | Config lookup with audit trail |\n| Vault secret fetch | Temporal local activity (`FetchAndInject`) | In-process via RequestRegistry; secrets never serialized |\n| Placeholder→credential substitution | Temporal local activity (`FetchAndInject`) | Modifies `*http.Request` in-place via RequestRegistry |\n| HTTP forwarding | goproxy | Owns the HTTP lifecycle |\n| Response credential scrubbing | goproxy + Temporal signal | goproxy scrubs; signals workflow with outcome metadata |\n| Audit recording | Temporal (workflow lifecycle + search attributes) | Full lifecycle: authn, authz, inject, forward, scrub |\n\n### Handler Registration\n\n```go\n// HandleConnect: domain allowlist + JWT extraction (no Temporal yet)\nproxy.OnRequest().HandleConnect(goproxy.FuncHttpsHandler(\n    func(host string, ctx *goproxy.ProxyCtx) (*goproxy.ConnectAction, string) {\n        domain := stripPort(host)\n        if !gw.cfg.IsAllowedDomain(domain) {\n            return goproxy.RejectConnect, host\n        }\n        gw.connTokens.Store(ctx.Req.RemoteAddr, extractBearerToken(\n            ctx.Req.Header.Get(\"Proxy-Authorization\")))\n        return goproxy.MitmConnect, host\n    }))\n\n// OnRequest: register context → start Temporal workflow → block on decision\nproxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n    rawToken := gw.resolveToken(req)\n    if rawToken == \"\" {\n        return req, errorResponse(req, 407, \"missing authentication token\")\n    }\n    req.Header.Del(\"Proxy-Authorization\")\n\n    placeholders, _ := Extract(req)\n    if len(placeholders) == 0 {\n        return req, nil // No credentials needed — pass through\n    }\n\n    // Register request in shared registry for local activities\n    requestID := generateRequestID()\n    decisionCh := make(chan *WorkflowDecision, 1)\n    reqCtx := \u0026RequestContext{Request: req, DecisionCh: decisionCh}\n    gw.registry.Store(requestID, reqCtx)\n    defer gw.registry.Delete(requestID)\n\n    // Start Temporal workflow (stays alive until response_complete signal)\n    targetDomain := stripPort(req.Host)\n    run, err := gw.temporal.ExecuteWorkflow(bgCtx, client.StartWorkflowOptions{\n        ID:        fmt.Sprintf(\"proxy-%s-%s\", targetDomain, requestID),\n        TaskQueue: gw.cfg.Temporal.TaskQueue,\n    }, workflows.ProxyRequestWorkflow, workflows.ProxyInput{\n        RequestID:    requestID,\n        RawJWT:       rawToken,\n        Placeholders: placeholders,\n        TargetDomain: targetDomain,\n    })\n\n    // Block until FetchAndInject activity signals decision (NOT run.Get())\n    decision := \u003c-decisionCh\n    if decision.Status != StatusAllowed {\n        return req, errorResponse(req, 403, decision.Reason)\n    }\n\n    // Request was modified in-place by FetchAndInject. ScrubMap populated.\n    ctx.UserData = \u0026requestState{\n        scrubMap:   reqCtx.ScrubMap,\n        workflowID: run.GetID(),\n        runID:      run.GetRunID(),\n    }\n    return req, nil\n})\n\n// OnResponse: scrub credentials, then signal workflow completion\nproxy.OnResponse().DoFunc(func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n    state := ctx.UserData.(*requestState)\n    scrubCount := ScrubCredentials(resp, state.scrubMap)\n\n    // Signal workflow that response is handled — completes the audit trail\n    gw.temporal.SignalWorkflow(bgCtx, state.workflowID, state.runID,\n        \"response_complete\", ResponseOutcome{\n            StatusCode:       resp.StatusCode,\n            ScrubCount:       scrubCount,\n            BytesTransferred: resp.ContentLength,\n        })\n\n    return resp\n})\n```\n\n### Custom CA Certificate\n\nGenerated at NixOS build time:\n```nix\n# In modules/credential-proxy/default.nix\npkgs.runCommand \"credproxy-ca\" { buildInputs = [ pkgs.openssl ]; } ''\n  openssl req -x509 -newkey ec -pkeyopt ec_paramgen_curve:prime256v1 \\\n    -keyout $out/ca.key -out $out/ca.crt -days 3650 -nodes \\\n    -subj '/CN=Credential Proxy CA/O=openclaw-vm'\n''\n```\n\nInstalled in guest VM:\n```nix\n# In guest.nix\nsecurity.pki.certificateFiles = [ \"${credproxyCa}/ca.crt\" ];\n```\n\n---\n\n## File Structure\n\n### Go Service: `credential-proxy/`\n\n```\ncredential-proxy/\n├── go.mod\n├── go.sum\n├── main.go                        # Entry: VSOCK listener, goproxy setup, Temporal worker\n├── config/\n│   └── config.go                  # Config types, YAML loading, domain allowlist\n├── auth/\n│   └── oidc.go                    # (2) Keycloak JWT validation (coreos/go-oidc wrapper)\n├── authz/\n│   ├── engine.go                  # (3) OPA embedded policy evaluator\n│   └── policies/\n│       └── credential_access.rego # Rego policy: identity → credential → domain\n├── proxy/\n│   ├── gateway.go                 # Composable gateway router (CONNECT → outbound)\n│   ├── handlers.go                # goproxy OnRequest/OnResponse + signal workflow\n│   ├── registry.go                # RequestRegistry: shared state between goproxy and Temporal\n│   ├── placeholder.go             # Placeholder extraction + substitution (regex)\n│   └── sanitizer.go               # Response credential scrubbing\n├── vault/\n│   └── client.go                  # (1) OpenBao client wrapper (DI-friendly interface)\n├── workflows/\n│   ├── proxy_workflow.go          # ProxyAccessDecision workflow (authn→authz→resolve)\n│   └── activities.go              # ValidateIdentity, EvaluatePolicy, ResolveCredentialPaths\n└── audit/\n    └── search_attributes.go       # Temporal search attribute definitions\n```\n\n### NixOS Modules: `modules/credential-proxy/`\n\n```\nmodules/credential-proxy/\n├── default.nix                    # Host: proxy service + Temporal + CA generation\n├── guest.nix                      # Guest: VSOCK bridge, CA cert, HTTP_PROXY env\n└── openbao-policy.nix             # OpenBao read-only policy for proxy\n```\n\n### Modifications to Existing Files\n\n| File | Change |\n|------|--------|\n| `flake.nix` | Add `credential-proxy` Go package (`buildGoModule`), module imports, test-vm config |\n| `modules/openclaw-vm/default.nix` | Add `credentialProxy` option group, VSOCK port 18790, CA cert fw_cfg |\n| `modules/openclaw-vm/guest.nix` | VSOCK bridge for port 18790, `HTTP_PROXY`/`HTTPS_PROXY` env vars, CA cert install |\n\n---\n\n## Temporal Workflow Design\n\n### ProxyRequest Workflow — Full Lifecycle Orchestration\n\nThe workflow orchestrates the **entire proxy request lifecycle** — authentication,\nauthorization, credential injection, and response scrubbing audit. It stays alive for\nthe full HTTP request duration, receiving a completion signal from goproxy when the\nresponse has been scrubbed.\n\n**Key constraint**: goproxy owns the live `*http.Request` and `*http.Response` objects\n(they cannot be serialized into Temporal). Solution: a `RequestRegistry` (`sync.Map`)\nshared between goproxy and Temporal local activities. Activities reference requests by\nID; secrets flow through in-process memory, never through Temporal event history.\n\n```\nInput:  { requestID, rawJWT, placeholders[], targetDomain }\nOutput: { status, statusCode, credentialCount, scrubCount, latencyMs }\n\nSearch attributes: AgentID, TargetDomain, CredentialRefHash, Status\n\nSignals:\n  \"response_complete\" → { statusCode, scrubCount, bytesTransferred }\n```\n\n```go\nfunc ProxyRequestWorkflow(ctx workflow.Context, input ProxyInput) (*ProxyOutput, error) {\n    start := workflow.Now(ctx)\n    upsertSearchAttributes(ctx, \"\", input.TargetDomain, input.Placeholders, StatusInProgress)\n\n    // Phase 1: Validate identity (regular activity — JWKS may need network)\n    var identity IdentityClaims\n    err := workflow.ExecuteActivity(authnCtx, ValidateIdentity, input.RawJWT).Get(ctx, \u0026identity)\n    if err != nil {\n        return finalize(ctx, start, StatusDenied, \"authentication_failed\")\n    }\n    upsertSearchAttributes(ctx, identity.Subject, \"\", nil, \"\")\n\n    // Phase 2: Evaluate authorization policy (local activity — OPA is in-process)\n    var decision AuthzDecision\n    err = workflow.ExecuteLocalActivity(authzCtx, EvaluatePolicy, AuthzInput{\n        Identity: identity, Placeholders: input.Placeholders, TargetDomain: input.TargetDomain,\n    }).Get(ctx, \u0026decision)\n    if err != nil || !decision.Allowed {\n        return finalize(ctx, start, StatusDenied, decision.Reason)\n    }\n\n    // Phase 3: Fetch credentials from vault and inject into request (local activity)\n    // Accesses *http.Request via RequestRegistry[input.RequestID].\n    // Secrets stay in-process — only metadata in event history.\n    var injectResult InjectResult\n    err = workflow.ExecuteLocalActivity(injectCtx, FetchAndInject, FetchAndInjectInput{\n        RequestID:    input.RequestID,\n        Placeholders: input.Placeholders,\n    }).Get(ctx, \u0026injectResult)\n    if err != nil {\n        return finalize(ctx, start, StatusError, \"credential_injection_failed\")\n    }\n\n    // Phase 4: Wait for goproxy to forward + scrub response.\n    // goproxy signals us when response scrubbing is complete.\n    var outcome ResponseOutcome\n    timerCtx, _ := workflow.WithDeadline(ctx, workflow.Now(ctx).Add(60*time.Second))\n    signalCh := workflow.GetSignalChannel(timerCtx, \"response_complete\")\n    signalCh.Receive(timerCtx, \u0026outcome)\n\n    return \u0026ProxyOutput{\n        Status:          StatusSuccess,\n        StatusCode:      outcome.StatusCode,\n        CredentialCount: injectResult.CredentialCount,\n        ScrubCount:      outcome.ScrubCount,\n        LatencyMs:       workflow.Now(ctx).Sub(start).Milliseconds(),\n    }, nil\n}\n```\n\n### Request Registry (Shared In-Process State)\n\ngoproxy and Temporal local activities run in the same process. The `RequestRegistry`\nbridges them without serializing secrets through Temporal:\n\n```go\n// In proxy/registry.go\ntype RequestRegistry struct {\n    entries sync.Map // requestID → *RequestContext\n}\n\ntype RequestContext struct {\n    Request    *http.Request            // live HTTP request (goproxy owns this)\n    ScrubMap   map[string]string        // realValue → placeholder (populated by FetchAndInject)\n    DecisionCh chan\u003c- *WorkflowDecision // unblocks goproxy when injection is complete\n}\n```\n\nFlow:\n1. goproxy creates `RequestContext`, stores in registry, starts workflow\n2. goproxy blocks on `DecisionCh` (NOT `run.Get()` — workflow stays alive)\n3. Workflow activities access the `RequestContext` by ID\n4. `FetchAndInject` activity: fetches secrets from vault, modifies `*http.Request`,\n   populates scrub map, sends decision on `DecisionCh`\n5. goproxy unblocks, forwards request, scrubs response using `ScrubMap`\n6. goproxy signals workflow with `response_complete` (status, scrub count, bytes)\n7. Workflow records final audit metadata and completes\n\n### Activities\n\n1. **ValidateIdentity** (regular activity — authn via coreos/go-oidc)\n   - Input: raw JWT string\n   - Verifies JWT signature against Keycloak JWKS (cached, but may need network)\n   - Extracts claims: sub, realm_access.roles, groups\n   - Returns: `IdentityClaims` (safe for event history)\n   - Retry: 2 attempts (JWKS endpoint may be temporarily unreachable)\n   - Timeout: 10s start-to-close\n\n2. **EvaluatePolicy** (local activity — authz via OPA embedded)\n   - Input: identity claims + placeholders + target domain\n   - Resolves placeholder→credential bindings from config\n   - Evaluates Rego policy: \"identity.roles → credential → domain\"\n   - Returns: `AuthzDecision { allowed, reason }`\n   - Local activity: OPA evaluation is in-process, no network\n   - Timeout: 5s start-to-close\n\n3. **FetchAndInject** (local activity — vault fetch + credential injection)\n   - Input: `{ requestID, placeholders }` (no secrets in input)\n   - Looks up `RequestContext` from `RequestRegistry` by requestID\n   - Resolves credential vault paths from config\n   - Fetches real credentials from OpenBao (network call to vault)\n   - Replaces placeholders in request headers/body (modifies `*http.Request` in-place)\n   - Populates `RequestContext.ScrubMap` for response scrubbing\n   - Sends decision on `RequestContext.DecisionCh` (unblocks goproxy)\n   - Returns: `InjectResult { credentialCount }` (no secrets in output)\n   - Timeout: 30s start-to-close\n\n### Secrets Safety\n\nSecret values NEVER appear in Temporal event history:\n\n| Data | In Temporal history? | Where it lives |\n|------|---------------------|----------------|\n| Raw JWT | Yes (activity input) | Short-lived, already on VSOCK |\n| Identity claims | Yes (activity output) | Public metadata from JWT |\n| Credential paths | No (local activity) | In-process config lookup |\n| Real secret values | **No** | In-process memory via RequestRegistry |\n| Scrub map | **No** | In-process memory via RequestRegistry |\n| HTTP request/response | **No** | goproxy memory via RequestRegistry |\n| Scrub count / status code | Yes (signal payload) | Metadata, not secrets |\n\n### What This Replaces\n\nThe previous implementation had:\n- `ProxyRequestWorkflow` — dead code that tried to own the HTTP lifecycle inside a\n  `FetchAndForward` activity, rebuilding requests from scratch (discarding headers/body).\n- `AuditWorkflow` — fire-and-forget metadata logger, only recorded successes.\n- All authn/authz/vault/scrub logic was inline in goproxy `handleRequest`.\n\nThe new `ProxyRequestWorkflow` orchestrates the full lifecycle:\n- **Authn, authz, credential injection** are Temporal activities\n- **Response scrubbing** is tracked via signal from goproxy to the workflow\n- Every access attempt (allowed AND denied) is a complete workflow with search attributes\n- The workflow is the single source of truth for \"what happened with this request\"\n\n---\n\n## OpenBao Credential Schema\n\n```\nPath: secret/data/openclaw/credentials/\u003calias\u003e\nData: {\n  \"type\": \"api_key\" | \"bearer\" | \"basic_auth\" | \"header\",\n  \"key\": \"sk-ant-...\",\n  \"domain\": \"api.anthropic.com\",\n  \"header_name\": \"x-api-key\",\n  \"header_prefix\": \"\",\n  \"placeholder\": \"agent-vault-\u003cuuid\u003e\"\n}\n```\n\n---\n\n## Guest VM Configuration\n\n### What changes in the VM:\n\n1. **socat VSOCK bridge** (new systemd service):\n   ```\n   socat TCP-LISTEN:18790,fork,reuseaddr VSOCK-CONNECT:2:18790\n   ```\n\n2. **HTTP proxy env vars** (for all users + services):\n   ```\n   HTTP_PROXY=http://localhost:18790\n   HTTPS_PROXY=http://localhost:18790\n   NO_PROXY=localhost,127.0.0.1,10.88.0.1\n   ```\n\n3. **CA certificate** installed system-wide:\n   ```nix\n   security.pki.certificateFiles = [ credproxyCaCert ];\n   ```\n\n4. **Placeholder env vars** (per credential):\n   ```\n   ANTHROPIC_API_KEY=agent-vault-a1b2c3d4-...\n   GITHUB_TOKEN=agent-vault-e5f6a7b8-...\n   ```\n\n5. **Placeholder config** via fw_cfg (JSON listing available credentials with aliases + domains)\n\n---\n\n## Implementation Phases\n\n### Phase 1: Types, Config, Auth, Authz (no external service deps)\n- `credential-proxy/config/config.go` — Config types, YAML loading, domain allowlist\n- `credential-proxy/authn/oidc.go` — Keycloak JWT validation wrapper (coreos/go-oidc)\n- `credential-proxy/authz/engine.go` — OPA embedded policy evaluator\n- `credential-proxy/authz/policies/credential_access.rego` — Authorization policy\n- `credential-proxy/proxy/placeholder.go` — Placeholder regex extraction + substitution\n- `credential-proxy/proxy/sanitizer.go` — Response credential scrubbing\n- `credential-proxy/proxy/registry.go` — RequestRegistry (sync.Map bridging goproxy ↔ Temporal)\n\n### Phase 2: Tests (import production code paths)\n- `credential-proxy/authn/oidc_test.go` — JWT validation (valid, expired, wrong issuer)\n- `credential-proxy/authz/engine_test.go` — OPA policy (allow, deny, domain mismatch)\n- `credential-proxy/proxy/placeholder_test.go` — Placeholder detection in headers, body, URLs\n- `credential-proxy/proxy/sanitizer_test.go` — Credential scrubbing from JSON/HTML/text responses\n- `credential-proxy/workflows/activities_test.go` — ValidateIdentity, EvaluatePolicy, FetchAndInject\n- `credential-proxy/workflows/proxy_workflow_test.go` — ProxyRequestWorkflow via testsuite\n\n### Phase 3: Implementation (make tests pass)\n- `credential-proxy/vault/client.go` — OpenBao client with DI interface\n- `credential-proxy/proxy/gateway.go` — Gateway router (now holds RequestRegistry)\n- `credential-proxy/proxy/handlers.go` — OnRequest (start workflow + block on ch), OnResponse (scrub + signal)\n- `credential-proxy/workflows/proxy_workflow.go` — ProxyRequestWorkflow (full lifecycle + signal)\n- `credential-proxy/workflows/activities.go` — ValidateIdentity, EvaluatePolicy, FetchAndInject\n- `credential-proxy/main.go` — VSOCK listener, goproxy setup, Temporal worker\n\n### Phase 4: NixOS Integration\n- `modules/credential-proxy/default.nix` — Host module (proxy + Temporal + CA gen)\n- `modules/credential-proxy/guest.nix` — Guest module (VSOCK bridge, CA cert, env vars)\n- `modules/credential-proxy/openbao-policy.nix` — Read-only policy\n- `flake.nix` — `buildGoModule` package, module imports, test-vm config\n- `modules/openclaw-vm/default.nix` — Wire in credentialProxy options, VSOCK port 18790\n- `modules/openclaw-vm/guest.nix` — HTTP_PROXY/HTTPS_PROXY, CA cert, placeholder env vars\n\n### Phase 5: VM Network Lockdown\n- Extend nftables in `modules/openclaw-vm/default.nix` — block all external network when proxy enabled\n- Only VSOCK communication allowed\n\n---\n\n## Verification\n\n1. **Nix evaluation**: `nix flake check --no-build` passes\n2. **Module evaluation**: `nix eval .#nixosConfigurations.test-vm.config.system.build.toplevel --apply 'x: \"ok\"'` → `\"ok\"`\n3. **Go build**: `nix build .#credential-proxy` succeeds\n4. **Go tests**: `cd credential-proxy \u0026\u0026 go test ./...` — all pass\n5. **Placeholder detection**: Unit tests verify extraction from HTTP headers, JSON body, URL query params\n6. **Sanitization**: Unit tests verify credential values scrubbed from responses (JSON, HTML, plaintext)\n7. **Domain binding**: Unit tests verify mismatch → denied (fail-closed), match → allowed\n8. **MITM TLS**: Integration test with custom CA cert — proxy decrypts HTTPS, injects credentials\n9. **Temporal workflow**: Integration test with `go.temporal.io/sdk/testsuite` — ProxyRequestWorkflow completes full lifecycle (authn → authz → inject → signal → audit)\n10. **Forward proxy**: Integration test — `curl -x http://proxy:18790 https://httpbin.org/get` works with placeholder substitution\n11. **Network lockdown**: Agent cannot reach external network without proxy (no DNS, no TCP out)\n\n---\n\n## Existing Code to Reuse\n\n| Pattern | Source | Reuse |\n|---------|--------|-------|\n| VSOCK socat bridge | `modules/openclaw-vm/guest.nix:466-488` (vsock-gateway-proxy) | Same pattern for credproxy VSOCK bridge |\n| fw_cfg credential injection | `modules/openclaw-vm/default.nix:397-440` (sops.templates + fw_cfg) | Same pattern for placeholder config |\n| systemd hardening | `modules/openclaw-vm/guest.nix:293-370` (openclaw-gateway service) | Copy hardening directives for proxy service |\n| nftables VM isolation | `modules/openclaw-vm/default.nix:190-260` (nftables rules) | Extend for full network lockdown |\n| OpenBao policy gen | `modules/openclaw/openbao.nix:42-70` (per-instance policies) | Same pattern for proxy read-only policy |\n| CA cert install | NixOS `security.pki.certificateFiles` | Standard NixOS pattern for custom CAs |","notes":"Reopened: Proposal must remain open until user performs UAT. Was closed without user review.","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T03:25:45.699759213-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T15:04:25.978513381-08:00","labels":["aura:plan:proposal"],"dependencies":[{"issue_id":"nix-openclaw-vm-35e","depends_on_id":"nix-openclaw-vm-7xk","type":"blocks","created_at":"2026-02-17T09:03:10.06512248-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-3f9","title":"Add missing test coverage: concurrent registry, nil response, nil credential","description":"Three test gaps from wave 2 reviewer-tests:\n\n1. No concurrent registry stress test (Medium) — exercise concurrent Store/Load/Delete/sweep operations on RequestRegistry. Verifies sync.Map safety under load.\n\n2. No test for handleResponse with nil resp (Low) — handlers.go:195-196 has a nil check. Exercise it.\n\n3. No test for FetchAndInject with nil credential at injection time (Low) — activities.go:296-301 has a cred == nil branch. Exercise it.\n\nFiles: credential-proxy/proxy/registry_test.go, credential-proxy/proxy/gateway_test.go, credential-proxy/workflows/activities_test.go","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T14:33:44.130142075-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:43:39.783994886-08:00","closed_at":"2026-02-17T14:43:39.783994886-08:00","close_reason":"Added TestRegistry_ConcurrentAccess, TestGateway_NilResponsePassthrough, TestFetchAndInject_UnknownPlaceholder"}
{"id":"nix-openclaw-vm-3mu","title":"[SLICE 4] TLA+/PlusCal formal verification model","description":"## Vertical Slice: Concurrency Formal Verification\n\n**Production artifact:** TLA+/PlusCal model of the goproxy ↔ Temporal ↔ RequestRegistry concurrency protocol. Model checker verifies no deadlocks, no double-injection, eventual cleanup.\n\n**End user benefit:** Confidence that the concurrency protocol is correct by construction. Catches entire classes of bugs (deadlock, livelock, race conditions) that testing alone cannot prove absent.\n\n### Worker Owns (Full Vertical)\n\nPlan backwards from verification:\n1. End: TLC model checker passes all invariants with zero violations\n2. Back: Safety + liveness properties defined (NoDeadlock, EveryRequestGetsResponse, RegistryEventuallyEmpty, NoDoubleInjection)\n3. Back: PlusCal process definitions for 3 actors\n4. Back: State variables matching finalized protocol from Slice 1\n\n### Leaf Tasks\n\n- **xno** (P2): Create TLA+/PlusCal state machine model for proxy concurrency protocol\n\n### DEPENDS ON: Slice 1\n\nThis slice MUST wait for Slice 1 (hardened request decision pipeline) to complete. The TLA+ model must reflect the FINALIZED concurrency protocol, including:\n- select+timeout on DecisionCh (from ct4)\n- JWT validation in goproxy, not workflow (from zyg)\n- Typed error flow (from d3k)\n\n### Files You Own\n\n- credential-proxy/model/proxy_protocol.tla (NEW)\n- credential-proxy/model/README.md (NEW: how to run TLC)\n\n### Implementation Order\n\n**Layer 1: State Variables**\n- RequestRegistry states: empty / has_entry / stale\n- DecisionCh states: empty / signaled_allow / signaled_deny\n- response_complete signal: pending / delivered\n- Workflow states: init / evaluating / injecting / waiting_signal / complete\n\n**Layer 2: Process Definitions (~80-120 lines PlusCal)**\n- GoproxyHandler: register → start_workflow → select(decisionCh, timeout) → forward → scrub → signal\n- ProxyRequestWorkflow: evaluate_policy → fetch_and_inject → wait_signal → finalize\n- FetchAndInjectActivity: registry_lookup → vault_fetch → modify_request → signal_decision\n\n**Layer 3: Invariants + Properties**\n- NoDeadlock: no reachable state where all actors blocked\n- SecretsNeverInHistory: credential values never in workflow I/O\n- EveryRequestGetsResponse: registered request eventually gets decision\n- RegistryEventuallyEmpty: all entries eventually cleaned\n- NoDoubleInjection: FetchAndInject runs at most once per request\n\n### Validation\n\n- [ ] TLC model checker: zero violations across full state space\n- [ ] All 5 invariants verified\n- [ ] Model runs in \u003c 30 seconds\n- [ ] README documents how to run TLC","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T13:38:57.873421511-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:12.307618432-08:00","closed_at":"2026-02-17T14:37:12.307618432-08:00","close_reason":"All leaf tasks completed by wave 2 workers","dependencies":[{"issue_id":"nix-openclaw-vm-3mu","depends_on_id":"nix-openclaw-vm-xno","type":"blocks","created_at":"2026-02-17T13:39:07.572704632-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-3mu","depends_on_id":"nix-openclaw-vm-glo","type":"blocks","created_at":"2026-02-17T13:39:07.598938169-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-3xk","title":"Study Temporal Go SDK patterns for workflow/activity design","description":"Deep-dive into the Temporal Go SDK (go.temporal.io/sdk) to understand idiomatic patterns. Focus areas: workflow.Context vs context.Context, UpsertTypedSearchAttributes API, activity options (StartToClose, HeartbeatTimeout, RetryPolicy), local activities vs regular activities, workflow.ExecuteActivity patterns, client.ExecuteWorkflow (sync vs async), testsuite for unit testing workflows, and worker.New configuration options.","notes":"Research completed. Report written to docs/research/temporal-go-sdk.Rmd. Key findings: (1) ValidateAndResolve is a strong candidate for local activity, (2) authz denials should use temporal.NewNonRetryableApplicationError, (3) audit workflow ID should be deterministic for dedup, (4) search attribute keys should be package-level vars with KeyKeyword for Status, (5) comprehensive testsuite patterns documented for workflow+activity unit tests, (6) worker Options should set OnFatalError and MaxConcurrentActivityExecutionSize.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:16:35.471521466-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:29:13.342998937-08:00","closed_at":"2026-02-17T08:29:13.342998937-08:00","close_reason":"Research completed, reports written to docs/research/"}
{"id":"nix-openclaw-vm-4tp","title":"Add goleak to all test packages for goroutine leak detection","description":"Add Uber's goleak package to detect goroutine leaks in tests. This directly catches the DecisionCh deadlock class of bugs — if a test finishes with a goroutine still blocked on a channel, goleak flags it.\n\nAdd to each test package's TestMain:\n```go\nfunc TestMain(m *testing.M) {\n    goleak.VerifyTestMain(m)\n}\n```\n\nPackages: proxy/, workflows/, authn/, authz/\nDependency: go.uber.org/goleak","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T11:43:53.677853036-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:11.308556434-08:00","closed_at":"2026-02-17T14:37:11.308556434-08:00","close_reason":"Implemented by wave 2 workers"}
{"id":"nix-openclaw-vm-52l","title":"Fix vendorHash in flake.nix for credential-proxy build","description":"BLOCKING: vendorHash = null in credential-proxy/flake.nix with no vendor/ directory. Nix build fails. Either compute vendorHash or run go mod vendor.","status":"closed","priority":0,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:27:55.122552653-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T11:37:18.674320679-08:00","closed_at":"2026-02-17T11:37:18.674320679-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-5hx","title":"Consolidate test mock types into internal/testutil package","description":"mockEvaluator and mockStore are defined identically in proxy/gateway_test.go and workflows/activities_test.go. Create credential-proxy/internal/testutil/ with shared MockVerifier, MockEvaluator, MockStore, common TestConfig(), and shared placeholder/secret constants.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:28.696183439-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T12:04:19.959771604-08:00","closed_at":"2026-02-17T12:04:19.959771604-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-5rc","title":"[SLICE 2] Resource lifecycle management: TTL eviction + cleanup","description":"## Vertical Slice: Resource Cleanup Lifecycle\n\n**Production code path:** Long-running proxy under sustained load — RequestRegistry and connTokens entries are bounded by TTL eviction, preventing memory leaks from client disconnects, panics, or timeout edge cases.\n\n**End user observes:** Proxy memory usage stays bounded over hours/days of operation. No gradual memory growth from leaked registry entries or orphaned JWT tokens.\n\n### Worker Owns (Full Vertical)\n\nPlan backwards from production code path:\n1. End: Registry entries evicted after 2× signal timeout (~120s), connTokens cleaned after TTL\n2. Back: Background sweeper goroutine in RequestRegistry\n3. Back: Timestamp tracking on Store(), TTL configuration in config\n4. Back: connTokens time.AfterFunc on Store, cancel on Delete\n\n### Leaf Tasks\n\n- **8h6** (P1): Add RequestRegistry TTL-based eviction and connTokens cleanup\n\n### Files You Own\n\n- credential-proxy/proxy/registry.go (TTL tracking, background sweeper, cleanup)\n- credential-proxy/proxy/gateway.go (connTokens cleanup, sweeper lifecycle)\n- credential-proxy/config/config.go (TTL config options if needed)\n- credential-proxy/proxy/registry_test.go (NEW: TTL eviction tests)\n\n### Implementation Order\n\n**Layer 1: Types**\n- Add timestamp field to registry entries\n- Add TTL config option (default: 120s = 2× signal timeout)\n\n**Layer 2: Tests**\n- Test: entry evicted after TTL\n- Test: active entry NOT evicted\n- Test: connTokens cleaned up on disconnect\n- Test: sweeper goroutine exits cleanly on shutdown\n\n**Layer 3: Implementation**\n- RequestRegistry: track creation time per entry, background goroutine sweeps every TTL/2\n- connTokens: time.AfterFunc per entry, cancel timer on delete\n- Sweeper lifecycle: start in NewGateway, stop via context cancellation\n- Tests should now PASS\n\n### Validation\n\n- [ ] `go test -race ./proxy/ -v` passes\n- [ ] Registry entries evicted after TTL in tests\n- [ ] connTokens entries cleaned on timeout\n- [ ] Sweeper goroutine exits cleanly (goleak-safe)\n- [ ] No memory growth under sustained load simulation","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T13:38:28.093862013-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:12.295558595-08:00","closed_at":"2026-02-17T14:37:12.295558595-08:00","close_reason":"All leaf tasks completed by wave 2 workers","dependencies":[{"issue_id":"nix-openclaw-vm-5rc","depends_on_id":"nix-openclaw-vm-8h6","type":"blocks","created_at":"2026-02-17T13:39:07.516157571-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-5x1","title":"Study Peta Core JIT decryption and audit patterns","description":"Study dunialabs/peta-core for JIT decryption with short TTL, short-lived agent tokens, HITL approval workflows, and audit trail patterns. Key areas: how they implement time-limited credential access, approval workflows, audit logging. Compare with our Temporal audit and OpenBao vault fetch patterns.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:17.043745691-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.771506858-08:00","closed_at":"2026-02-17T08:16:09.771506858-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-6h5","title":"Study Ory Oathkeeper pipeline/mutator architecture","description":"Study ory/oathkeeper for pipeline architecture (authenticators, authorizers, mutators), per-domain access rules, and header/JWT injection patterns. Key areas: how rules match requests to handler pipelines, mutator design for credential injection, error handling pipeline. Improve our handler pipeline design.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:10.512257422-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.75830895-08:00","closed_at":"2026-02-17T08:16:09.75830895-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-6vm","title":"Replace stringly-typed APIs with strongly-typed enums across credential-proxy","description":"User requirement (Q31): All internal API boundaries must use strongly-typed enums, NOT string literals or untyped string constants.\n\nSpecific changes needed:\n\n1. **ProxyStatus enum** (workflows/types.go):\n   ```go\n   type ProxyStatus int\n   const (\n       StatusSuccess ProxyStatus = iota\n       StatusDenied\n       StatusError\n       StatusTimeout\n   )\n   func (s ProxyStatus) String() string { ... }\n   ```\n\n2. **DenialReason enum**:\n   ```go\n   type DenialReason int\n   const (\n       ReasonNone DenialReason = iota\n       ReasonAuthenticationFailed\n       ReasonAuthorizationDenied\n       ReasonCredentialInjectionFailed\n       ReasonTimeout\n   )\n   ```\n\n3. **DecisionStatus enum** (already partially done by worker-temporal, verify):\n   ```go\n   type DecisionStatus int\n   const (\n       DecisionAllowed DecisionStatus = iota\n       DecisionDenied\n       DecisionError\n   )\n   ```\n\n4. **Signal name constants**:\n   ```go\n   const SignalResponseComplete = \"response_complete\"\n   ```\n\n5. **WorkflowDecision** should carry typed DecisionStatus + DenialReason + HTTPStatusCode (int), not free-form string Reason.\n\n6. **HTTP error mapping**: goproxy handler uses DenialReason → HTTP status code mapping (typed, not if/else on strings).\n\n7. **Search attributes**: Go-side uses typed enums with .String() for Temporal serialization.\n\nFiles: credential-proxy/workflows/ (types, workflow, activities), credential-proxy/proxy/handlers.go, credential-proxy/audit/search_attributes.go","notes":"Use `ast-grep` to find all stringly-typed values before making changes. ast-grep is available at /run/current-system/sw/bin/ast-grep. Write ast-grep patterns to identify: string literal function arguments, string-typed struct fields at API boundaries, bare string constants without named types.","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T11:47:04.40099225-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T11:55:49.086850105-08:00","closed_at":"2026-02-17T11:55:49.086850105-08:00","close_reason":"Replaced all stringly-typed status/decision/signal APIs with strongly-typed Go enums: ProxyStatus int, DecisionStatus int, DenialReason int with String()+HTTPStatusCode(), SignalName string type + SignalResponseComplete constant. All tests pass.","dependencies":[{"issue_id":"nix-openclaw-vm-6vm","depends_on_id":"nix-openclaw-vm-db8","type":"blocks","created_at":"2026-02-17T11:51:35.292391748-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-71r","title":"MVP: Define sample credentials in test-vm config","description":"## Goal\nAdd sample credential definitions to the test-vm NixOS config so the credential proxy has something to work with.\n\n## What to define\nIn flake.nix test-vm block, add:\n- credentialProxy.enable = true\n- credentialProxy.allowedDomains = [ \"httpbin.org\" ] (safe for testing)\n- credentialProxy.credentials with at least one entry:\n  - placeholder: \"agent-vault-httpbin\"\n  - type: api_key\n  - vault_path: \"secret/data/openclaw/credentials/httpbin\"\n  - bound_domain: \"httpbin.org\"\n  - header_name: \"Authorization\"\n  - header_prefix: \"Bearer \"\n\n## Context\n- Module options defined in `modules/credential-proxy/default.nix`\n- Config types in `credential-proxy/config/config.go`\n- httpbin.org echoes headers back, making it ideal for verifying injection\n\n## Acceptance\n- [ ] `nix flake check` passes with credential proxy enabled\n- [ ] Config generates valid YAML for credproxy service","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T15:21:30.947365354-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T15:21:30.947365354-08:00","dependencies":[{"issue_id":"nix-openclaw-vm-71r","depends_on_id":"nix-openclaw-vm-opa","type":"blocks","created_at":"2026-02-17T15:21:45.011545356-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-71r","depends_on_id":"nix-openclaw-vm-8y4","type":"blocks","created_at":"2026-02-17T15:21:45.047167338-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-7xk","title":"CREDENTIAL-PROXY: Implement credential proxy security layer for openclaw-vm","description":"## Goal\nImplement a credential proxy security layer for the openclaw microVM where:\n- Agent inside VM has zero external network access\n- All auth-required requests delegated to trusted proxy service on host via VSOCK\n- Credentials stored in OpenBao with domain binding enforcement\n- Proxy injects auth headers — agent never sees API keys\n- Full audit trail of all credential access\n\n## Architecture\nHost (NixOS)\n├── OpenBao (secrets store)\n│   └── Credentials with domain binding metadata\n├── Credential Proxy Service (NEW)\n│   ├── Listens on VSOCK\n│   ├── Validates ACP protocol requests\n│   ├── Fetches credential from OpenBao + verifies domain binding\n│   ├── Injects auth headers into outbound HTTPS request\n│   ├── Templates response\n│   └── Audit logs everything\n└── openclaw-vm (microVM)\n    └── Agent (zero network — all via VSOCK → proxy)\n\n## Phases\n1. Protocol \u0026 Types (ACP subset)\n2. Credential Proxy Service (Rust)\n3. NixOS Integration\n4. Guest-Side Client\n5. VM Network Lockdown","notes":"Reopened: Feature must remain open until user performs UAT.","status":"open","priority":1,"issue_type":"feature","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T01:12:10.551998339-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T15:04:46.043624913-08:00","dependencies":[{"issue_id":"nix-openclaw-vm-7xk","depends_on_id":"nix-openclaw-vm-2vh","type":"blocks","created_at":"2026-02-17T09:26:50.29507789-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-7xk","depends_on_id":"nix-openclaw-vm-wj1","type":"relates-to","created_at":"2026-02-17T15:21:50.169668063-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-8a1","title":"Rename auth package to authn for conventional authn/authz naming","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:01:15.791463993-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:05:22.497274393-08:00","closed_at":"2026-02-17T08:05:22.497274393-08:00","close_reason":"Renamed auth→authn, all tests pass"}
{"id":"nix-openclaw-vm-8h6","title":"Add RequestRegistry TTL-based eviction and connTokens cleanup","description":"Two memory leak paths found by reviewers:\n\n1. RequestRegistry: if goproxy panics between workflow start and response, the entry leaks (defer may not run). Add a background goroutine that evicts entries older than 2x signal timeout.\n\n2. connTokens (sync.Map storing JWT per CONNECT): if client disconnects after CONNECT but before sending a request, the entry leaks. handleResponse is the only cleanup path. Add TTL-based eviction (time.AfterFunc on store, cancel on delete).\n\nFiles: credential-proxy/proxy/registry.go, credential-proxy/proxy/gateway.go","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T11:44:32.932449824-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:11.320104035-08:00","closed_at":"2026-02-17T14:37:11.320104035-08:00","close_reason":"Implemented by wave 2 workers"}
{"id":"nix-openclaw-vm-8te","title":"REVIEW W2-1: Correctness review of wave 2 slices","description":"## Review Axis: Correctness (spirit and technicality)\n\nReview ALL wave 2 slices against the PROPOSAL and URD:\n\n### Slice 0 (h80): goleak + race detector\n- Are goleak ignores justified? Do they mask real leaks?\n- Is -race flag properly wired in Nix checkPhase?\n\n### Slice 1 (glo): Decision pipeline hardening\n- Does select+timeout on DecisionCh actually prevent deadlocks in all code paths?\n- Does moving JWT validation to goproxy correctly handle all error cases (expired, invalid issuer, JWKS unavailable)?\n- Are structured error types (DenialReason → HTTP status) mapped correctly? (407 for authn, 403 for authz, 502 for vault, 504 for timeout)\n- Does the roundtrip integration test cover the full goproxy→Temporal→Registry→vault→scrub cycle?\n- Are there any workflow exit paths that DON'T send on DecisionCh?\n\n### Slice 2 (5rc): TTL eviction\n- Does the sweeper actually prevent memory leaks under sustained load?\n- Are there race conditions between sweeper eviction and normal request completion?\n- Does connToken timer cancellation prevent double-delete races?\n\n### Slice 3 (m1b): nftables Tailscale exemption\n- Does `oifname \"tailscale0\" accept` correctly exempt Tailscale SSH?\n- Is the rule conditional on cfg.tailscale.enable?\n- Does the rule placement (before drop) work correctly?\n\n### Slice 4 (3mu): TLA+ model\n- Does the model faithfully represent the actual code's concurrency protocol?\n- Are the invariants (NoDeadlock, EveryRequestGetsResponse, etc.) correctly specified?\n- Does TLC pass with zero violations?\n\n### Cross-slice concerns\n- Are there file conflicts or inconsistencies between slices?\n- Do all slices follow the type safety rules (no stringly-typed APIs)?\n- Does `ast-grep scan --config sgconfig.yml .` pass with zero violations?","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T13:58:19.328349977-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:14.48508871-08:00","closed_at":"2026-02-17T14:37:14.48508871-08:00","close_reason":"Wave 2 reviews completed, findings captured as ruw/d5c/3f9","dependencies":[{"issue_id":"nix-openclaw-vm-8te","depends_on_id":"nix-openclaw-vm-h80","type":"blocks","created_at":"2026-02-17T13:58:51.603911301-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-8te","depends_on_id":"nix-openclaw-vm-glo","type":"blocks","created_at":"2026-02-17T13:58:51.632272252-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-8te","depends_on_id":"nix-openclaw-vm-5rc","type":"blocks","created_at":"2026-02-17T13:58:51.659381642-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-8te","depends_on_id":"nix-openclaw-vm-m1b","type":"blocks","created_at":"2026-02-17T13:58:51.687825259-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-8te","depends_on_id":"nix-openclaw-vm-3mu","type":"blocks","created_at":"2026-02-17T13:58:51.716470575-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-8y4","title":"MVP: Mock OpenBao vault service for dev mode","description":"## Goal\nProvide an OpenBao-compatible KV v2 endpoint for the test-vm so credproxy can fetch credentials without a full OpenBao deployment.\n\n## Options (pick one)\n1. **NixOS openbao module** — Import from nixpkgs, configure KV v2 store with demo secrets. Real but complex setup.\n2. **Mock vault service** — Minimal HTTP service returning static KV v2 responses. Lightweight.\n3. **Static credential bypass** — In dangerousDevMode, load credentials from local YAML instead of vault. Fastest but doesn't test vault pipeline.\n\n## Context\n- OpenBao wrapper exists at `modules/openclaw/openbao.nix`\n- vault client expects: `http://127.0.0.1:8200`, KV v2 at `secret/data/openclaw/credentials/*`\n- vault.Client uses AppRole auth by default\n- OpenBao policy defined in `modules/credential-proxy/openbao-policy.nix`\n\n## Acceptance\n- [ ] credproxy can fetch a credential from the vault endpoint\n- [ ] Domain binding metadata included in response\n- [ ] `nix flake check` passes","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T15:21:25.313610903-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T15:21:25.313610903-08:00"}
{"id":"nix-openclaw-vm-auz","title":"Add goproxy-Temporal-RequestRegistry roundtrip integration test","description":"CRITICAL GAP (reviewer-tests): No existing or proposed test exercises the full synchronization loop: goproxy starts workflow → blocks on DecisionCh → local activity accesses RequestRegistry → signals DecisionCh → goproxy unblocks → forwards → scrubs → signals workflow.\n\nCurrent tests mock Temporal entirely (gateway_test) or mock activities (workflow_test). The missing middle tier tests the actual coordination.\n\nAdd an integration test that wires: real RequestRegistry + real Gateway + TestWorkflowEnvironment (or real local activities in-process). This catches deadlocks, channel misuse, and registry cleanup bugs.\n\nFiles: credential-proxy/proxy/gateway_integration_test.go (new)","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T11:44:38.469300865-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:11.303252865-08:00","closed_at":"2026-02-17T14:37:11.303252865-08:00","close_reason":"Implemented by wave 2 workers"}
{"id":"nix-openclaw-vm-bhw","title":"Study Secretless Broker (CyberArk) patterns","description":"Study cyberark/secretless-broker for provider/connector architecture, Vault integration patterns, and per-connector-port domain scoping. Key areas: how providers abstract secret backends, how connectors define per-service credential injection, their plugin architecture. Compare with our vault.SecretStore and config.Credential patterns.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:02.42095771-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.744828709-08:00","closed_at":"2026-02-17T08:16:09.744828709-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-c5x","title":"Add HTTPS CONNECT integration test for TLS MITM path","description":"Current gateway_test.go only exercises plain HTTP proxying. The production-critical path (CONNECT -\u003e MITM TLS -\u003e credential injection -\u003e response scrubbing) has no automated test. Add test using httptest.NewTLSServer as upstream with client going through CONNECT tunnel.","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:26.594716208-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T12:04:19.954707642-08:00","closed_at":"2026-02-17T12:04:19.954707642-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-cgg","title":"Implement fw_cfg provisioning for credential placeholder config","description":"URD Q9: user chose both env vars AND fw_cfg. Currently only env vars implemented. fw_cfg should provide a JSON config listing available placeholders with aliases and domains. Guest-side: env vars should be populated FROM the fw_cfg JSON at boot time, making fw_cfg the single source of truth.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:31.808775836-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T11:37:18.683692547-08:00","closed_at":"2026-02-17T11:37:18.683692547-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-coe","title":"IMPL-UAT: Credential proxy end-to-end acceptance test","description":"## Implementation UAT — Credential Proxy Security Layer\n\nPresent each component one at a time with real output, then ask about specific design decisions made during implementation. Record user responses verbatim.\n\n**Prerequisite:** MVP smoke test (lvm) passes — VM boots, services run, proxied request succeeds.\n\n---\n\n### Component 1: Guest-Side UX — What the Agent Sees\n\n**Command to run (from inside guest VM):**\n```bash\n# Step 1: Authenticate\n$ credproxy-auth\neyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\n\n# Step 2: Make proxied request\n$ credproxy-request GET https://httpbin.org/headers\n{\n  \"headers\": {\n    \"Authorization\": \"Bearer agent-vault-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n    ...\n  }\n}\n```\n\nNote: The response shows the *placeholder* string, not the real credential — that's the scrubbing working.\n\n**Design question:** The guest-side UX requires two steps: (1) `credproxy-auth` to obtain a JWT, (2) `credproxy-request` to make proxied requests. The JWT is cached to a file with mode 600 so step 1 only runs once per session. The alternative is a single command that auto-authenticates on every request. Which is preferable?\n\n**Options:**\n- **Two-step (current)** — Explicit auth then request. Agent controls when to re-authenticate. JWT cached in `${XDG_RUNTIME_DIR}/credproxy-jwt`.\n- **Single command** — Auto-authenticate if no cached token or token expired. Simpler UX but hides the auth step.\n- **Auto-auth with explicit refresh** — Default to auto-auth, but expose `credproxy-auth --refresh` for manual token rotation.\n\n---\n\n### Component 2: Placeholder Substitution — How Credentials Are Hidden\n\n**Definition shown:**\n```go\n// placeholder.go\nvar placeholderPattern = regexp.MustCompile(\n  `agent-vault-[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}`)\n```\n\n**Motivating example:**\n```\nAGENT SENDS (through proxy):\n  POST https://api.anthropic.com/v1/messages\n  x-api-key: agent-vault-a1b2c3d4-e5f6-7890-abcd-ef1234567890\n  Body: {\"model\": \"claude-3\", ...}\n\nPROXY TRANSFORMS (outbound to API):\n  POST https://api.anthropic.com/v1/messages\n  x-api-key: sk-ant-api03-REAL_KEY_HERE\n  Body: {\"model\": \"claude-3\", ...}\n```\n\nSubstitution happens in headers, query params, AND request body via `strings.NewReplacer` (single-pass, prevents double-substitution).\n\n**Design question:** The placeholder format is opaque UUID (`agent-vault-\u003cuuid-v4\u003e`). Three alternatives were considered during URE:\n\n**Options:**\n- **Opaque UUID (current)** — Agent sees `agent-vault-a1b2c3d4-...`. Cannot infer what credential it is. Mapping is in proxy config. Agent discovers placeholders via env vars or fw_cfg at boot.\n- **Structured refs** — Agent sees `{{vault:secret/data/openclaw/credentials/anthropic}}`. More readable, agent knows the vault path. But leaks the secret path to the guest.\n- **Human-readable aliases** — Agent sees `my-anthropic-key`. More ergonomic but requires alias management and risks naming collisions.\n\n---\n\n### Component 3: Response Scrubbing — How Credentials Are Removed from Responses\n\n**Definition shown:**\n```go\n// sanitizer.go — ScrubCredentials replaces real credential values with placeholders\nfunc ScrubCredentials(resp *http.Response, credentials map[string]string) (int, error)\n// credentials map: realValue → placeholder (reverse of injection mapping)\n```\n\n**Motivating example:**\n```\nAPI RETURNS (to proxy):\n  {\"headers\": {\"x-api-key\": \"sk-ant-api03-REAL_KEY_HERE\"}, ...}\n\nPROXY SCRUBS (before forwarding to agent):\n  {\"headers\": {\"x-api-key\": \"agent-vault-a1b2c3d4-e5f6-7890-abcd-ef1234567890\"}, ...}\n\nScrub count: 1 (recorded in Temporal audit via SignalResponseComplete)\n```\n\nAlso scrubs the raw key separately if a prefix was used (e.g., \"Bearer \" + key → scrubs both \"Bearer key\" and \"key\" alone).\n\n**Design question:** To make string-matching scrubbing reliable, the proxy forces `Accept-Encoding: identity` on all outbound requests (disabling gzip/deflate). This means upstream APIs always send uncompressed responses. The tradeoff:\n\n**Options:**\n- **Force identity encoding (current)** — Responses are always plaintext. Scrubbing is reliable. But responses may be larger over the wire (no compression).\n- **Decompress-scrub-recompress** — Accept compressed responses, decompress in proxy, scrub, recompress. More bandwidth-efficient but adds CPU overhead and complexity.\n- **Accept the risk** — Allow compressed responses. Scrubbing only works on uncompressed bodies. Some credential leakage possible if API compresses the response.\n\n---\n\n### Component 4: OIDC Authentication — How the Agent Proves Identity\n\n**Definition shown:**\n```go\n// authn/oidc.go — Verifier validates JWTs against Keycloak OIDC discovery\ntype Verifier interface {\n    VerifyToken(ctx context.Context, rawToken string) (*Identity, error)\n}\n\ntype Identity struct {\n    Subject   string\n    Roles     []string   // from realm_access.roles\n    Groups    []string\n    RawClaims map[string]interface{}\n}\n```\n\n**Motivating example:**\n```\n1. Agent runs credproxy-auth → client_credentials grant → Keycloak returns JWT\n2. Agent sends request with Proxy-Authorization: Bearer \u003cjwt\u003e\n3. Gateway.handleRequest validates JWT inline (BEFORE Temporal workflow starts)\n4. Only IdentityClaims (subject, roles, groups) flow into Temporal — raw token stays in process memory\n```\n\nJWT validation is inline in goproxy, not in a Temporal activity. This keeps raw tokens out of Temporal event history entirely.\n\n**Design question:** The `client_credentials` grant is machine-to-machine (no human in the loop). The agent's identity is determined by which Keycloak client ID/secret pair was provisioned to the VM. During URE, you chose OIDC-only auth (not VSOCK CID-based). The question:\n\n**Options:**\n- **client_credentials only (current)** — Agent authenticates as a Keycloak service account. Identity = client ID. Simple, standard OIDC.\n- **Add VSOCK CID as defense-in-depth** — Also verify the request comes from the expected VSOCK CID. Prevents a compromised host process from impersonating the VM.\n- **Per-agent JWT** — Each agent instance gets a unique JWT (not shared per-VM). Enables per-agent audit trails. But requires Keycloak provisioning per agent spawn.\n\n---\n\n### Component 5: OPA Authorization + Domain Binding — How Access Is Controlled\n\n**Definition shown (credential_access.rego):**\n```rego\ndefault allow := false\n\nallow if {\n    has_roles                # identity has at least one Keycloak role\n    all_credentials_bound    # every credential's bound_domain == target_domain\n}\n\ndeny_reasons contains \"no roles in identity\" if { not has_roles }\ndeny_reasons contains msg if {\n    some cred in input.credentials\n    cred.bound_domain != input.target_domain\n    msg := sprintf(\"credential %s not bound to domain %s\", [cred.placeholder, input.target_domain])\n}\n```\n\n**Motivating example:**\n```\nALLOWED: Agent requests api.anthropic.com with placeholder bound to api.anthropic.com\n  → OPA: allow=true\n\nDENIED: Agent requests evil.com with placeholder bound to api.anthropic.com\n  → OPA: allow=false\n  → deny_reasons: [\"credential agent-vault-abc not bound to domain evil.com\"]\n  → HTTP 403 Forbidden\n```\n\nDomain binding is DOUBLE-checked: global allowlist in handleConnect (CONNECT rejected before MITM) AND per-credential in OPA (request rejected before vault fetch).\n\n**Design question:** The OPA policy only requires \"at least one Keycloak role\" (`count(roles) \u003e 0`). It does NOT check for a specific role like `credproxy-user`. This means any authenticated Keycloak user with ANY role can use the proxy.\n\n**Options:**\n- **Any role (current)** — Simplest. Any authenticated identity with roles can proxy. Domain binding is the real access control.\n- **Require specific role** — Add `\"credproxy-user\" in roles` check. More restrictive but requires Keycloak role provisioning.\n- **Role-per-credential** — Each credential config specifies required roles. E.g., `anthropic-api` credential requires `anthropic-user` role. Most granular but most config.\n\n---\n\n### Component 6: Temporal Audit Trail — How Everything Is Recorded\n\n**Definition shown:**\n```go\n// audit/search_attributes.go\nconst (\n    AttrAgentID           = \"CredProxyAgentID\"\n    AttrTargetDomain      = \"CredProxyTargetDomain\"\n    AttrCredentialRefHash = \"CredProxyCredentialRefHash\"\n    AttrStatus            = \"CredProxyStatus\"\n)\n```\n\n**Motivating example:**\n```\nTemporal workflow: proxy-api.anthropic.com-\u003crequestID\u003e\n  Activity 1: EvaluatePolicy → {allowed: true}\n  Activity 2: FetchAndInject → {credential_count: 1}\n  Signal: response_complete → {status_code: 200, scrub_count: 1, bytes: 4096}\n\nSearch attributes (queryable):\n  CredProxyAgentID = \"credproxy-vm-agent\"\n  CredProxyTargetDomain = \"api.anthropic.com\"\n  CredProxyStatus = \"allowed\"\n```\n\nEvery proxied request = one Temporal workflow. Full replay capability.\n\n**Design question:** The audit trail records: agent ID, target domain, credential ref hash, and status. Credential VALUES never appear in Temporal history (secrets stay in local activity memory). But response metadata does (status code, scrub count, byte count). \n\n**Options:**\n- **Current attributes are sufficient** — Agent, domain, status, credential hash covers the audit use cases.\n- **Add request metadata** — Also record: HTTP method, URL path (not query), request size. More context for forensics but more data.\n- **Add timing metadata** — Also record: authn duration, authz duration, vault fetch duration, total latency. Useful for performance monitoring.\n- **Add all of the above** — Full observability. More search attributes but richer queries.\n\n---\n\n### Component 7: Error Responses — What Happens When Things Go Wrong\n\n**Definition shown:**\n```go\n// workflows/activities.go — DenialReason typed enum\nReasonAuthenticationFailed    → 407 Proxy Authentication Required\nReasonAuthorizationDenied     → 403 Forbidden\nReasonCredentialInjectionFailed → 502 Bad Gateway\nReasonTimeout                 → 504 Gateway Timeout\n```\n\n**Motivating example:**\n```\nNo JWT:          → 407 \"missing authentication token\"\nInvalid JWT:     → 407 \"authentication failed: token expired\"\nWrong domain:    → 403 \"authorization denied\"\nVault down:      → 502 \"credential injection failed\"\nTemporal timeout: → 504 \"credential resolution timed out\"\n```\n\n**Design question:** The proxy returns 407 (Proxy Authentication Required) for JWT failures, not 401 (Unauthorized). RFC 7235 specifies 407 for proxy auth, but many tools and agents expect 401. \n\n**Options:**\n- **407 (current, RFC-correct)** — Standard proxy auth status. Works with HTTP clients that understand proxy auth. But some agents may not handle 407.\n- **401 (pragmatic)** — More widely understood. But technically incorrect for a proxy.\n- **407 with WWW-Authenticate fallback** — Return 407 but also include a `WWW-Authenticate: Bearer` header so clients can discover the auth scheme.\n\n---\n\n## Execution Protocol\n\n1. Boot test-vm with credential proxy enabled\n2. Present each component one at a time using AskUserQuestion\n3. For each: show real output, explain the design choice, ask for the specific decision\n4. Record user's selection AND any free-text feedback verbatim\n5. After all 7 components: ask for final ACCEPT or REVISE with component-specific notes\n6. If REVISE: document which component(s) need changes and exact feedback\n\n## Final Decision\n\nAfter all components reviewed:\n- **ACCEPT** → Close UAT task, close upstream chain (7xk → 35e → whp → et5)\n- **REVISE** → Document specific component(s) and feedback, return to relevant slice","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T15:45:08.010589678-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T15:45:08.010589678-08:00","labels":["aura:impl:uat","aura:user:uat"],"dependencies":[{"issue_id":"nix-openclaw-vm-coe","depends_on_id":"nix-openclaw-vm-lvm","type":"blocks","created_at":"2026-02-17T15:45:17.603710496-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-ct4","title":"Fix DecisionCh deadlock: add select with timeout on all bare channel reads","description":"CRITICAL (found by reviewer-correctness): If ValidateIdentity or EvaluatePolicy fails, the workflow returns via finalize() without sending on DecisionCh. goproxy blocks forever on `\u003c-decisionCh`. The goproxy goroutine leaks and the deferred registry.Delete never runs.\n\nFix: Replace bare `decision := \u003c-decisionCh` with:\n```go\nselect {\ncase decision := \u003c-decisionCh:\n    // FetchAndInject succeeded\ncase \u003c-workflowDone(run):\n    // Workflow completed without sending decision — check result for denial\ncase \u003c-time.After(45 * time.Second):\n    // Timeout safety net\n}\n```\n\nAlso add a NotifyDenial local activity at every early-return path, OR use a deferred cleanup pattern in the workflow.\n\nFiles: credential-proxy/proxy/handlers.go (goproxy side), credential-proxy/workflows/proxy_workflow.go (workflow side)","status":"closed","priority":0,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T11:43:50.347381191-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:11.284672245-08:00","closed_at":"2026-02-17T14:37:11.284672245-08:00","close_reason":"Implemented by wave 2 workers"}
{"id":"nix-openclaw-vm-d3k","title":"Add structured error types from workflow decisions to goproxy","description":"reviewer-elegance flagged: WorkflowDecision carries a string Reason but goproxy maps everything to 403. Should distinguish:\n- Auth failed → 407 Proxy Authentication Required\n- Authz denied → 403 Forbidden\n- Vault unavailable → 502 Bad Gateway\n- Internal error → 500 Internal Server Error\n\nAdd a typed error category (enum/const) to WorkflowDecision with the appropriate HTTP status code, or at minimum a StatusCode field.\n\nFiles: credential-proxy/workflows/proxy_workflow.go (decision types), credential-proxy/proxy/handlers.go (status mapping)","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T11:44:28.20452791-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:11.297144128-08:00","closed_at":"2026-02-17T14:37:11.297144128-08:00","close_reason":"Implemented by wave 2 workers"}
{"id":"nix-openclaw-vm-d5c","title":"Fix scrubCount audit accuracy — count actual replacements, not map entries","description":"reviewer-correctness flagged: handlers.go:210 sets scrubCount = len(state.scrubMap) which counts map entries, not actual string replacements found in the response body. ScrubCredentials() doesn't return a replacement count.\n\nFix: Have ScrubCredentials return the number of actual replacements made. Use that as scrubCount in the ResponseCompleteMeta signal.\n\nFiles: credential-proxy/proxy/sanitizer.go (return count), credential-proxy/proxy/handlers.go (use returned count)","status":"closed","priority":2,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T14:33:40.230078426-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:43:39.760146554-08:00","closed_at":"2026-02-17T14:43:39.760146554-08:00","close_reason":"ScrubCredentials now returns (int, error); handlers.go uses actual count"}
{"id":"nix-openclaw-vm-d6c","title":"Study Octelium secretless access patterns","description":"Study octelium/octelium for zero-trust secretless access architecture, CEL/OPA policy-as-code integration, per-service routing with credential injection (API keys, Bearer, OAuth2, Sigv4). Key areas: how they abstract different auth schemes, policy evaluation pipeline, service routing model. Compare with our authz and credential injection approach.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:08.072643257-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.753484442-08:00","closed_at":"2026-02-17T08:16:09.753484442-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-db8","title":"Create ast-grep rules for stringly-typed API detection in credential-proxy","description":"User requirement (Q32): Use ast-grep as enforcement tool for the strongly-typed API requirement.\n\nCreate reusable ast-grep rule files that detect:\n1. String literal arguments at function call boundaries (e.g., finalize(..., \"denied\", \"auth_failed\"))\n2. Untyped string constants (const Foo = \"bar\" instead of typed enum)\n3. String-typed struct fields used as status/reason/decision identifiers\n4. Bare string literals as Temporal signal names (GetSignalChannel(ctx, \"response_complete\"))\n5. String comparisons on status/reason fields (if status == \"denied\")\n\nDeliverables:\n- credential-proxy/sgconfig.yml — ast-grep config\n- credential-proxy/rules/ — rule YAML files with patterns + messages\n- Document in AGENTS.md how to run: `ast-grep scan --rule rules/ credential-proxy/`\n- Rules should be runnable as a pre-commit quality gate\n\nast-grep is available at /run/current-system/sw/bin/ast-grep","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T11:51:28.197724086-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T12:04:09.884643245-08:00","closed_at":"2026-02-17T12:04:09.884643245-08:00","close_reason":"Created 3 ast-grep rule files (no-signal-string-literal, no-stringly-typed-status-enum, no-untyped-string-const) + sgconfig.yml. Updated AGENTS.md with quality gate instructions. All rules produce 0 violations in non-vendor code."}
{"id":"nix-openclaw-vm-ddc","title":"REVIEW W2-2: Test quality review of wave 2 slices","description":"## Review Axis: Test quality and coverage\n\nReview ALL wave 2 slice tests against AGENTS.md test writing rules:\n\n### General criteria (apply to all slices)\n- System under test is NOT mocked out\n- Shared fixtures used (not inline config per test)\n- Observable outcomes asserted (HTTP status, response body, side effects)\n- Compile-time interface checks (var _ Interface = (*mock)(nil))\n- Integration tests favored over brittle unit tests\n\n### Slice 0 (h80): goleak + race detector\n- Are goleak TestMain wrappers in ALL test packages?\n- Are IgnoreTopFunction entries justified with comments?\n- Does -race actually run during nix build (checkPhase)?\n\n### Slice 1 (glo): Decision pipeline hardening\n- Does the roundtrip integration test (auz) exercise REAL coordination (not mocked Temporal)?\n- Are error paths tested? (auth failure → 407, authz denied → 403, vault error → 502, timeout → 504)\n- Are workflow tests updated for removed ValidateIdentity?\n- Do tests cover the select+timeout path (simulated slow/absent decision)?\n\n### Slice 2 (5rc): TTL eviction\n- Do registry tests use real RequestRegistry (not mocked)?\n- Do TTL tests actually wait for expiry (not just check flags)?\n- Is the sweeper goroutine tested for clean shutdown (goleak-safe)?\n- Are connToken race conditions tested (concurrent store/delete/timeout)?\n\n### Slice 3 (m1b): nftables\n- Is nix flake check sufficient, or should there be a NixOS test that inspects generated rules?\n\n### Slice 4 (3mu): TLA+ model\n- Does the model have a runnable verification command documented?\n- Are invariants testable (can we add a CI step)?\n\n### Cross-slice test gaps\n- Is there a test that exercises the FULL pipeline end-to-end (proxy + registry TTL + goleak)?\n- Are there untested interactions between slices?","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T13:58:31.209193921-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:14.491042114-08:00","closed_at":"2026-02-17T14:37:14.491042114-08:00","close_reason":"Wave 2 reviews completed, findings captured as ruw/d5c/3f9","dependencies":[{"issue_id":"nix-openclaw-vm-ddc","depends_on_id":"nix-openclaw-vm-h80","type":"blocks","created_at":"2026-02-17T13:58:51.744868165-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-ddc","depends_on_id":"nix-openclaw-vm-glo","type":"blocks","created_at":"2026-02-17T13:58:51.771645199-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-ddc","depends_on_id":"nix-openclaw-vm-5rc","type":"blocks","created_at":"2026-02-17T13:58:51.7994655-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-ddc","depends_on_id":"nix-openclaw-vm-m1b","type":"blocks","created_at":"2026-02-17T13:58:51.827803227-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-ddc","depends_on_id":"nix-openclaw-vm-3mu","type":"blocks","created_at":"2026-02-17T13:58:51.855924235-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-dwl","title":"Document VM testing patterns in README.md and AGENTS.md","description":"No documentation on how to test the VM or credential-proxy. Should cover: nix flake check, Go unit/integration tests (go test ./...), the dev/test workflow from flake.nix, and how to run VM boot tests. Add to both README.md (for external users) and AGENTS.md (for agent contributors).","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:35.023627318-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T11:29:55.295695938-08:00","closed_at":"2026-02-17T11:29:55.295695938-08:00","close_reason":"Added Testing sections to both README.md and AGENTS.md covering nix flake check, go test ./..., dev shell, VM boot, and VSOCK testing."}
{"id":"nix-openclaw-vm-et5","title":"REQUEST: Credential proxy security layer for openclaw-vm","description":"Verbatim User Request: Implement a credential proxy security layer for the openclaw microVM where the agent inside the VM has zero external network access, all auth-required requests are delegated to a trusted proxy service on the host via VSOCK, credentials are stored in OpenBao with domain binding enforcement, the proxy injects auth headers (agent never sees API keys), and full audit trail of all credential access. User Clarifications: Does NOT want Rust. Prefers Zig, Gleam/Elixir, or Golang. Does NOT want to re-implement secret-to-domain mapping or the proxy itself if avoidable. Interested in Temporal for backend orchestration (audit trail, event sourcing, event-driven architecture). Wants to evaluate existing solutions before building from scratch. Source Document: ~/dotfiles/docs/agent-sandbox.md","notes":"Reopened: REQUEST must remain open until user performs UAT. Depends on URE (whp) which is now open.","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T01:20:06.451275233-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T15:04:45.256538596-08:00","labels":["aura:user:request"],"dependencies":[{"issue_id":"nix-openclaw-vm-et5","depends_on_id":"nix-openclaw-vm-whp","type":"blocks","created_at":"2026-02-17T09:02:19.142299287-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-et5","depends_on_id":"nix-openclaw-vm-coe","type":"blocks","created_at":"2026-02-17T15:45:17.633329927-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-ffs","title":"Refactor to Temporal-orchestrated full lifecycle (replace dead ProxyRequestWorkflow)","description":"Replace the current inline handler + dead ProxyRequestWorkflow + fire-and-forget AuditWorkflow with a single ProxyRequestWorkflow that orchestrates the full request lifecycle via activities and signals.\n\nChanges:\n1. New ProxyRequestWorkflow with ValidateIdentity → EvaluatePolicy → FetchAndInject → wait signal\n2. New RequestRegistry (sync.Map) bridging goproxy ↔ Temporal local activities  \n3. FetchAndInject local activity: vault fetch + request modification via RequestRegistry\n4. OnResponse signals workflow with response_complete (scrub count, status)\n5. Remove dead FetchAndForward activity and AuditWorkflow\n6. Update Gateway struct: add RequestRegistry, remove direct authn/authz deps\n7. Update main.go: register new workflow + activities, wire registry","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:05.811714738-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T11:44:11.194350506-08:00","closed_at":"2026-02-17T11:44:11.194350506-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-g5f","title":"REVIEW 3: Elegance and complexity matching","description":"# Review 3: Elegance and Complexity Matching\n\nReviewed credential-proxy for interface completeness, over/under-engineering, and complexity proportionality.\n\n## Component Inventory (1,581 prod LOC, 1,542 test LOC, 475 Nix LOC)\n- config/ (193 LOC) — YAML parsing, validation, indexed lookups — MATCHED\n- authn/ (123 LOC) — Keycloak JWT validation — MATCHED\n- authz/ (235 LOC) — OPA embedded + Rego policy — MATCHED\n- vault/ (95 LOC) — OpenBao KV v2 wrapper — SLIGHTLY INCOMPLETE (no health check)\n- proxy/ (483 LOC) — Gateway, handlers, placeholder, sanitizer — MATCHED\n- workflows/ (303 LOC) — Temporal workflows + activities — OVER (dead code)\n- audit/ (50 LOC) — Search attribute definitions — MATCHED\n\n## Interface Audit — All Complete\n- authn.Verifier: Single-method VerifyToken — complete for forward-proxy authn\n- authz.Evaluator: Single-method Evaluate — complete for binary gate authorization\n- vault.SecretStore: FetchCredential — slightly incomplete (missing HealthCheck)\n- config.Config: LookupCredential, IsAllowedDomain — complete\n- proxy.Gateway: NewGateway + http.Handler — complete and well-designed\n\n## Over-Engineering\n1. ProxyRequestWorkflow + FetchAndForward are dead code (~600 LOC production + test)\n2. FetchAndForward rebuilds HTTP request from scratch, discarding headers/body/query — would be buggy if invoked\n3. CredentialType enum exists but has no behavioral dispatch (MINOR — acceptable as documentation)\n\n## Under-Engineering\n1. HIGH: No body size limits in Extract() and ScrubCredentials() — OOM risk via io.ReadAll on unbounded bodies\n2. HIGH: Compressed responses bypass scrubbing (Content-Encoding: gzip not handled)\n3. MODERATE: No vault health check at startup — confusing error at request time\n4. MODERATE: Vault token is static string only — no AppRole/renewal (acceptable for MVP)\n5. MINOR: No rate limiting (acceptable for MVP)\n6. MINOR: Temporal audit failure silently logged, no metrics\n7. MODERATE: Response scrubbing only handles exact string matching (no base64/URL-encoded variants)\n\n## Complexity Scorecard\n8 packages matching 5 architectural components + config + audit + main = PROPORTIONAL\nNo God objects, no micro-packages. Package structure aligns with architecture.\nOnly deviation: unused Temporal workflow code inflates audit component.","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:27:57.517420745-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:13.635260587-08:00","closed_at":"2026-02-17T14:37:13.635260587-08:00","close_reason":"Wave 1 reviews completed, findings addressed by wave 2 slices","dependencies":[{"issue_id":"nix-openclaw-vm-g5f","depends_on_id":"nix-openclaw-vm-oxd","type":"blocks","created_at":"2026-02-17T09:31:01.821585968-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-g5f","depends_on_id":"nix-openclaw-vm-hm3","type":"blocks","created_at":"2026-02-17T09:31:02.719929063-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-g5f","depends_on_id":"nix-openclaw-vm-r42","type":"blocks","created_at":"2026-02-17T09:31:03.573957959-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-g5f","depends_on_id":"nix-openclaw-vm-dwl","type":"blocks","created_at":"2026-02-17T09:31:04.561992567-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-g5f","depends_on_id":"nix-openclaw-vm-xno","type":"blocks","created_at":"2026-02-17T11:44:13.904822014-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-g5f","depends_on_id":"nix-openclaw-vm-8h6","type":"blocks","created_at":"2026-02-17T11:44:54.250303533-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-glo","title":"[SLICE 1] Hardened proxy request decision pipeline","description":"## Vertical Slice: Request Decision Lifecycle\n\n**Production code path:** Agent HTTP request → goproxy CONNECT → OnRequest → Temporal ProxyRequestWorkflow (authz → inject) → DecisionCh → forward → OnResponse → scrub → signal → complete\n\n**End user observes:** Requests never hang (deadlock-proof), authentication failures return 407, authorization denials return 403, vault errors return 502, and JWT is validated before workflow starts (no wasted Temporal load).\n\n### Worker Owns (Full Vertical)\n\nPlan backwards from production code path:\n1. End: Roundtrip integration test (auz) proves full lifecycle — goproxy → Temporal → RequestRegistry → vault → scrub → signal → complete\n2. Back: Structured error types (d3k) — DenialReason.HTTPStatusCode() maps correctly in goproxy OnRequest handler\n3. Back: JWT validation in goproxy (zyg) — go-oidc validates in OnRequest, only IdentityClaims cross to workflow. ValidateIdentity activity removed.\n4. Back: DecisionCh deadlock fix (ct4) — select+timeout replaces bare channel read, all workflow exit paths send on DecisionCh\n\n### Leaf Tasks\n\n- **ct4** (P0): Fix DecisionCh deadlock — select with timeout on all bare channel reads\n- **zyg** (P1): Move JWT validation from Temporal activity to goproxy OnRequest\n- **d3k** (P1): Add structured error types from workflow decisions to goproxy\n- **auz** (P1): Add goproxy-Temporal-RequestRegistry roundtrip integration test\n\n### Files You Own\n\n- credential-proxy/proxy/handlers.go (select+timeout, JWT validation, error status mapping)\n- credential-proxy/workflows/proxy_workflow.go (remove ValidateIdentity phase, update ProxyInput)\n- credential-proxy/workflows/activities.go (remove/refactor ValidateIdentity, update types)\n- credential-proxy/proxy/gateway_integration_test.go (NEW: roundtrip integration test)\n- credential-proxy/proxy/gateway_test.go (update existing tests for new flow)\n- credential-proxy/workflows/proxy_workflow_test.go (update for removed ValidateIdentity)\n- credential-proxy/workflows/activities_test.go (update for activity changes)\n\n### Implementation Order (Layers Within Slice)\n\n**Layer 1: Types + Protocol Changes**\n- Update ProxyInput: replace RawJWT with IdentityClaims\n- Verify DenialReason.HTTPStatusCode() mapping is complete (407/403/502/504/500)\n- Add Verifier field to Gateway (for in-process JWT validation)\n\n**Layer 2: Tests**\n- Update existing workflow/activity tests for removed ValidateIdentity\n- Write roundtrip integration test (auz) — will FAIL initially\n- Test: unauthenticated → 407, unauthorized → 403, vault down → 502, happy path → 200\n\n**Layer 3: Implementation**\n- ct4: Replace bare `\u003c-decisionCh` with select+timeout in handleRequest\n- zyg: Add go-oidc validation in handleRequest before workflow start\n- d3k: Map decision.HTTPStatus to HTTP response in handleRequest\n- Remove ValidateIdentity from workflow + activities (or keep as optional fallback)\n- Tests should now PASS\n\n### Validation\n\n- [ ] `go test -race ./proxy/ -v` passes (including roundtrip integration test)\n- [ ] `go test -race ./workflows/ -v` passes\n- [ ] Unauthenticated request → 407 Proxy Authentication Required\n- [ ] Unauthorized request → 403 Forbidden\n- [ ] Vault error → 502 Bad Gateway\n- [ ] Happy path → credentials injected, response scrubbed, workflow completes\n- [ ] No goroutine leaks (DecisionCh always drained)\n- [ ] ast-grep scan: zero violations\n- [ ] No bare channel reads without select+timeout","status":"closed","priority":0,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T13:38:17.084727716-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:12.2894668-08:00","closed_at":"2026-02-17T14:37:12.2894668-08:00","close_reason":"All leaf tasks completed by wave 2 workers","dependencies":[{"issue_id":"nix-openclaw-vm-glo","depends_on_id":"nix-openclaw-vm-ct4","type":"blocks","created_at":"2026-02-17T13:39:07.410416063-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-glo","depends_on_id":"nix-openclaw-vm-zyg","type":"blocks","created_at":"2026-02-17T13:39:07.436961247-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-glo","depends_on_id":"nix-openclaw-vm-d3k","type":"blocks","created_at":"2026-02-17T13:39:07.463929869-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-glo","depends_on_id":"nix-openclaw-vm-auz","type":"blocks","created_at":"2026-02-17T13:39:07.489825027-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-h80","title":"[SLICE 0] Test concurrency infrastructure: goleak + race detector","description":"## Layer 0: Cross-Cutting Test Quality Infrastructure\n\n**Production verification:** `go test -race ./...` passes with zero goroutine leaks\n\n### Worker Owns (Full Vertical)\n\nPlan backwards from verification:\n1. End: All test packages use goleak, -race flag in CI/Nix build\n2. Back: `go test -race ./...` runs clean (no data races, no leaked goroutines)\n3. Back: goleak TestMain wrappers in proxy/, workflows/, authn/, authz/\n4. Back: `-race` added to flake.nix checkPhase + AGENTS.md docs\n\n### Leaf Tasks\n\n- **4tp**: Add goleak to all test packages\n- **32d**: Enable -race flag for Go tests\n\n### Files You Own\n\n- credential-proxy/proxy/gateway_test.go (add TestMain)\n- credential-proxy/workflows/proxy_workflow_test.go (add TestMain)\n- credential-proxy/workflows/activities_test.go (add TestMain)\n- credential-proxy/authn/oidc_test.go (add TestMain)\n- credential-proxy/authz/engine_test.go (add TestMain)\n- credential-proxy/flake.nix (checkPhase: -race flag)\n- AGENTS.md (document -race in test section)\n- go.mod / go.sum (add go.uber.org/goleak)\n\n### Implementation Order\n\n**Step 1:** Add goleak dependency, add TestMain wrappers\n**Step 2:** Run tests — fix any goroutine leaks that surface\n**Step 3:** Add -race to flake.nix checkPhase, document in AGENTS.md\n**Step 4:** Run `go test -race ./...` — fix any data races\n\n### Validation\n\n- [ ] `go test -race ./...` passes (zero data races)\n- [ ] goleak detects no leaked goroutines\n- [ ] `nix build .#credential-proxy` with checkPhase passes\n- [ ] AGENTS.md documents -race testing","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T13:37:58.53923388-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:12.283507294-08:00","closed_at":"2026-02-17T14:37:12.283507294-08:00","close_reason":"All leaf tasks completed by wave 2 workers","dependencies":[{"issue_id":"nix-openclaw-vm-h80","depends_on_id":"nix-openclaw-vm-4tp","type":"blocks","created_at":"2026-02-17T13:39:07.356609696-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-h80","depends_on_id":"nix-openclaw-vm-32d","type":"blocks","created_at":"2026-02-17T13:39:07.383109334-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-hm3","title":"Handle compressed responses in credential scrubbing","description":"If upstream sends Content-Encoding: gzip, ScrubCredentials scrubs compressed bytes — credential strings won't match and will pass through unscrubbed. Fix: set Accept-Encoding: identity on outbound requests (via goproxy OnRequest handler) to prevent compressed responses needing scrubbing. ~5 lines.","status":"closed","priority":1,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:14.00283115-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T11:44:11.199416698-08:00","closed_at":"2026-02-17T11:44:11.199416698-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-irv","title":"Study Keycloak OIDC integration patterns for credential proxy","description":"Study Keycloak's OIDC/OAuth2 implementation to understand how credential-proxy will integrate. Focus areas: realm configuration, client credential grants, service account setup, JWKS endpoint, realm_access.roles claim structure, token exchange flows, and how to configure a realm for agent authentication. Understand the admin REST API for programmatic setup in NixOS modules.","notes":"Research completed. Report written to docs/research/keycloak.Rmd. Key findings: (1) Realms provide full tenant isolation with independent keys/users/roles -- ideal for per-VM agent isolation. (2) client_credentials flow is correct for service accounts; credproxy-auth.sh implementation is sound. (3) realm_access.roles extraction in oidc.go is correct but groups claim requires explicit GroupMembershipMapper. (4) Audience must be configured via AudienceProtocolMapper for aud verification to pass. (5) NixOS has services.keycloak module with realmFiles for declarative realm import. (6) Token exchange (RFC 8693) is not needed for current architecture. (7) resource_access extraction should be added for per-client role scoping.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:16:24.60270627-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:29:13.329894396-08:00","closed_at":"2026-02-17T08:29:13.329894396-08:00","close_reason":"Research completed, reports written to docs/research/"}
{"id":"nix-openclaw-vm-lm1","title":"Study OSS patterns from proposal research to improve credential-proxy","description":"Clone and study OSS projects from the proposal's research findings. Extract design patterns, interfaces, and security practices to improve our credential-proxy. Key repos: secretless-broker (provider/connector pattern), goproxy (handler patterns), octelium (policy-as-code), oathkeeper (mutators/rules), peta-core (JIT decryption), vultrino (alias-based refs).","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:08:36.05937192-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:29:23.125244408-08:00","closed_at":"2026-02-17T08:29:23.125244408-08:00","close_reason":"All 11 OSS and infrastructure study sub-tickets completed, research reports written to docs/research/","dependencies":[{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-bhw","type":"blocks","created_at":"2026-02-17T08:12:31.707974452-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-wzj","type":"blocks","created_at":"2026-02-17T08:12:31.73764208-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-d6c","type":"blocks","created_at":"2026-02-17T08:12:31.765293887-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-6h5","type":"blocks","created_at":"2026-02-17T08:12:31.792940754-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-mot","type":"blocks","created_at":"2026-02-17T08:12:31.820664366-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-m6g","type":"blocks","created_at":"2026-02-17T08:12:31.846791547-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-5x1","type":"blocks","created_at":"2026-02-17T08:12:31.875463608-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-irv","type":"blocks","created_at":"2026-02-17T08:16:48.984245578-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-34h","type":"blocks","created_at":"2026-02-17T08:16:49.011310115-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-qfp","type":"blocks","created_at":"2026-02-17T08:16:49.036977639-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-3xk","type":"blocks","created_at":"2026-02-17T08:16:49.063674323-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-lvm","title":"MVP: End-to-end smoke test (boot VM + proxied request)","description":"## Goal\nBoot the test-vm with credential proxy enabled and make a successful proxied request from guest to external API.\n\n## Steps\n1. nix build .#test-vm\n2. ./result/bin/microvm-run\n3. Verify services: systemctl status credproxy credproxy-temporal credproxy-ca-init\n4. From guest: credproxy-auth (obtain JWT)\n5. From guest: credproxy-request GET https://httpbin.org/headers\n6. Verify: response shows injected credentials in headers\n7. Verify: response body has credentials scrubbed\n8. Verify: Temporal workflow recorded in audit\n\n## Dependencies\n- Keycloak mock/service running\n- OpenBao mock/service running  \n- Sample credentials defined in test-vm config\n\n## Acceptance\n- [ ] VM boots with all credential proxy services running\n- [ ] Guest can authenticate via credproxy-auth\n- [ ] credproxy-request injects credential into outbound request\n- [ ] Response scrubbing removes credential from response\n- [ ] Temporal audit shows workflow execution","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T15:21:36.334209482-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T15:21:36.334209482-08:00","dependencies":[{"issue_id":"nix-openclaw-vm-lvm","depends_on_id":"nix-openclaw-vm-opa","type":"blocks","created_at":"2026-02-17T15:21:43.43766464-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lvm","depends_on_id":"nix-openclaw-vm-8y4","type":"blocks","created_at":"2026-02-17T15:21:43.465415568-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lvm","depends_on_id":"nix-openclaw-vm-71r","type":"blocks","created_at":"2026-02-17T15:21:43.493757049-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-m1b","title":"[SLICE 3] VM network lockdown with Tailscale SSH exemption","description":"## Vertical Slice: VM Network Isolation\n\n**Production code path:** VM boots with credential proxy enabled → nftables credproxy-lockdown chain blocks direct internet → VSOCK proxy is the only outbound path → Tailscale/Headscale SSH access is preserved for remote management.\n\n**End user observes:** Agent in VM cannot reach the internet directly (must go through credential proxy). SSH via Tailscale/Headscale continues to work for the operator.\n\n### Worker Owns (Full Vertical)\n\nPlan backwards from production code path:\n1. End: VM cannot curl external sites, but `tailscale ssh` into VM works\n2. Back: nftables credproxy-lockdown chain exempts Tailscale interface/mark\n3. Back: Existing Tailscale mark (0x00044F43) and interface config already present in openclaw-vm-firewall\n\n### Leaf Tasks\n\n- **0ei** (P1): Fix credproxy-lockdown nftables to allow Tailscale/Headscale SSH traffic\n\n### Files You Own\n\n- modules/openclaw-vm/default.nix (credproxy-lockdown chain, ~lines 559-587)\n\n### Context\n\nThe existing nftables configuration has:\n- `credproxy-lockdown` chain at priority 0 (forward hook)\n- Allows: established/related, DNS to bridge gateway\n- Drops: everything else\n\nThe existing `openclaw-vm-firewall` table (priority -10) already:\n- Marks VM traffic with `0x00044F43` (Tailscale forwarding bit + OpenClaw ID) in prerouting\n- Has Tailscale interface awareness via `cfg.tailscale` options\n\nThe fix needs to add rules BEFORE the final `drop` in credproxy-lockdown:\n- Option A: `iifname \"tailscale0\" accept` + `oifname \"tailscale0\" accept`\n- Option B: `meta mark \u0026 0x00040000 == 0x00040000 accept` (Tailscale forwarding bit)\n- Option A is more explicit; Option B is more robust if interface name changes\n\n### Implementation Order\n\n**Layer 1: Analysis**\n- Verify Tailscale interface name in VM context (tailscale0 vs ts0)\n- Check if cfg.tailscale options expose interface name\n- Determine if mark-based or interface-based exemption is safer\n\n**Layer 2: Tests**\n- `nix flake check` passes (module evaluation)\n- `nix build .#test-vm` succeeds\n\n**Layer 3: Implementation**\n- Add Tailscale exemption rules to credproxy-lockdown chain\n- Conditional on `cfg.credentialProxy.enable \u0026\u0026 cfg.tailscale.enable`\n\n### Validation\n\n- [ ] `nix flake check` passes\n- [ ] `nix build .#test-vm` succeeds\n- [ ] credproxy-lockdown chain includes Tailscale exemption (inspect generated nftables)\n- [ ] Chain structure: established → DNS → Tailscale → drop","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T13:38:42.334444495-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:12.301712277-08:00","closed_at":"2026-02-17T14:37:12.301712277-08:00","close_reason":"All leaf tasks completed by wave 2 workers","dependencies":[{"issue_id":"nix-openclaw-vm-m1b","depends_on_id":"nix-openclaw-vm-0ei","type":"blocks","created_at":"2026-02-17T13:39:07.541904911-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-m6g","title":"Study Agent Gateway RBAC and header patterns","description":"Study agentgateway/agentgateway for RBAC model, JWT-based auth, header manipulation patterns, and MCP/A2A gateway architecture. Key areas: how they compose auth middleware, header injection/removal, per-route policies. Compare with our authn/authz pipeline.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:14.685122906-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.767206429-08:00","closed_at":"2026-02-17T08:16:09.767206429-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-mot","title":"Study Vultrino alias-based credential references","description":"Study zachyking/vultrino for alias-based credential references, MCP server integration, and WASM plugin architecture. Key areas: how aliases map to credentials, plugin extensibility model, client-side integration patterns. Compare with our placeholder UUID approach.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:12.410460005-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.76286416-08:00","closed_at":"2026-02-17T08:16:09.76286416-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-na4","title":"REVIEW 2: Test quality and coverage","description":"# Review 2: Test Quality and Coverage\n\nReviewed all test files in credential-proxy/ for mock discipline, fixture usage, integration coverage, and brittleness.\n\n## Strengths\n- SUT is never mocked — all tests exercise real production code\n- Gateway integration tests (gateway_test.go) are genuinely end-to-end through full goproxy handler chain\n- OPA tests use real policy evaluation, loading actual .rego from disk\n- Package-level constants for shared placeholder/secret values\n- Test-to-production ratio: 0.98:1\n\n## Mock Analysis — All Correct\n- proxy/placeholder_test.go, proxy/sanitizer_test.go: No mocks needed (pure functions)\n- authz/engine_test.go: Real OPAEvaluator with real Rego policy, no mocks\n- authn/oidc_test.go: Real helper functions, no mocks (OIDCVerifier.VerifyToken not tested — reasonable, requires live Keycloak)\n- workflows/activities_test.go: Real Activities methods, mocks only for dependencies (vault, OPA)\n- proxy/gateway_test.go: Real Gateway with real goproxy MITM, mocks only for dependencies (authn, authz, vault, Temporal)\n\n## Integration Coverage Gaps\n1. No Temporal workflow tests — ProxyRequestWorkflow and AuditWorkflow have zero coverage\n2. No HTTPS CONNECT integration test — production-critical TLS MITM path untested\n3. No config/config_test.go — validation edge cases untested\n4. No vault/client_test.go — KV v2 response parsing untested\n5. No test for connTokens cleanup in handleResponse (memory leak regression)\n6. No audit/search_attributes_test.go (low priority — trivial logic)\n\n## Fixture Analysis\n- Within-package: well-centralized (package-level consts, helper functions)\n- Cross-package: mock types duplicated (mockEvaluator, mockStore in both gateway_test.go and activities_test.go)\n- Config: two separate testConfig() helpers with different inline YAML\n\n## Brittleness Hotspots\n- String-based error assertions in activities_test.go and gateway_test.go\n- Should use typed Temporal errors (temporal.NewNonRetryableApplicationError) for type-based assertions","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:27:40.067869746-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:13.628951973-08:00","closed_at":"2026-02-17T14:37:13.628951973-08:00","close_reason":"Wave 1 reviews completed, findings addressed by wave 2 slices","dependencies":[{"issue_id":"nix-openclaw-vm-na4","depends_on_id":"nix-openclaw-vm-o29","type":"blocks","created_at":"2026-02-17T09:30:59.103186909-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-na4","depends_on_id":"nix-openclaw-vm-c5x","type":"blocks","created_at":"2026-02-17T09:30:59.909297197-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-na4","depends_on_id":"nix-openclaw-vm-5hx","type":"blocks","created_at":"2026-02-17T09:31:00.879349748-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-na4","depends_on_id":"nix-openclaw-vm-4tp","type":"blocks","created_at":"2026-02-17T11:44:12.007981128-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-na4","depends_on_id":"nix-openclaw-vm-32d","type":"blocks","created_at":"2026-02-17T11:44:12.754519221-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-na4","depends_on_id":"nix-openclaw-vm-auz","type":"blocks","created_at":"2026-02-17T11:44:54.27844085-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-o29","title":"Add ProxyRequestWorkflow tests with testsuite.TestWorkflowEnvironment","description":"Test the new ProxyRequestWorkflow that orchestrates the full lifecycle:\n\n1. Happy path: authn → authz → fetch+inject → response signal → completion\n2. Auth failure: ValidateIdentity fails → workflow returns denied, no further activities\n3. Authz denial: EvaluatePolicy denies → workflow returns denied, no FetchAndInject\n4. Inject failure: FetchAndInject fails (vault error) → workflow returns error\n5. Signal timeout: workflow times out waiting for response_complete signal (60s)\n6. Search attributes: verify all attributes set at each phase\n\nUse testsuite.TestWorkflowEnvironment with mock activities. RequestRegistry integration tests should use a real registry + local activities.","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:19.528257288-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T12:04:19.933680241-08:00","closed_at":"2026-02-17T12:04:19.933680241-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-opa","title":"MVP: Mock Keycloak OIDC service for dev mode","description":"## Goal\nProvide a Keycloak-compatible OIDC endpoint for the test-vm so credproxy can validate JWTs without a full Keycloak deployment.\n\n## Options (pick one)\n1. **NixOS keycloak module** — Import from nixpkgs, configure realm \"openclaw\" with client \"credproxy\". Heavyweight but real.\n2. **Mock OIDC service** — Minimal Go/shell service returning static JWKS + issuing tokens. Lightweight, fast to build.\n3. **Static JWT bypass** — In dangerousDevMode, skip OIDC validation entirely and use a pre-signed JWT. Fastest but doesn't test auth pipeline.\n\n## Context\n- Keycloak wrapper exists at `modules/openclaw/keycloak.nix`\n- OIDC config: issuer=`http://127.0.0.1:8080/realms/openclaw`, audience=`credproxy`\n- authn package validates JWTs against OIDC discovery endpoint\n- Guest scripts expect `client_credentials` grant to get JWT\n\n## Acceptance\n- [ ] Test-vm can obtain a valid JWT token\n- [ ] credproxy validates the JWT successfully\n- [ ] `nix flake check` passes","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T15:21:20.245758947-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T15:21:20.245758947-08:00"}
{"id":"nix-openclaw-vm-oxd","title":"Add body size limits to Extract() and ScrubCredentials()","description":"Both Extract() and ScrubCredentials() call io.ReadAll() on unbounded request/response bodies. Malicious agent or large API response could OOM the proxy. Add configurable MaxBodySize (e.g., 10MB default) to Config and use io.LimitReader. ~20 lines of change.","status":"closed","priority":1,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:11.369189131-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T11:30:35.168882313-08:00","closed_at":"2026-02-17T11:30:35.168882313-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-pci","title":"Research: Temporal usage in proxy/agent orchestration (awesome-temporal)","description":"Search awesome-temporal and broader ecosystem for projects using Temporal in domains similar to ours: credential proxies, agent orchestration, security pipelines, access control. Write research report to docs/research/. Update AGENTS.md design references table.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:37:37.502360244-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:42:22.150237513-08:00","closed_at":"2026-02-17T09:42:22.150237513-08:00","close_reason":"Research report written to docs/research/temporal-agent-orchestration.Rmd, AGENTS.md updated"}
{"id":"nix-openclaw-vm-qfp","title":"Study Temporal workflow patterns for credential proxy audit","description":"Study Temporal's architecture and Go SDK to understand how credential-proxy will use it for audit workflows. Focus areas: workflow vs activity distinction, search attributes (custom typed), event history (what gets persisted vs sealed), workflow ID design patterns, task queue architecture, retry policies, worker lifecycle, dev server (temporal-cli), and visibility/query APIs for forensic analysis.","notes":"Research completed. Report written to docs/research/temporal.Rmd. Key findings: (1) Current secret isolation design is correct - vault paths safe in event history, secrets only in activity memory. (2) All 4 custom Keyword search attributes fit within SQLite dev server limits (10 max). (3) Auth denials should use temporal.NewNonRetryableApplicationError. (4) Worker needs explicit MaxConcurrentActivityExecutionSize limits. (5) Visibility API supports SQL-like queries for forensic analysis. (6) Dev server registers search attrs via --search-attribute flags at startup. (7) Workflow IDs should consider deterministic patterns for deduplication. (8) Production needs dedicated namespace with retention policy.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:16:31.877250423-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:29:13.338721161-08:00","closed_at":"2026-02-17T08:29:13.338721161-08:00","close_reason":"Research completed, reports written to docs/research/"}
{"id":"nix-openclaw-vm-r42","title":"Add vault health check at startup","description":"NewOpenBaoClient succeeds without connecting — vault reachability issues surface as confusing 'credential resolution failed' at request time. Add a Sys().Health() or test FetchCredential call during run() after client init. ~10 lines.","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:16.436289477-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T11:44:11.204276119-08:00","closed_at":"2026-02-17T11:44:11.204276119-08:00","close_reason":"Closed"}
{"id":"nix-openclaw-vm-ruw","title":"Wire registry.Start() in main.go — sweeper never activated","description":"All 3 wave 2 reviewers flagged this: RequestRegistry.Start(ctx, ttl, sweepInterval) is implemented in registry.go and tested in registry_test.go, but never called in main.go. The defence-in-depth sweeper for stale entries is dead code at runtime.\n\nFix: Add registry.Start(ctx, cfg.RegistryTTL(), 30*time.Second) after line 93 in main.go.\n\nAlso remove dead ValidateIdentity activity (never called after JWT validation moved to goproxy) and unused Verifier field wiring in Activities struct.\n\nFix misleading FetchAndInject comment (activities.go:280-281) — should say \"MUST send on DecisionCh before returning if the registry entry exists.\"\n\nFiles: credential-proxy/main.go, credential-proxy/workflows/activities.go","status":"closed","priority":1,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T14:33:36.985811033-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:43:39.736975389-08:00","closed_at":"2026-02-17T14:43:39.736975389-08:00","close_reason":"registry.Start() wired in main.go, dead ValidateIdentity removed, FetchAndInject comment fixed"}
{"id":"nix-openclaw-vm-sil","title":"REVIEW 1: Correctness to proposal/URD","description":"# Review 1: Correctness (Spirit and Technicality)\n\nReviewed the implementation plan (7xk) against the PROPOSAL (35e) and URD (whp).\n\n## Matches (17 confirmed)\n- M1: Language (Go) — matches URD Q5/Q6\n- M2: Proxy mode (goproxy forward proxy with MITM) — matches URD Q14\n- M3: Transport (VSOCK via mdlayher/vsock) — matches URD Q17\n- M4: Credential pattern (opaque UUID placeholders) — matches URD Q3/Q7\n- M5: Authentication (Keycloak OIDC JWT via coreos/go-oidc) — matches URD Q25/Q26\n- M6: Authorization (OPA embedded with Rego) — matches URD Q24\n- M7: Domain binding (fail-closed, two enforcement layers) — matches URD Q3\n- M8: Response sanitization (credential scrubbing) — matches URD Q3\n- M9: Temporal from day 1 — matches URD Q1 (but see G1)\n- M10: Deployment (systemd service on host) — matches URD Q2\n- M11: Temporal hosting (temporal-cli dev server) — matches URD Q8\n- M12: Guest client (shell wrapper) — matches URD Q4\n- M13: OpenBao client with DI interface — matches proposal\n- M14: CA cert generation at runtime (IMPROVED over proposal — private keys never in /nix/store)\n- M15: Provisioning via env vars — partial match URD Q9\n- M16: 5-component architecture in single Go binary — matches proposal\n- M17: OpenBao read-only policy — matches proposal\n- M18: MITM CA installed in guest — matches proposal\n- M19: Redirect-following disabled (enhancement beyond spec)\n\n## Gaps\n- G1: Temporal reduced to fire-and-forget audit (proposal said each request = workflow) — ProxyRequestWorkflow is dead code\n- G2: BLOCKING — Rego policies not bundled into Nix package (no postInstall step)\n- G3: fw_cfg provisioning not implemented (URD said both env vars + fw_cfg)\n- G4: Phase 5 VM network lockdown (nftables) not implemented — security gap\n- G5: Retry policy says 2 attempts, proposal said 3 (moot — dead code)\n- G6: Timestamp search attribute missing (Temporal provides implicitly)\n- G7: BLOCKING — vendorHash = null with no vendor directory breaks Nix build\n- G8: No modifications to existing openclaw-vm modules (standalone approach is arguably cleaner)\n- G9: JSONL audit logging delegated to slog + Temporal (acceptable)\n\n## Contradictions\n- C1: vsock.Listen API — implementation is correct, proposal pseudocode was wrong\n- C2: Temporal is audit-only, not request-orchestrating (see G1)\n- C3: Package naming auth/ → authn/ (cosmetic improvement)\n\n## Ambiguities (likely bugs)\n- A2: OPA identity mismatch — Rego expects input.identity.roles but Keycloak JWTs have realm_access.roles. Tests mask this by constructing identity with top-level roles key. LIKELY BUG that would deny all requests in production.\n- A5: Response sanitization does not handle compressed responses","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:27:26.780524876-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:13.62303069-08:00","closed_at":"2026-02-17T14:37:13.62303069-08:00","close_reason":"Wave 1 reviews completed, findings addressed by wave 2 slices","dependencies":[{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-52l","type":"blocks","created_at":"2026-02-17T09:30:54.479671027-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-1l8","type":"blocks","created_at":"2026-02-17T09:30:55.323021688-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-14h","type":"blocks","created_at":"2026-02-17T09:30:56.314804896-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-ffs","type":"blocks","created_at":"2026-02-17T09:30:57.264632943-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-cgg","type":"blocks","created_at":"2026-02-17T09:30:58.10160719-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-ct4","type":"blocks","created_at":"2026-02-17T11:44:10.843254793-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-zyg","type":"blocks","created_at":"2026-02-17T11:44:54.195368194-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-d3k","type":"blocks","created_at":"2026-02-17T11:44:54.223064319-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-6vm","type":"blocks","created_at":"2026-02-17T11:47:10.441783102-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-db8","type":"blocks","created_at":"2026-02-17T11:51:35.320055614-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-whp","title":"URE: Credential proxy scope and MVP","description":"## User Requirements Elicitation — Credential Proxy Security Layer\n\n### Session 1: Initial Requirements Interview\n\n#### URE Q1: MVP Scope\n**Q:** \"What is the MVP scope? Should Phase 1 focus on just the proxy + OpenBao domain binding, or do you also want Temporal orchestration in the MVP?\"\n- (1) Proxy + domain binding only — MVP: VSOCK listener, OpenBao credential fetch, domain binding check, header injection, JSONL audit. Add Temporal later.\n- (2) Include Temporal from start — Build on Temporal from day 1: each proxy request = workflow execution, audit trail via workflow history, event replay built-in.\n- (3) Temporal for audit only — Simple proxy handles requests directly, but logs events to Temporal for audit trail and replay. Hybrid approach.\n\n**A:** \"Include Temporal from start\"\n\n#### URE Q2: Deployment Model\n**Q:** \"For deployment: should the credential proxy run as a standalone systemd service on the host, or inside a container (Podman) like OpenBao?\"\n- (1) Systemd service (Recommended) — Native binary, systemd hardening (like the existing gateway). Simpler, less overhead, direct VSOCK access.\n- (2) Podman container — Containerized like OpenBao. More isolation but adds complexity for VSOCK passthrough.\n- (3) Decide later — Design the NixOS module to support both, decide during implementation.\n\n**A:** \"Systemd service (Recommended)\"\n\n#### URE Q3: Response Templating\n**Q:** \"How important is response templating (agent requests specific fields, proxy strips the rest) for MVP? The agent-sandbox.md spec includes it but it adds complexity.\"\n- (1) Essential for MVP — Agent should never see fields it didn't request (PII protection, minimizing attack surface).\n- (2) Defer to Phase 2 — MVP passes full response through. Add field filtering later. Domain binding is the critical security layer.\n\n**A:** \"Essential for MVP — Agent should never see fields it didn't request (PII protection, minimizing attack surface). But also, the response should NOT contain any auth / secrets. It should just contain that placeholder string. I imagine something similar to vaultwarden, where the secret has a templated form `agent-vault-\u003cuuid\u003e`, and the proxy searches for this, ingests it, replaces it on the proxy-side, and responses all replace the auth with this string when returned to the agent.\"\n\n#### URE Q4: Guest-Side Client\n**Q:** \"Should the guest-side client be a proper CLI tool, or is a simple shell wrapper (e.g., around socat/curl) sufficient for MVP?\"\n- (1) Shell wrapper (socat+curl) — Minimal: shell script that sends JSON over VSOCK via socat. Quick to build, easy to debug.\n- (2) Proper CLI tool — Compiled binary with arg parsing, error handling, structured output. More robust but more work.\n- (3) Library/SDK — Import-able library the agent's code calls directly. Most ergonomic but heaviest to build.\n\n**A:** \"Shell wrapper (socat+curl)\"\n\n#### URE Q5: Language Preference (Free-form)\n**Q:** (Prompted by initial plan proposing Rust)\n\n**A:** \"Whoa. I don't know about using Rust. Why would that be the case? I think using Zig, Gleam/Elixir, or Golang would be better. Let's consider. Which language has decent support for Keycloak and OpenBao? I also don't want to re-implement this 'secret-to-domain' allowable mapping, or even the proxy itself if I can avoid it. Let's see what exists already. I'm particularly interested in trying to use Temporal on the backend, as this will help with building the audit trail, the event sourcing, and the event-driven system for the proxy.\"\n\n#### URE Q6: Language Confirmation (after research)\n**Q:** \"Given the research, Go is the only language with production-grade support for all three key dependencies (Temporal, OpenBao, OIDC). Are you okay with Go, or do you want to explore a polyglot approach (e.g., Go for the proxy, Gleam/Elixir for something else)?\"\n- (1) Go (Recommended) — Monolingual. First-party Vault client, tier 1 Temporal SDK, excellent OIDC + VSOCK + Nix support.\n- (2) Polyglot approach — Go for the proxy core, but use another language for some component (e.g., Gleam for a future API layer).\n- (3) Need more info — I want to dig deeper into one of the alternatives before deciding.\n\n**A:** \"Go (Recommended)\"\n\n#### URE Q7: Placeholder Pattern\n**Q:** \"For the credential placeholder pattern: should placeholders be per-credential-ref (e.g., `{{vault:openclaw/api/key}}`) or opaque UUIDs (e.g., `agent-vault-a1b2c3d4`) that map to credentials via a separate config?\"\n- (1) Opaque UUIDs — Agent sees `agent-vault-\u003cuuid\u003e`. Mapping from UUID to credential ref + domain is stored in proxy config. Agent can't infer what the credential is.\n- (2) Structured refs — Agent sees `{{vault:path/to/secret}}`. More readable, agent knows what credential it's using, but leaks the secret path.\n- (3) Agent-chosen aliases — Agent uses human-readable aliases like `my-api-key`. Proxy maps alias to credential ref + domain. Flexible but requires alias management.\n\n**A:** \"Opaque UUIDs\"\n\n#### URE Q8: Temporal Deployment\n**Q:** \"For Temporal deployment on NixOS: `temporal-cli` is in nixpkgs and includes a dev server with SQLite. For production, you'd want PostgreSQL-backed. Which path for the MVP?\"\n- (1) temporal-cli dev server — Single binary, SQLite, includes web UI. Simplest. Good enough for single-host with a few VMs. Can migrate to PostgreSQL later.\n- (2) Podman container — Use official temporalio/auto-setup Docker image in Podman. More production-like but adds container dependency.\n- (3) Full PostgreSQL setup — Build a proper NixOS module for Temporal with PostgreSQL backend. Most work upfront but most production-ready.\n\n**A:** \"temporal-cli dev server\"\n\n#### URE Q9: Credential Provisioning\n**Q:** \"How should placeholder-to-credential mappings be provisioned to the agent inside the VM? The agent needs to know which placeholder string to use for which service.\"\n- (1) Environment variables — Inject placeholders as env vars (e.g., ANTHROPIC_API_KEY=agent-vault-abc123). Agent code uses them naturally.\n- (2) Config file via fw_cfg — JSON config file passed through QEMU fw_cfg (like existing openclaw-config). Lists all available placeholders and their target services.\n- (3) Query proxy at boot — Agent asks the proxy 'what credentials do I have?' over VSOCK and gets back a list of placeholder aliases and their allowed domains.\n\n**A:** \"Can do (1) and (2).\"\n\n#### URE Q10: Transport Protocol\n**Q:** \"For the VSOCK transport, should the proxy act as an HTTP forward proxy (agent sets HTTP_PROXY env var, needs MITM TLS for HTTPS) or use a simple JSON RPC (agent sends {url, method, headers, body} and proxy makes the actual request)?\"\n- (1) JSON RPC (Recommended) — Simple POST to proxy with request details as JSON. No TLS MITM needed. Clean placeholder substitution. Matches your shell wrapper preference.\n- (2) HTTP forward proxy — Standard HTTP proxy (CONNECT tunneling). More transparent but requires MITM CA cert for HTTPS inspection. Complex.\n- (3) Both modes — JSON RPC for MVP, add forward proxy mode later for agents that want transparent proxying.\n\n**A:** \"JSON RPC (Recommended)\"\n\n#### URE Q11: User Directive on Solution Research (Free-form)\n\n**A:** \"Agent-native and agentic software / MCP open-source projects are generally terrible. Look for pre-existing and established solutions that were well-accepted by the security community for our problem in a NON-agentic scenario. This is inherently a non-agentic problem.\"\n\n#### URE Q12: Build vs Wrap (Octelium)\n**Q:** \"Given the research, Octelium (Go, 3.4k stars, AGPLv3) is the closest existing solution with 'secretless access' and Go implementation. Should we evaluate integrating/wrapping Octelium, or build custom since our requirements (VSOCK, Temporal, placeholder pattern) diverge enough?\"\n- (1) Build custom (Recommended) — Our requirements (VSOCK, Temporal, placeholder pattern, domain binding) are sufficiently unique. Borrow design patterns from Octelium/Peta/Vultrino but build our own ~500 lines of Go core logic.\n- (2) Evaluate Octelium first — Clone Octelium, read its credential injection code, and assess if we can wrap/extend it. Risk: AGPLv3 license, may not be worth the effort if VSOCK+Temporal don't fit.\n- (3) Evaluate Peta Core first — Clone Peta, read its vault/injection code. Risk: TypeScript (not Go), ELv2 license, may not fit our architecture.\n- (4) Hybrid approach — Use Octelium as the access gateway layer and bolt Temporal + custom VSOCK listener on top. Most integration work but most reuse.\n\n**A:** \"Evaluate Octelium first\"\n\n#### URE Q13: Additional Research\n**Q:** \"Is there anything else you'd like me to research before finalizing the plan? The research confirmed no existing solution covers our needs, and Go + custom proxy is the path.\"\n- (1) Research is sufficient — You've seen enough. Let's finalize the plan and move to implementation.\n- (2) Dig into Vultrino source — Clone zachyking/vultrino and study its architecture in detail — borrow design patterns for our Go implementation.\n- (3) Explore goproxy more — Investigate whether elazarl/goproxy could serve as the proxy foundation (forward proxy mode instead of JSON RPC).\n- (4) Something else — I want to research a specific topic before we proceed.\n\n**A:** \"Explore goproxy more\"\n\n#### URE Q14: Proxy Mode (after goproxy research)\n**Q:** \"Given goproxy's capabilities, should we use it as a transparent forward proxy (agent just sets HTTP_PROXY and makes normal requests) or stick with JSON RPC? The forward proxy approach means zero agent code changes but requires MITM TLS with a custom CA cert installed in the VM.\"\n- (1) Forward proxy (goproxy) — Agent sets HTTP_PROXY env var, makes normal requests. goproxy does MITM TLS, placeholder substitution, domain enforcement. Requires installing custom CA cert in VM.\n- (2) JSON RPC (current plan) — Agent uses credproxy wrapper to send structured JSON. No TLS MITM needed. More explicit but requires agent to use the wrapper.\n- (3) Both modes — Build on goproxy as foundation. Support both forward proxy mode AND a /proxy JSON RPC endpoint. Agent can use whichever suits its needs.\n- (4) Need more info — I want to understand the tradeoffs better before deciding.\n\n**A:** \"Forward proxy (goproxy)\"\n\n#### URE Q15: Credential Pattern + Implementation (Rejected)\n**Q:** \"Secretless Broker uses a 'transparent proxy' pattern where the agent doesn't know about credentials AT ALL (just sets http_proxy). Your placeholder pattern (agent-vault-uuid) gives the agent explicit control over where credentials go. Which approach do you prefer?\" / \"For the proxy implementation: should we wrap/extend Secretless Broker (reuse its Vault provider, connector system, HTTP proxy), or build a custom thin proxy using the Go vault/api client directly (~500 lines)?\"\n\n**A:** (REJECTED — user wanted clarification first)\n\n#### URE Q16: Clarification Request\n**Q:** \"What would you like to clarify about the credential pattern choice (transparent proxy vs placeholder) or the implementation approach (Secretless Broker vs custom)?\"\n- (1) Explain transparent proxy more\n- (2) Explain placeholder pattern more\n- (3) Explain Secretless limitations\n- (4) I have a different idea\n(Multi-select)\n\n**A:** \"Explain transparent proxy more, Explain Secretless limitations, Can I self-host Secretless Broker? This all needs to be self-hostable\"\n\n#### URE Q17: Transport (VSOCK vs TAP)\n**Q:** \"Should the proxy listen on VSOCK (direct hypervisor channel, no IP networking) or on the TAP bridge IP (10.88.0.1:18790, reuse existing network, simpler)? The VM already has a TAP interface for host communication.\"\n- (1) TAP bridge (simpler) — Proxy listens on 10.88.0.1:18790. VM sets HTTP_PROXY=http://10.88.0.1:18790. Reuses existing TAP network. nftables restricts VM to only reach the proxy. No socat needed.\n- (2) VSOCK (more isolated) — Proxy listens on VSOCK CID:4 port:18790. Adds socat bridge in VM. Physically impossible for traffic to escape. But adds the socat bridge complexity.\n- (3) Both (belt and suspenders) — Proxy listens on both. TAP for the forward proxy (HTTP_PROXY). VSOCK as a fallback/admin channel. Maximum flexibility.\n\n**A:** \"VSOCK (more isolated)\"\n\n#### URE Q18: Secretless Broker Approach (Premature)\n**Q:** \"Given Secretless Broker's gaps (no response sanitization, no Temporal, weak domain binding, no rate limiting), which approach do you prefer?\"\n\n**A:** \"So far have been given no details on Secretless Broker, what it is\"\n\n#### URE Q19: Build vs Wrap (after Secretless explanation)\n**Q:** \"Now that you understand Secretless Broker: should we use it as the credential injection layer and build our custom features on top, or build our own proxy that borrows its patterns?\"\n- (1) Use Secretless + add layers — Run Secretless as the credential injection proxy. Build a Go middleware service in front that adds: VSOCK listener, domain binding enforcement, Temporal audit, response sanitization, rate limiting. Two processes, most code reuse.\n- (2) Custom proxy, inspired by SB — Build our own single Go binary (~500 lines core). Use vault/api directly for OpenBao. Borrow Secretless design (connector configs, provider abstraction) but own the full stack. One process, full control.\n- (3) Fork Secretless Broker — Fork the repo, add our features (VSOCK, domain binding, Temporal, response sanitization) directly into the codebase. Most reuse but we maintain a fork.\n- (4) Clone and evaluate first — Before deciding, clone the Secretless Broker repo to ~/codebases/ and read the actual Go code. Understand the architecture hands-on before committing to an approach.\n\n**A:** \"Use Secretless + add layers\"\n\n#### URE Q20: Response Sanitization Conflict\n**Q:** \"Given the response sanitization conflict with Secretless Broker, which tradeoff do you prefer?\"\n- (1) Single Go binary (current plan) — Our proxy fetches creds from OpenBao, injects into requests, AND scrubs from responses. One process, full control. Uses goproxy for HTTP proxy + mdlayher/vsock for transport. This is what the current plan file already describes.\n- (2) Secretless + skip sanitization — Use Secretless for injection. Accept that API responses may leak credentials. Rely on domain binding to limit exposure. Simpler (Secretless handles Vault), but weaker security.\n- (3) Secretless + parallel fetch — Use Secretless for injection AND separately fetch creds from OpenBao in our middleware for sanitization. Two Vault lookups per request (one by Secretless, one by us). Redundant but keeps separation.\n- (4) Clone Secretless, evaluate — Before deciding, clone the Secretless Broker repo and read how its credential provider works. Maybe we can extract the provider interface as a library.\n\n**A:** \"Single Go binary (current plan)\"\n\n### Session 2: Deeper Research and Architecture Refinement\n\n#### ExitPlanMode Rejection 1: Existing Solutions Research\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"Still need to do research about what exists, and how we can avoid re-implementing this. For example, vaultwarden exists. How is it different from OpenBao? Any other auth proxies exist that do NOT expose ANY secrets AT ALL to the clients?\"\n\n#### ExitPlanMode Rejection 2: Online Research Needed\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"Still need to do research. Still have not looked online and seen what exists.\"\n\n#### ExitPlanMode Rejection 3: VSOCK Purpose\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"Why do we even need VSOCK? What's the purpose or point of VSOCK?\"\n\n#### ExitPlanMode Rejection 4: Secretless vs goproxy\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"If we use Secretless Broker, do we need goproxy?\"\n\n#### ExitPlanMode Rejection 5: Envoy Inquiry\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"So, what about Envoy + ext_authz? What is that? What does that do? why was it deemed too heavyweight?\"\n\n### Session 3: Continued Deep Research\n\n#### ExitPlanMode Rejection 6: OpenBao vs Vaultwarden\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"This is looking very good indeed. However, does OpenBao not handle the 'secret-to-domain' mapping already? or does Vaultwarden? Why do we use OpenBao instead of Vaultwarden?\"\n\n#### ExitPlanMode Rejection 7: OpenBao Extensions\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"In some sense, the agent is a human, and it essentially needs a secretless broker-style password manager for use in the CLI and developing applications. OpenBao has nice attributes though. Has there been no attempts at extending OpenBao with this application-level logic?\"\n\n#### URE Q21: Riptides + Boundary Investigation\n**Q:** \"Riptides is the closest existing solution to what you described. Want me to dig deeper into it before we finalize, or are you satisfied that the custom goproxy approach is the right path given our specific requirements (VSOCK, response sanitization, Temporal audit, NixOS)?\"\n- (1) Finalize with goproxy — The research is thorough. Custom Go proxy with goproxy + OpenBao + Temporal is the right call — nothing existing covers all our requirements.\n- (2) Investigate Riptides — Dig deeper into Riptides — licensing, source availability, how kernel-level injection works, whether it could work inside a microVM with VSOCK.\n- (3) Investigate Boundary — Dig deeper into HashiCorp Boundary's credential injection — it's the 'official' Vault ecosystem approach even if HTTP API support is pending.\n\n**A:** \"Investigate deeper into both Riptides and Boundary. Is there an open-source alternative to Boundary? Must be self-hostable. Surprised the security and privacy communities haven't developed anything here yet.\"\n\n#### URE Q22: Ready to Finalize?\n**Q:** \"The research is thorough across 17 solutions. The gap is real — no OSS tool provides outbound HTTPS credential injection + response sanitization + VSOCK + audit. Ready to finalize the custom Go proxy plan, or is there another direction you want explored?\"\n- (1) Finalize plan — Research is complete. The custom Go proxy (goproxy + OpenBao + Temporal over VSOCK) fills a genuine gap. Ready to approve and move to implementation.\n- (2) Explore more — There's another solution category or specific tool I want investigated before committing.\n\n**A:** \"Explore more\"\n\n#### URE Q23: What to Explore\n**Q:** \"What area or tool would you like me to investigate further?\"\n- (1) Riptides deeper — Check if the kernel module could work in our microVM, or if their tokenex/SPIFFE approach is worth adopting without the kernel module.\n- (2) eBPF-based approach — Could we use eBPF (like Cilium, Falco, or custom) for transparent credential injection instead of a userspace proxy? Kernel-level but open source.\n- (3) Secretless Broker fork — Could we fork Secretless Broker and add HTTPS MITM + response sanitization + VSOCK rather than building from scratch?\n- (4) WASM/plugin proxy — Investigate proxy architectures with plugin systems (WASM, Go plugins) for extensibility — e.g., could we build something others could extend?\n(Multi-select)\n\n**A:** \"eBPF-based approach, Well, I think that we don't need a SINGLE tool that does both inbound and outbound secrets management and scrubbing. Couldn't we just have a gateway that delegates its inbound requests to the best-fitting inbound tool, and then outbound requests to the best-fitting outbound tool\"\n\n#### URE Q24: Architecture Decision\n**Q:** \"The composable gateway pattern is a better architecture than the original monolithic proxy. Do you want me to update the plan with this architecture, or dig into anything else?\"\n- (1) Update plan — Adopt composable gateway architecture. Single Go binary with CONNECT-based routing: outbound (goproxy + credential injection) and inbound (pluggable auth handler). Finalize plan.\n- (2) eBPF defense-in-depth — Also add an eBPF enforcement layer spec to the plan — guest-side eBPF program that blocks all outbound traffic except to proxy port.\n- (3) More research — There's something else I want explored before updating the plan.\n(Multi-select)\n\n**A:** \"Update plan, How is Pomerium versus Oathkeeper versus the other tools we've explored? It seems like our application will have 5 components: (1) the secret vault whose access MUST require authentication via (2) Keycloak auth from an OIDC JWT that then MUST be checked for (3) authorization application protocol that determines what secrets the authenticated identity can access and for what domain/protocol/purpose, who receives requests from a (4) inbound handler, and then sends out to a (5) outbound handler?\"\n\n#### URE Q25: Agent Authentication\n**Q:** \"For agent-to-proxy authentication, VSOCK CID gives implicit identity (the hypervisor assigns it, can't be spoofed from inside the VM). Is CID-based identity sufficient for MVP, or do you want full Keycloak OIDC JWT authentication from the agent through the proxy?\"\n- (1) VSOCK CID for MVP (Recommended) — CID is hypervisor-enforced, can't be spoofed. Each VM has a unique CID. Sufficient for single-agent or known-agent scenarios. Add OIDC later if multi-agent with different trust levels.\n- (2) Full OIDC from start — Agent authenticates to Keycloak, gets JWT, presents it in proxy-auth header. More complex but supports multi-agent with fine-grained identity from day 1.\n- (3) Both — CID + OIDC — Use CID for transport-level identity (which VM), OIDC for application-level identity (which agent/role). Defense in depth.\n\n**A:** \"Both — CID + OIDC\"\n\n#### URE Q26: OIDC Revision (Free-form)\n**Q:** (Unprompted user correction following Q25)\n\n**A:** \"Wait actually nevermind, we should only require the Keycloak OIDC JWT\"\n\n---\n\n### Derived Requirements Summary\n\n| Requirement | Decision | Source |\n|------------|----------|--------|\n| Language | Go | Q5, Q6 |\n| Orchestration | Temporal from day 1 (temporal-cli dev server) | Q1, Q8 |\n| Credential pattern | Placeholder substitution (opaque UUIDs: `agent-vault-\u003cuuid\u003e`) | Q3, Q7 |\n| Proxy mode | HTTP forward proxy (goproxy + MITM TLS) | Q14 |\n| Transport | VSOCK (physically isolated) | Q17 |\n| Provisioning | Env vars + fw_cfg config | Q9 |\n| Deployment | Systemd service on host | Q2 |\n| Guest client | Shell wrapper (socat+curl) | Q4 |\n| Domain binding | Fail-closed enforcement | Q3 |\n| Response sanitization | Essential — scrub credentials from responses | Q3, Q20 |\n| Authentication | Keycloak OIDC JWT only (not CID) | Q25, Q26 |\n| Authorization | OPA embedded (Rego policies) | Q24 |\n| Architecture | 5-component composable gateway (single Go binary) | Q23, Q24 |\n| Build vs buy | Custom proxy (no existing solution fits) | Q11, Q12, Q19, Q20, Q21, Q22, Q23 |\n| Self-hostable | Required | Q16, Q21 |\n| Existing solutions | \"Agent-native / MCP projects are generally terrible. Look for pre-existing and established solutions.\" | Q11 |","notes":"Reopened: URD must remain open until user performs UAT. Was closed without user review.","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T01:20:11.995480103-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T15:04:25.130753308-08:00","labels":["aura:user:elicit"],"dependencies":[{"issue_id":"nix-openclaw-vm-whp","depends_on_id":"nix-openclaw-vm-35e","type":"blocks","created_at":"2026-02-17T09:03:09.451283908-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-wj1","title":"MVP: End-to-end credential proxy demo","description":"## Goal\n\nBridge the gap from \"all tests pass\" to \"boot VM, make a proxied request, observe credential injection + response scrubbing + audit trail.\"\n\n## Current State (What Works)\n\n- ✅ Go code compiles and passes 56 tests with `-race`\n- ✅ Nix evaluates (`nix flake check` passes)\n- ✅ NixOS modules fully defined (host + guest, VSOCK, Temporal, CA init)\n- ✅ test-vm boots in dev mode (without credential proxy services)\n- ✅ OIDC JWT validation (Keycloak integration)\n- ✅ OPA authorization with Rego policies\n- ✅ OpenBao vault client (KV v2)\n- ✅ Placeholder substitution + response scrubbing\n- ✅ Guest-side scripts (credproxy-auth.sh, credproxy-request.sh)\n- ✅ fw_cfg env var provisioning\n- ✅ Type safety (ast-grep rules, strongly-typed enums)\n- ✅ TLA+ formal model\n\n## Gap Analysis (What's Missing)\n\n| Component | Status | Blocker |\n|-----------|--------|---------|\n| Keycloak service | Wrapper in keycloak.nix, standalone module NOT imported | Need nixpkgs or nix-openclaw module |\n| OpenBao service | Wrapper in openbao.nix, standalone module NOT imported | Need nixpkgs or nix-openclaw module |\n| Test-VM credential config | Not defined | Need sample `credentialProxy.credentials` in flake.nix |\n| Sample vault secrets | Not provisioned | Need `secret/data/openclaw/credentials/*` entries |\n| End-to-end smoke test | No automated test | Need script: boot → auth → request → verify |\n| Demo walkthrough | No documentation | Need runbook for manual verification |\n\n## Actionable Items (Ordered)\n\n1. **Import or mock Keycloak** — Either import the nixpkgs keycloak module and enable it in test-vm, or create a minimal mock HTTP service on :8080 that returns valid OIDC discovery + tokens\n2. **Import or mock OpenBao** — Either import the nixpkgs openbao/vault module and enable it in test-vm, or create a minimal mock HTTP service on :8200 that returns KV v2 secrets\n3. **Define sample credentials in test-vm** — Add `credentialProxy.credentials` to flake.nix test-vm config with at least one demo credential (e.g., httpbin.org with a test API key)\n4. **Provision sample vault secrets** — Script or activation service that populates OpenBao with demo secrets matching the credential config\n5. **Enable credential proxy in test-vm** — Set `credentialProxy.enable = true` and verify `nix flake check` still passes\n6. **Boot and smoke test** — `nix build .#test-vm \u0026\u0026 ./result/bin/microvm-run`, then from guest: `credproxy-auth \u0026\u0026 credproxy-request GET https://httpbin.org/headers`\n7. **Document demo walkthrough** — Runbook with exact commands for reviewers to reproduce\n\n## Decision: Mock vs Real Services\n\nFor a fast MVP demo, mocking Keycloak + OpenBao is likely faster:\n- Mock Keycloak: static JWKS endpoint + token endpoint returning a valid JWT\n- Mock OpenBao: static KV v2 response with a test API key\n- This lets us validate the proxy pipeline without provisioning real infrastructure\n\nReal services can follow as a second phase.\n\n## Acceptance Criteria\n\n- [ ] `nix build .#test-vm` succeeds with credential proxy enabled\n- [ ] VM boots and credential proxy service starts (systemctl status credproxy)\n- [ ] Guest can authenticate (credproxy-auth returns JWT)\n- [ ] Guest request through proxy injects credentials (credproxy-request to httpbin.org shows injected header)\n- [ ] Response scrubbing removes credentials from response body\n- [ ] Temporal audit trail shows the request workflow","status":"open","priority":1,"issue_type":"epic","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T15:20:18.734271428-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T15:20:18.734271428-08:00","dependencies":[{"issue_id":"nix-openclaw-vm-wj1","depends_on_id":"nix-openclaw-vm-7xk","type":"blocks","created_at":"2026-02-17T15:20:25.306998536-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-wj1","depends_on_id":"nix-openclaw-vm-opa","type":"blocks","created_at":"2026-02-17T15:21:41.717660446-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-wj1","depends_on_id":"nix-openclaw-vm-8y4","type":"blocks","created_at":"2026-02-17T15:21:41.745378361-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-wj1","depends_on_id":"nix-openclaw-vm-71r","type":"blocks","created_at":"2026-02-17T15:21:41.773398797-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-wj1","depends_on_id":"nix-openclaw-vm-lvm","type":"blocks","created_at":"2026-02-17T15:21:41.801478405-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-wj1","depends_on_id":"nix-openclaw-vm-7xk","type":"relates-to","created_at":"2026-02-17T15:21:50.167361954-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-wj1","depends_on_id":"nix-openclaw-vm-coe","type":"blocks","created_at":"2026-02-17T15:45:17.661812725-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-wzj","title":"Study goproxy (elazarl) handler patterns","description":"Study elazarl/goproxy for handler/condition chaining, MITM TLS patterns, and request/response modification. Key areas: how conditions compose (DstHostIs, ReqHostIs), how HandleConnect/OnRequest/OnResponse pipeline works, custom CA configuration, UserData passing between handlers. Improve our handlers.go patterns.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:05.218348814-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.749287207-08:00","closed_at":"2026-02-17T08:16:09.749287207-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-xno","title":"Create TLA+/PlusCal state machine model for proxy concurrency protocol","description":"Model the goproxy ↔ Temporal ↔ RequestRegistry concurrency protocol in TLA+/PlusCal. The state space is small (~3 actors, ~5-8 states each) so the model checker runs in seconds.\n\nActors to model:\n1. GoproxyHandler — register context, start workflow, block on DecisionCh, forward, scrub, signal\n2. ProxyRequestWorkflow — ValidateIdentity, EvaluatePolicy, FetchAndInject, wait signal, finalize\n3. FetchAndInjectActivity — registry lookup, vault fetch, modify request, signal DecisionCh\n\nShared state:\n- RequestRegistry (entries: created/accessed/deleted)\n- DecisionCh (empty/signaled/closed)\n- response_complete signal (pending/delivered)\n\nInvariants to verify:\n- NoDeadlock: no reachable state where all actors are blocked\n- SecretsNeverInHistory: credential values never appear in workflow I/O\n- EveryRequestGetsResponse: every registered request eventually gets a decision (allow or deny)\n- RegistryEventuallyEmpty: all registry entries are eventually cleaned up\n- NoDoubleInjection: FetchAndInject runs at most once per request\n\nExpected spec size: ~80-120 lines PlusCal. Model checker runtime: seconds.\nFile: credential-proxy/model/proxy_protocol.tla\n\nThis model would have caught the DecisionCh deadlock bug found by reviewer-correctness.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T11:44:05.197790038-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:11.3314521-08:00","closed_at":"2026-02-17T14:37:11.3314521-08:00","close_reason":"Implemented by wave 2 workers"}
{"id":"nix-openclaw-vm-zyg","title":"Move JWT validation from Temporal activity to goproxy OnRequest","description":"Both reviewer-elegance and reviewer-correctness flagged this. Currently ValidateIdentity is a regular Temporal activity, which means:\n1. Raw JWT flows through Temporal event history (bearer token replayable until expiry)\n2. Workflows start for unauthenticated requests (wasted Temporal load)\n3. Extra activity adds latency\n\nFix: Validate JWT in goproxy OnRequest before starting the workflow. Pass only IdentityClaims (sub, roles, groups) as workflow input instead of RawJWT. go-oidc caches JWKS so network failure is rare; if Keycloak is down the whole system is down anyway.\n\nThis eliminates ValidateIdentity activity entirely. Workflow input becomes:\n{ requestID, identityClaims, placeholders, targetDomain }\n\nFiles: credential-proxy/proxy/handlers.go, credential-proxy/workflows/proxy_workflow.go, credential-proxy/workflows/activities.go","status":"closed","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T11:44:24.085553296-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T14:37:11.291318886-08:00","closed_at":"2026-02-17T14:37:11.291318886-08:00","close_reason":"Implemented by wave 2 workers"}
