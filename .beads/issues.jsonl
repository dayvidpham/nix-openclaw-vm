{"id":"nix-openclaw-vm-14h","title":"Fix OPA identity.roles path mismatch with Keycloak JWT","description":"Rego policy checks input.identity.roles but Keycloak JWTs have roles at realm_access.roles. handlers.go passes RawClaims (which has Keycloak structure), but Rego expects top-level roles. Tests mask this by constructing identity with top-level roles key. Will deny all requests in production. Fix: either transform RawClaims before passing to OPA (inject Roles from AgentIdentity), or update Rego to read input.identity.realm_access.roles.","status":"open","priority":1,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:02.246414471-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:28:02.246414471-08:00"}
{"id":"nix-openclaw-vm-1l8","title":"Bundle Rego policies into Nix package via postInstall","description":"BLOCKING: authz/policies/credential_access.rego not copied into $out/share/policies by buildGoModule. default.nix expects policies at credproxy-pkg/share/policies. Proxy fails at startup because NewOPAEvaluator gets nonexistent directory.","status":"open","priority":0,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:27:58.119270764-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:27:58.119270764-08:00"}
{"id":"nix-openclaw-vm-2vh","title":"IMPL REVIEW: Credential proxy implementation plan review","description":"# Implementation Plan Review — Tracking Issue\n\nThree independent reviews of the credential-proxy implementation plan (nix-openclaw-vm-7xk) were conducted against three axes:\n\n1. **Correctness** (spirit and technicality to proposal/URD)\n2. **Test quality** (integration coverage, mock discipline, fixtures)\n3. **Elegance and complexity matching** (interface completeness, over/under-engineering)\n\n## Combined Top Findings\n\n| # | Finding | Source | Severity |\n|---|---------|--------|----------|\n| 1 | `vendorHash = null` breaks Nix build | Correctness | Blocking |\n| 2 | Rego policies not bundled in Nix package | Correctness | Blocking |\n| 3 | OPA `roles` path mismatch with Keycloak JWT | Correctness | Likely bug |\n| 4 | `ProxyRequestWorkflow` + `FetchAndForward` are dead code (~600 LOC) | Correctness + Elegance | Significant |\n| 5 | No body size limits — OOM risk | Elegance | High |\n| 6 | Compressed responses bypass scrubbing | Elegance | High |\n| 7 | No vault health check at startup | Elegance | Moderate |\n| 8 | No workflow tests (testsuite.TestWorkflowEnvironment) | Tests | High |\n| 9 | No HTTPS CONNECT integration test | Tests | High |\n| 10 | Mock types duplicated across packages | Tests | Medium |\n| 11 | Phase 5 network lockdown not implemented | Correctness | Security gap |\n| 12 | fw_cfg provisioning not implemented (should source env vars) | Correctness | Missing feature |\n| 13 | No VM testing patterns documented in README/AGENTS | All | Documentation gap |\n\n## Disposition\n\nThis tracking issue is blocked by the three individual review issues, which are in turn blocked by leaf fix tasks.","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:26:44.947132466-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:26:44.947132466-08:00","dependencies":[{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-sil","type":"blocks","created_at":"2026-02-17T09:27:31.124990582-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-na4","type":"blocks","created_at":"2026-02-17T09:27:44.01765733-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-2vh","depends_on_id":"nix-openclaw-vm-g5f","type":"blocks","created_at":"2026-02-17T09:28:01.671987373-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-34h","title":"Study OpenBao KV v2 API and policy model for credential proxy","description":"Study OpenBao (Vault-compatible) to understand how credential-proxy will store and retrieve secrets. Focus areas: KV v2 secret engine (data envelope structure), policy language (path-based ACLs for read-only proxy access), AppRole auth method for service authentication, token renewal/revocation, secret versioning, and NixOS module integration (openbao service, policy provisioning).","notes":"Research completed. Report written to docs/research/openbao.Rmd. Key findings: KV v2 data.data envelope confirmed working; typed KVv2 API available for upgrade; AppRole auth with periodic tokens recommended for production; LifetimeWatcher provides automatic renewal with backoff; audit logs HMAC-hash all secret values; Transit engine available for future caching; NixOS policy module already provisions credproxy-readonly; OpenBao API endpoints identical to Vault.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:16:28.277963018-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:29:13.334172774-08:00","closed_at":"2026-02-17T08:29:13.334172774-08:00","close_reason":"Research completed, reports written to docs/research/"}
{"id":"nix-openclaw-vm-35e","title":"PROPOSAL: Credential proxy implementation plan","description":"# Credential Proxy Security Layer — Implementation Plan\n\n**Beads**: `nix-openclaw-vm-7xk` (epic), `nix-openclaw-vm-et5` (request), `nix-openclaw-vm-whp` (URE)\n\n---\n\n## Research Findings\n\n### Existing Solutions Evaluated\n\n| Solution | What It Does | Domain Binding | VSOCK | Verdict |\n|----------|-------------|----------------|-------|---------|\n| [Vultrino](https://github.com/zachyking/vultrino) | Rust credential proxy for AI agents. Alias-based refs, MCP server, WASM plugins. 6 stars, Jan 2026. | No (glob scoping only) | No | **Design reference only**. Too immature, Rust (rejected), no domain binding. |\n| [Agent Gateway](https://github.com/agentgateway/agentgateway) | Rust MCP/A2A gateway. Linux Foundation. RBAC, JWT, header manipulation. | No | No | **Wrong purpose**. Inbound agent-to-tool routing, NOT outbound credential injection. |\n| [elazarl/goproxy](https://github.com/elazarl/goproxy) | Go HTTP proxy library. MITM HTTPS, per-host handlers, request/response modification. 6.6k stars, BSD-3, 10+ years. | N/A (library) | Yes (custom `net.Listener`) | **Foundation library**. Implements `http.Handler` — serves on any listener including VSOCK. |\n| Envoy + ext_authz | C++ L7 proxy (CNCF). ext_authz calls external service for auth + header injection. In nixpkgs. | Header-only (ext_authz can't modify bodies) | No (TCP/Unix only) | **Wrong tool.** ext_authz injects headers but cannot modify request/response bodies. MITM HTTPS is experimental (no cert generation). No VSOCK. Would still need custom Go for body substitution, response scrubbing, Temporal, OpenBao — making Envoy pure overhead (3 moving parts instead of 1). |\n| Vault/OpenBao Agent | Proxies requests TO vault, not outbound. | N/A | No | **Backend only**. Use OpenBao for secret storage. |\n| [Secretless Broker](https://github.com/cyberark/secretless-broker) | Go HTTP forward proxy by CyberArk. Injects credentials from Vault/Conjur into outbound HTTP. Plugin arch (Providers + Connectors). Apache 2.0, 366 stars, v1.7.32 Feb 2026, maintained since 2018. 25+ pre-built API configs. | URL regex matching, per-connector-port | No (tcp/unix only) | **Closest existing solution but 3 blockers**: (1) Rejects CONNECT with 405 — cannot MITM HTTPS; (2) No response sanitization — \"app never sees secrets\" model conflicts with our need to scrub credentials from API responses; (3) No VSOCK or Temporal. |\n| [Octelium](https://github.com/octelium/octelium) | Go zero-trust access platform. L7-aware \"secretless access\" — injects API keys, Bearer, OAuth2, Sigv4 per-upstream. CEL/OPA policy-as-code. 3.4k stars, AGPLv3. | Per-service routing + CEL policies | No | **Too heavyweight + AGPLv3**. Full platform (VPN, ZTNA, PaaS, MCP gateway). No response sanitization documented. No VSOCK. |\n| [Envoy credential_injector](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/credential_injector_filter) | Native Envoy filter. Injects credentials from SDS into outbound requests. First-class in Envoy Gateway v1.4+. | Via routing rules / HTTPRouteFilter | No | **Kubernetes-centric, heavyweight**. Requires full Envoy. No response sanitization. |\n| [Ory Oathkeeper](https://www.ory.com/docs/oathkeeper) | Go zero-trust proxy. Per-domain access rules, header/JWT injection, CNCF ecosystem. | Per-rule domain matching | No | **Inbound-focused**. Designed for authenticating users TO your services, not injecting creds into outbound API calls. |\n| [Peta Core](https://github.com/dunialabs/peta-core) | TypeScript MCP gateway. Server-side vault with JIT decryption (30s TTL), short-lived agent tokens, HITL approvals. 28 stars, ELv2. | No | No | **TypeScript (not Go), ELv2 license**. Custom vault (not OpenBao). No domain binding. Design reference for JIT decryption + audit patterns. |\n| [Riptides](https://riptides.io/) | **Proprietary** kernel module for on-the-wire credential injection. kTLS + SPIFFE identity. Go userspace agent for OPA policy evaluation. Intercepts outbound IP sockets before TLS. | Per-process SPIFFE scoping | No (IP sockets only, not AF_VSOCK) | **Proprietary, no VSOCK, no response sanitization.** Core kernel module is closed-source. Plans to open-source \"the core\" but hasn't. Uses Lima VMs (TAP networking) — likely incompatible with VSOCK-only microVMs. No response scrubbing. No Temporal. Design reference for on-the-wire injection timing + SPIFFE identity. |\n| [Boundary](https://developer.hashicorp.com/boundary) (HashiCorp) | Credential brokering + injection for SSH, RDP, databases. Controller+Worker model. BSL 1.1. | Per-target | No | **3 blockers**: (1) BSL license (not truly OSS since 2023); (2) Credential injection is **Enterprise/HCP-only** — community edition only has brokering; (3) HTTP API injection is [not implemented](https://github.com/hashicorp/boundary/issues/5273) — only SSH, RDP, DB targets supported. |\n| [Pomerium](https://www.pomerium.com/) | Zero-trust access proxy. JWT injection + Vault integration. Apache 2.0. | Per-route | No | **Inbound-focused + JWT only.** Authenticates users TO apps. Can inject JWTs but not arbitrary API keys/headers into outbound requests. |\n| [Teleport](https://goteleport.com/) | Secure access platform. REST API access with JWT injection. Elastic v2/AGPL. | Per-app | No | **Restrictive license + JWT only.** Elastic v2 is not OSS. Same JWT-only limitation as Pomerium. |\n\n**Conclusion**: No existing solution provides our required combination (VSOCK + MITM HTTPS + placeholder substitution + response sanitization + domain binding + Temporal audit). CyberArk Secretless Broker was closest but has fundamental conflicts with response sanitization (its \"app never sees secrets\" model means it can't scrub credentials from API responses). Build custom Go proxy using [goproxy](https://github.com/elazarl/goproxy) as the HTTP proxy foundation and [mdlayher/vsock](https://github.com/mdlayher/vsock) as the transport. Borrow design patterns from Secretless (Vault provider, connector configs) and Peta (JIT decryption, audit trail) without taking the dependencies.\n\n### Go Libraries\n\n| Library | Component | Purpose | Status |\n|---------|-----------|---------|--------|\n| [`elazarl/goproxy`](https://github.com/elazarl/goproxy) | (4)(5) Gateway | HTTP/HTTPS forward proxy with MITM | 6.6k stars, BSD-3, 10+ years |\n| [`mdlayher/vsock`](https://github.com/mdlayher/vsock) | (4) Transport | AF_VSOCK `net.Listener` | v1 stable, updated Jan 2025 |\n| [`coreos/go-oidc/v3`](https://github.com/coreos/go-oidc) | (2) Authentication | Keycloak JWT validation via JWKS | Industry standard |\n| [`open-policy-agent/opa/rego`](https://pkg.go.dev/github.com/open-policy-agent/opa/rego) | (3) Authorization | Rego policy evaluation (embedded) | CNCF graduated, \u003c10ms P99 |\n| [`openbao/openbao/api/v2`](https://pkg.go.dev/github.com/openbao/openbao/api) | (1) Secret vault | OpenBao client (Vault API compat) | Official, maintained |\n| [`temporalio/sdk-go`](https://go.temporal.io/sdk) | (5) Audit | Temporal workflows + activities | Tier 1, v1.29+, production-grade |\n| `temporal-cli` | Infrastructure | Temporal dev server | [In nixpkgs](https://www.nixhub.io/packages/temporal-cli) |\n\n### Auth/Authz Tool Evaluation\n\nPomerium, Ory Oathkeeper, and OPA were evaluated for components (2) and (3):\n\n| Tool | Keycloak OIDC | Embeddable | Forward proxy (CONNECT) | Authz model | Verdict |\n|------|--------------|------------|------------------------|-------------|---------|\n| **Pomerium** | Native (redirect flow) | **No** — standalone only | Partial (needs pomerium-cli) | PPL (YAML) + Rego | **Too heavy**. Can't embed, requires separate process. |\n| **Oathkeeper** | JWT validation | **Yes** (gRPC middleware) | **No** | Rules + remote authorizer | **No CONNECT**. Good mutators but wrong proxy mode. |\n| **OPA (embedded)** | JWT decode in Rego | **Yes** (library) | N/A (policy engine) | Rego (very flexible) | **Winner for (3).** \u003c10ms, embeddable, expressive. |\n| **coreos/go-oidc** | JWKS validation | **Yes** (library) | N/A | N/A | **Winner for (2).** Simple, 5 lines of code. |\n\n**Decision:** Use `coreos/go-oidc` for JWT validation + `OPA embedded` for authorization policy. Skip Pomerium and Oathkeeper — they don't handle CONNECT, and their auth can be done more simply with direct libraries.\n\n### Language Elimination\n\n| Language | Temporal SDK | Vault Client | OIDC | VSOCK | Verdict |\n|----------|-------------|-------------|------|-------|---------|\n| **Go** | Tier 1 | First-party | Excellent | `mdlayher/vsock` | **Winner** |\n| Rust | Alpha | Community | Good | Available | User rejected; Temporal experimental |\n| Gleam/Elixir | **None** | Poor | Fair | **None** | Eliminated |\n| Zig | **None** | **None** | **None** | Syscall | Eliminated |\n\n---\n\n## Context\n\nThe openclaw-vm gives an AI agent a sandboxed microVM with VSOCK-only host communication. Currently, the agent needs API credentials passed in directly (via fw_cfg), meaning a compromised agent could exfiltrate secrets. This plan builds a **transparent forward proxy** on the host that:\n\n- Listens on **VSOCK** (hypervisor-level socket — physically cannot reach the internet, no IP routing)\n- Acts as a standard HTTP forward proxy — agent just sets `HTTP_PROXY` / `HTTPS_PROXY` env vars\n- **Intercepts HTTPS** via MITM TLS with a custom CA cert installed in the VM\n- Detects **opaque placeholder strings** (`agent-vault-\u003cuuid\u003e`) in request headers/body\n- **Replaces placeholders with real credentials** fetched from OpenBao\n- Enforces **domain binding** (credential X only works for domain Y, fail-closed)\n- **Scrubs credentials from responses** (replaces real values back with placeholders)\n- Records every credential access as a **Temporal workflow** for audit/replay\n\n**Why VSOCK?** Unlike TAP networking (which relies on nftables rules that could be misconfigured), VSOCK is a direct guest↔host channel provided by the hypervisor. Traffic on VSOCK physically cannot be routed to the internet — it's not an IP socket. This provides defense-in-depth: even if firewall rules are wrong, credentials can only flow through the proxy.\n\n---\n\n## Key Decisions\n\n| Decision | Choice | Rationale |\n|----------|--------|-----------|\n| Language | **Go** | First-party Vault client, tier-1 Temporal SDK, goproxy library, VSOCK support |\n| Architecture | **Composable 5-component gateway** | Separation of concerns: auth, authz, vault, inbound, outbound. Single Go binary. |\n| Proxy foundation | **goproxy, not Secretless Broker** | Secretless rejects CONNECT (405) — no MITM HTTPS. goproxy handles MITM natively. |\n| Authentication | **Keycloak OIDC JWT via `coreos/go-oidc`** | Agent presents JWT in `Proxy-Authorization` header. Proxy validates against Keycloak JWKS. Pomerium/Oathkeeper evaluated but too heavy (can't embed, wrong proxy mode). |\n| Authorization | **OPA embedded (Rego policies)** | Evaluates \"identity X with role Y can use credential Z for domain D\". \u003c10ms P99, embeddable library. |\n| Proxy mode | **Transparent forward proxy** (goproxy) | Agent sets `HTTP_PROXY` env var. Zero agent code changes. |\n| HTTPS handling | **MITM with custom CA** | goproxy's `ConnectMitm` action. CA cert installed in VM at build time. |\n| Credential pattern | **Placeholder substitution** | `agent-vault-\u003cuuid\u003e` strings in headers/body. Proxy replaces outbound, scrubs inbound. |\n| Orchestration | **Temporal from day 1** | Each proxied request = workflow. Audit trail, replay, retries, rate limiting. |\n| Provisioning | **Env vars + fw_cfg** | `ANTHROPIC_API_KEY=agent-vault-abc123` + JSON config listing all placeholders. |\n| Deployment | **Systemd service** on host | Direct VSOCK access, systemd hardening. |\n| Temporal hosting | **temporal-cli dev server** | In nixpkgs. SQLite-backed. Upgrade to PostgreSQL later. |\n| Domain enforcement | **OPA policy + goproxy `DstHostIs()`** | OPA for fine-grained authz, goproxy for fail-closed domain allowlist. |\n\n---\n\n## Architecture (5-Component Composable Gateway)\n\n```\nGuest VM (zero external network)                Host (NixOS)\n┌──────────────────────────────┐    VSOCK     ┌─────────────────────────────────────┐\n│ Agent                        │  CID:4       │ credproxy (Single Go Binary)         │\n│  HTTP_PROXY=localhost:18790  │  port:18790  │                                      │\n│  HTTPS_PROXY=localhost:18790 │ ──────────▶  │  (4) INBOUND HANDLER (goproxy)         │\n│                              │              │     Accept CONNECT, extract JWT       │\n│ Keycloak JWT in              │              │          ↓                            │\n│  Proxy-Authorization header  │              │  (2) AUTHENTICATION (coreos/go-oidc)   │\n│                              │              │     Validate JWT via Keycloak JWKS    │\n│ Makes normal HTTP(S) calls:  │              │          ↓                            │\n│  curl -H \"x-api-key:         │              │  (3) AUTHORIZATION (OPA embedded)      │\n│   agent-vault-abc123\"        │              │     Rego: identity→credential→domain  │\n│   https://api.anthropic.com  │              │          ↓                            │\n│                              │  ◀────────── │  (1) SECRET VAULT (OpenBao client)     │\n│ socat VSOCK↔localhost bridge │   response   │     Fetch real credential values      │\n│ CA cert: /etc/ssl/credproxy  │  (sanitized) │          ↓                            │\n└──────────────────────────────┘              │  (5) OUTBOUND HANDLER (goproxy)        │\n                                              │     MITM TLS → inject creds →        │\n                                              │     forward → scrub response →       │\n                                              │     Temporal audit                    │\n                                              └──────┬──────┬──────────┬─────────────┘\n                                                     │      │          │\n                                                ┌────▼──┐┌──▼───┐┌───▼──────────┐\n                                                │OpenBao││Keyclk││ Temporal     │\n                                                │  (1)    ││  (2)   ││ dev server   │\n                                                └───────┘└──────┘└──────────────┘\n```\n\n---\n\n## Request Flow (Composable Gateway)\n\n```\n1. Agent authenticates to Keycloak, receives JWT.\n   Agent makes normal HTTPS request with JWT:\n     curl -H \"x-api-key: agent-vault-abc123\" \\\n          -H \"Proxy-Authorization: Bearer \u003cjwt\u003e\" \\\n          https://api.anthropic.com/v1/messages\n\n2. curl respects HTTP_PROXY=http://localhost:18790\n   → Sends CONNECT api.anthropic.com:443 to proxy (with Proxy-Authorization header)\n\n3. socat in VM bridges localhost:18790 → VSOCK CID:4 port:18790 → Host\n\n4. (4) INBOUND HANDLER — goproxy receives CONNECT request:\n   a. Extract Proxy-Authorization JWT from CONNECT request headers\n   b. Is api.anthropic.com in domain allowlist?\n      NO  → ConnectReject (403 Domain Not Allowed)\n\n5. (2) AUTHENTICATION — coreos/go-oidc validates JWT:\n   a. Fetch Keycloak JWKS (cached) from well-known endpoint\n   b. Verify JWT signature, issuer, audience, expiry\n   c. Extract claims: { sub, roles, groups, ... }\n   INVALID → 407 Proxy Authentication Required\n\n6. ConnectMitm (MITM intercept with custom CA). goproxy decrypts the request.\n\n7. goproxy runs OnRequest handlers:\n   a. Extract placeholders from headers + body (regex: agent-vault-[a-f0-9-]{36})\n   b. (3) AUTHORIZATION — OPA policy evaluation:\n      Input:  { identity: jwt.claims, placeholders: [...], target_domain: req.Host }\n      Policy: \"Allow if identity.roles contains required role\n               AND each credential is bound to target_domain\"\n      DENY → 403 Forbidden (with reason)\n   c. Start Temporal workflow: ProxyRequest\n\n8. (1) SECRET VAULT + (5) OUTBOUND HANDLER:\n   Temporal Activity: FetchAndForward (sealed — secrets never in event history)\n   - Fetch real credentials from OpenBao: credPath → \"sk-ant-xxx\"\n   - Replace placeholders with real values in request headers/body\n   - goproxy forwards modified request to api.anthropic.com\n   - Receive response\n\n9. goproxy runs OnResponse handlers:\n   a. Scan response body for real credential values\n   b. Replace any found values with their placeholder strings\n   c. Return sanitized response through MITM TLS → VSOCK → Agent\n\n10. Temporal workflow records: agentID (from JWT sub), targetDomain,\n    credentialRefHash, latency, status, OPA decision\n```\n\n---\n\n## goproxy Integration Details\n\n### Handler Registration\n\n```go\nproxy := goproxy.NewProxyHttpServer()\n\n// 1. Domain allowlist — reject unknown hosts\nproxy.OnRequest().HandleConnect(goproxy.FuncHttpsHandler(\n    func(host string, ctx *goproxy.ProxyCtx) (*goproxy.ConnectAction, string) {\n        domain := extractHost(host) // strip port\n        if !config.IsAllowedDomain(domain) {\n            return goproxy.RejectConnect, host\n        }\n        return \u0026goproxy.ConnectAction{\n            Action:    goproxy.ConnectMitm,\n            TLSConfig: goproxy.TLSConfigFromCA(\u0026caCert),\n        }, host\n    }))\n\n// 2. Placeholder substitution on request\nproxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n    placeholders := placeholder.Extract(req)\n    if len(placeholders) == 0 {\n        return req, nil // No placeholders, pass through\n    }\n\n    // Validate domain binding\n    for _, ph := range placeholders {\n        if ph.BoundDomain != req.URL.Hostname() {\n            return req, goproxy.NewResponse(req, goproxy.ContentTypeText,\n                http.StatusForbidden, \"Domain mismatch: credential not bound to this host\")\n        }\n    }\n\n    // Start Temporal workflow (synchronous — blocks until complete)\n    result := temporal.ExecuteProxyWorkflow(ctx, req, placeholders)\n    if result.Error != nil {\n        return req, goproxy.NewResponse(req, goproxy.ContentTypeText,\n            http.StatusBadGateway, result.Error.Error())\n    }\n\n    // Store result for response handler\n    ctx.UserData = result\n    return result.ModifiedRequest, nil\n})\n\n// 3. Credential scrubbing on response\nproxy.OnResponse().DoFunc(func(resp *http.Response, ctx *goproxy.ProxyCtx) *http.Response {\n    result := ctx.UserData.(*ProxyResult)\n    return sanitizer.ScrubCredentials(resp, result.Credentials)\n})\n\n// Serve on VSOCK listener\nvsockListener, _ := vsock.Listen(vsock.Host, 18790, nil)\nhttp.Serve(vsockListener, proxy)\n```\n\n### Custom CA Certificate\n\nGenerated at NixOS build time:\n```nix\n# In modules/credential-proxy/default.nix\npkgs.runCommand \"credproxy-ca\" { buildInputs = [ pkgs.openssl ]; } ''\n  openssl req -x509 -newkey ec -pkeyopt ec_paramgen_curve:prime256v1 \\\n    -keyout $out/ca.key -out $out/ca.crt -days 3650 -nodes \\\n    -subj '/CN=Credential Proxy CA/O=openclaw-vm'\n''\n```\n\nInstalled in guest VM:\n```nix\n# In guest.nix\nsecurity.pki.certificateFiles = [ \"${credproxyCa}/ca.crt\" ];\n```\n\n---\n\n## File Structure\n\n### Go Service: `credential-proxy/`\n\n```\ncredential-proxy/\n├── go.mod\n├── go.sum\n├── main.go                        # Entry: VSOCK listener, goproxy setup, Temporal worker\n├── config/\n│   └── config.go                  # Config types, YAML loading, domain allowlist\n├── auth/\n│   └── oidc.go                    # (2) Keycloak JWT validation (coreos/go-oidc wrapper)\n├── authz/\n│   ├── engine.go                  # (3) OPA embedded policy evaluator\n│   └── policies/\n│       └── credential_access.rego # Rego policy: identity → credential → domain\n├── proxy/\n│   ├── gateway.go                 # (4) Composable gateway router (CONNECT → outbound)\n│   ├── handlers.go                # (5) goproxy OnRequest/OnResponse handlers\n│   ├── placeholder.go             # Placeholder extraction + substitution (regex)\n│   └── sanitizer.go               # Response credential scrubbing\n├── vault/\n│   └── client.go                  # (1) OpenBao client wrapper (DI-friendly interface)\n├── workflows/\n│   ├── proxy_workflow.go          # ProxyRequest Temporal workflow\n│   └── activities.go              # FetchAndForward sealed activity\n└── audit/\n    └── search_attributes.go       # Temporal search attribute definitions\n```\n\n### NixOS Modules: `modules/credential-proxy/`\n\n```\nmodules/credential-proxy/\n├── default.nix                    # Host: proxy service + Temporal + CA generation\n├── guest.nix                      # Guest: VSOCK bridge, CA cert, HTTP_PROXY env\n└── openbao-policy.nix             # OpenBao read-only policy for proxy\n```\n\n### Modifications to Existing Files\n\n| File | Change |\n|------|--------|\n| `flake.nix` | Add `credential-proxy` Go package (`buildGoModule`), module imports, test-vm config |\n| `modules/openclaw-vm/default.nix` | Add `credentialProxy` option group, VSOCK port 18790, CA cert fw_cfg |\n| `modules/openclaw-vm/guest.nix` | VSOCK bridge for port 18790, `HTTP_PROXY`/`HTTPS_PROXY` env vars, CA cert install |\n\n---\n\n## Temporal Workflow Design\n\n### ProxyRequest Workflow\n\n```\nInput:  { agentID, requestID, targetDomain, method, path, placeholderHashes[] }\nOutput: { status: \"success\"|\"denied\"|\"error\", latencyMs, bytesTransferred }\n\nSearch attributes: AgentID, TargetDomain, CredentialRefHash, Timestamp, Status\n```\n\n### Activities\n\n1. **ValidateAndResolve** (local activity — deterministic, no retries)\n   - Input: request metadata + placeholder list\n   - Validates domain binding for all placeholders\n   - Returns: credential paths (NOT values) + validation result\n   - Safe for event history (no secrets)\n\n2. **FetchAndForward** (sealed activity — secrets stay inside)\n   - Input: original request + credential paths\n   - Fetches real credentials from OpenBao (inside activity)\n   - Replaces placeholders in request\n   - Makes HTTPS request to target\n   - Scrubs credentials from response\n   - Returns: sanitized response\n   - Retries: 3x exponential backoff for transient failures\n   - Timeout: 30s start-to-close\n   - **CRITICAL**: Secret values never appear in Temporal event history\n\n### Secrets Safety\n\nThe `FetchAndForward` activity is \"sealed\" — all credential handling (fetch, inject, forward, scrub) happens within a single activity. The activity input is credential *paths* (safe), and the output is a sanitized response (safe). Real credential values exist only in memory during activity execution.\n\n---\n\n## OpenBao Credential Schema\n\n```\nPath: secret/data/openclaw/credentials/\u003calias\u003e\nData: {\n  \"type\": \"api_key\" | \"bearer\" | \"basic_auth\" | \"header\",\n  \"key\": \"sk-ant-...\",\n  \"domain\": \"api.anthropic.com\",\n  \"header_name\": \"x-api-key\",\n  \"header_prefix\": \"\",\n  \"placeholder\": \"agent-vault-\u003cuuid\u003e\"\n}\n```\n\n---\n\n## Guest VM Configuration\n\n### What changes in the VM:\n\n1. **socat VSOCK bridge** (new systemd service):\n   ```\n   socat TCP-LISTEN:18790,fork,reuseaddr VSOCK-CONNECT:2:18790\n   ```\n\n2. **HTTP proxy env vars** (for all users + services):\n   ```\n   HTTP_PROXY=http://localhost:18790\n   HTTPS_PROXY=http://localhost:18790\n   NO_PROXY=localhost,127.0.0.1,10.88.0.1\n   ```\n\n3. **CA certificate** installed system-wide:\n   ```nix\n   security.pki.certificateFiles = [ credproxyCaCert ];\n   ```\n\n4. **Placeholder env vars** (per credential):\n   ```\n   ANTHROPIC_API_KEY=agent-vault-a1b2c3d4-...\n   GITHUB_TOKEN=agent-vault-e5f6a7b8-...\n   ```\n\n5. **Placeholder config** via fw_cfg (JSON listing available credentials with aliases + domains)\n\n---\n\n## Implementation Phases\n\n### Phase 1: Types, Config, Auth, Authz (no external service deps)\n- `credential-proxy/config/config.go` — Config types, YAML loading, domain allowlist\n- `credential-proxy/auth/oidc.go` — (2) Keycloak JWT validation wrapper (coreos/go-oidc)\n- `credential-proxy/authz/engine.go` — (3) OPA embedded policy evaluator\n- `credential-proxy/authz/policies/credential_access.rego` — Authorization policy\n- `credential-proxy/proxy/placeholder.go` — Placeholder regex extraction + substitution\n- `credential-proxy/proxy/sanitizer.go` — Response credential scrubbing\n\n### Phase 2: Tests (import production code paths)\n- `credential-proxy/auth/oidc_test.go` — JWT validation (valid, expired, wrong issuer)\n- `credential-proxy/authz/engine_test.go` — OPA policy (allow, deny, domain mismatch)\n- `credential-proxy/proxy/placeholder_test.go` — Placeholder detection in headers, body, URLs\n- `credential-proxy/proxy/sanitizer_test.go` — Credential scrubbing from JSON/HTML/text responses\n- `credential-proxy/workflows/activities_test.go` — Activity logic with mocked OpenBao\n\n### Phase 3: Implementation (make tests pass)\n- `credential-proxy/vault/client.go` — (1) OpenBao client with DI interface\n- `credential-proxy/proxy/gateway.go` — (4) Composable gateway router\n- `credential-proxy/proxy/handlers.go` — (5) goproxy OnRequest/OnResponse/HandleConnect\n- `credential-proxy/workflows/proxy_workflow.go` — ProxyRequest Temporal workflow\n- `credential-proxy/workflows/activities.go` — FetchAndForward sealed activity\n- `credential-proxy/main.go` — VSOCK listener, goproxy setup, Temporal worker\n\n### Phase 4: NixOS Integration\n- `modules/credential-proxy/default.nix` — Host module (proxy + Temporal + CA gen)\n- `modules/credential-proxy/guest.nix` — Guest module (VSOCK bridge, CA cert, env vars)\n- `modules/credential-proxy/openbao-policy.nix` — Read-only policy\n- `flake.nix` — `buildGoModule` package, module imports, test-vm config\n- `modules/openclaw-vm/default.nix` — Wire in credentialProxy options, VSOCK port 18790\n- `modules/openclaw-vm/guest.nix` — HTTP_PROXY/HTTPS_PROXY, CA cert, placeholder env vars\n\n### Phase 5: VM Network Lockdown\n- Extend nftables in `modules/openclaw-vm/default.nix` — block all external network when proxy enabled\n- Only VSOCK communication allowed\n\n---\n\n## Verification\n\n1. **Nix evaluation**: `nix flake check --no-build` passes\n2. **Module evaluation**: `nix eval .#nixosConfigurations.test-vm.config.system.build.toplevel --apply 'x: \"ok\"'` → `\"ok\"`\n3. **Go build**: `nix build .#credential-proxy` succeeds\n4. **Go tests**: `cd credential-proxy \u0026\u0026 go test ./...` — all pass\n5. **Placeholder detection**: Unit tests verify extraction from HTTP headers, JSON body, URL query params\n6. **Sanitization**: Unit tests verify credential values scrubbed from responses (JSON, HTML, plaintext)\n7. **Domain binding**: Unit tests verify mismatch → denied (fail-closed), match → allowed\n8. **MITM TLS**: Integration test with custom CA cert — proxy decrypts HTTPS, injects credentials\n9. **Temporal workflow**: Integration test with `go.temporal.io/sdk/testsuite` — workflow completes, search attributes recorded\n10. **Forward proxy**: Integration test — `curl -x http://proxy:18790 https://httpbin.org/get` works with placeholder substitution\n11. **Network lockdown**: Agent cannot reach external network without proxy (no DNS, no TCP out)\n\n---\n\n## Existing Code to Reuse\n\n| Pattern | Source | Reuse |\n|---------|--------|-------|\n| VSOCK socat bridge | `modules/openclaw-vm/guest.nix:466-488` (vsock-gateway-proxy) | Same pattern for credproxy VSOCK bridge |\n| fw_cfg credential injection | `modules/openclaw-vm/default.nix:397-440` (sops.templates + fw_cfg) | Same pattern for placeholder config |\n| systemd hardening | `modules/openclaw-vm/guest.nix:293-370` (openclaw-gateway service) | Copy hardening directives for proxy service |\n| nftables VM isolation | `modules/openclaw-vm/default.nix:190-260` (nftables rules) | Extend for full network lockdown |\n| OpenBao policy gen | `modules/openclaw/openbao.nix:42-70` (per-instance policies) | Same pattern for proxy read-only policy |\n| CA cert install | NixOS `security.pki.certificateFiles` | Standard NixOS pattern for custom CAs |","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T03:25:45.699759213-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T03:25:45.699759213-08:00","labels":["aura:plan:proposal"],"dependencies":[{"issue_id":"nix-openclaw-vm-35e","depends_on_id":"nix-openclaw-vm-7xk","type":"blocks","created_at":"2026-02-17T09:03:10.06512248-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-3xk","title":"Study Temporal Go SDK patterns for workflow/activity design","description":"Deep-dive into the Temporal Go SDK (go.temporal.io/sdk) to understand idiomatic patterns. Focus areas: workflow.Context vs context.Context, UpsertTypedSearchAttributes API, activity options (StartToClose, HeartbeatTimeout, RetryPolicy), local activities vs regular activities, workflow.ExecuteActivity patterns, client.ExecuteWorkflow (sync vs async), testsuite for unit testing workflows, and worker.New configuration options.","notes":"Research completed. Report written to docs/research/temporal-go-sdk.Rmd. Key findings: (1) ValidateAndResolve is a strong candidate for local activity, (2) authz denials should use temporal.NewNonRetryableApplicationError, (3) audit workflow ID should be deterministic for dedup, (4) search attribute keys should be package-level vars with KeyKeyword for Status, (5) comprehensive testsuite patterns documented for workflow+activity unit tests, (6) worker Options should set OnFatalError and MaxConcurrentActivityExecutionSize.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:16:35.471521466-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:29:13.342998937-08:00","closed_at":"2026-02-17T08:29:13.342998937-08:00","close_reason":"Research completed, reports written to docs/research/"}
{"id":"nix-openclaw-vm-52l","title":"Fix vendorHash in flake.nix for credential-proxy build","description":"BLOCKING: vendorHash = null in credential-proxy/flake.nix with no vendor/ directory. Nix build fails. Either compute vendorHash or run go mod vendor.","status":"open","priority":0,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:27:55.122552653-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:27:55.122552653-08:00"}
{"id":"nix-openclaw-vm-5hx","title":"Consolidate test mock types into internal/testutil package","description":"mockEvaluator and mockStore are defined identically in proxy/gateway_test.go and workflows/activities_test.go. Create credential-proxy/internal/testutil/ with shared MockVerifier, MockEvaluator, MockStore, common TestConfig(), and shared placeholder/secret constants.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:28.696183439-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:28:28.696183439-08:00"}
{"id":"nix-openclaw-vm-5x1","title":"Study Peta Core JIT decryption and audit patterns","description":"Study dunialabs/peta-core for JIT decryption with short TTL, short-lived agent tokens, HITL approval workflows, and audit trail patterns. Key areas: how they implement time-limited credential access, approval workflows, audit logging. Compare with our Temporal audit and OpenBao vault fetch patterns.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:17.043745691-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.771506858-08:00","closed_at":"2026-02-17T08:16:09.771506858-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-6h5","title":"Study Ory Oathkeeper pipeline/mutator architecture","description":"Study ory/oathkeeper for pipeline architecture (authenticators, authorizers, mutators), per-domain access rules, and header/JWT injection patterns. Key areas: how rules match requests to handler pipelines, mutator design for credential injection, error handling pipeline. Improve our handler pipeline design.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:10.512257422-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.75830895-08:00","closed_at":"2026-02-17T08:16:09.75830895-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-7xk","title":"CREDENTIAL-PROXY: Implement credential proxy security layer for openclaw-vm","description":"## Goal\nImplement a credential proxy security layer for the openclaw microVM where:\n- Agent inside VM has zero external network access\n- All auth-required requests delegated to trusted proxy service on host via VSOCK\n- Credentials stored in OpenBao with domain binding enforcement\n- Proxy injects auth headers — agent never sees API keys\n- Full audit trail of all credential access\n\n## Architecture\nHost (NixOS)\n├── OpenBao (secrets store)\n│   └── Credentials with domain binding metadata\n├── Credential Proxy Service (NEW)\n│   ├── Listens on VSOCK\n│   ├── Validates ACP protocol requests\n│   ├── Fetches credential from OpenBao + verifies domain binding\n│   ├── Injects auth headers into outbound HTTPS request\n│   ├── Templates response\n│   └── Audit logs everything\n└── openclaw-vm (microVM)\n    └── Agent (zero network — all via VSOCK → proxy)\n\n## Phases\n1. Protocol \u0026 Types (ACP subset)\n2. Credential Proxy Service (Rust)\n3. NixOS Integration\n4. Guest-Side Client\n5. VM Network Lockdown","status":"in_progress","priority":1,"issue_type":"feature","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T01:12:10.551998339-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T03:11:22.940438395-08:00","dependencies":[{"issue_id":"nix-openclaw-vm-7xk","depends_on_id":"nix-openclaw-vm-2vh","type":"blocks","created_at":"2026-02-17T09:26:50.29507789-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-8a1","title":"Rename auth package to authn for conventional authn/authz naming","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:01:15.791463993-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:05:22.497274393-08:00","closed_at":"2026-02-17T08:05:22.497274393-08:00","close_reason":"Renamed auth→authn, all tests pass"}
{"id":"nix-openclaw-vm-bhw","title":"Study Secretless Broker (CyberArk) patterns","description":"Study cyberark/secretless-broker for provider/connector architecture, Vault integration patterns, and per-connector-port domain scoping. Key areas: how providers abstract secret backends, how connectors define per-service credential injection, their plugin architecture. Compare with our vault.SecretStore and config.Credential patterns.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:02.42095771-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.744828709-08:00","closed_at":"2026-02-17T08:16:09.744828709-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-c5x","title":"Add HTTPS CONNECT integration test for TLS MITM path","description":"Current gateway_test.go only exercises plain HTTP proxying. The production-critical path (CONNECT -\u003e MITM TLS -\u003e credential injection -\u003e response scrubbing) has no automated test. Add test using httptest.NewTLSServer as upstream with client going through CONNECT tunnel.","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:26.594716208-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:28:26.594716208-08:00"}
{"id":"nix-openclaw-vm-cgg","title":"Implement fw_cfg provisioning for credential placeholder config","description":"URD Q9: user chose both env vars AND fw_cfg. Currently only env vars implemented. fw_cfg should provide a JSON config listing available placeholders with aliases and domains. Guest-side: env vars should be populated FROM the fw_cfg JSON at boot time, making fw_cfg the single source of truth.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:31.808775836-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:28:31.808775836-08:00"}
{"id":"nix-openclaw-vm-d6c","title":"Study Octelium secretless access patterns","description":"Study octelium/octelium for zero-trust secretless access architecture, CEL/OPA policy-as-code integration, per-service routing with credential injection (API keys, Bearer, OAuth2, Sigv4). Key areas: how they abstract different auth schemes, policy evaluation pipeline, service routing model. Compare with our authz and credential injection approach.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:08.072643257-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.753484442-08:00","closed_at":"2026-02-17T08:16:09.753484442-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-dwl","title":"Document VM testing patterns in README.md and AGENTS.md","description":"No documentation on how to test the VM or credential-proxy. Should cover: nix flake check, Go unit/integration tests (go test ./...), the dev/test workflow from flake.nix, and how to run VM boot tests. Add to both README.md (for external users) and AGENTS.md (for agent contributors).","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:35.023627318-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:28:35.023627318-08:00"}
{"id":"nix-openclaw-vm-et5","title":"REQUEST: Credential proxy security layer for openclaw-vm","description":"Verbatim User Request: Implement a credential proxy security layer for the openclaw microVM where the agent inside the VM has zero external network access, all auth-required requests are delegated to a trusted proxy service on the host via VSOCK, credentials are stored in OpenBao with domain binding enforcement, the proxy injects auth headers (agent never sees API keys), and full audit trail of all credential access. User Clarifications: Does NOT want Rust. Prefers Zig, Gleam/Elixir, or Golang. Does NOT want to re-implement secret-to-domain mapping or the proxy itself if avoidable. Interested in Temporal for backend orchestration (audit trail, event sourcing, event-driven architecture). Wants to evaluate existing solutions before building from scratch. Source Document: ~/dotfiles/docs/agent-sandbox.md","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T01:20:06.451275233-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T01:20:06.451275233-08:00","labels":["aura:user:request"],"dependencies":[{"issue_id":"nix-openclaw-vm-et5","depends_on_id":"nix-openclaw-vm-whp","type":"blocks","created_at":"2026-02-17T09:02:19.142299287-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-ffs","title":"Refactor to Temporal-orchestrated full lifecycle (replace dead ProxyRequestWorkflow)","description":"Replace the current inline handler + dead ProxyRequestWorkflow + fire-and-forget AuditWorkflow with a single ProxyRequestWorkflow that orchestrates the full request lifecycle via activities and signals.\n\nChanges:\n1. New ProxyRequestWorkflow with ValidateIdentity → EvaluatePolicy → FetchAndInject → wait signal\n2. New RequestRegistry (sync.Map) bridging goproxy ↔ Temporal local activities  \n3. FetchAndInject local activity: vault fetch + request modification via RequestRegistry\n4. OnResponse signals workflow with response_complete (scrub count, status)\n5. Remove dead FetchAndForward activity and AuditWorkflow\n6. Update Gateway struct: add RequestRegistry, remove direct authn/authz deps\n7. Update main.go: register new workflow + activities, wire registry","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:05.811714738-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:55:10.308627081-08:00"}
{"id":"nix-openclaw-vm-g5f","title":"REVIEW 3: Elegance and complexity matching","description":"# Review 3: Elegance and Complexity Matching\n\nReviewed credential-proxy for interface completeness, over/under-engineering, and complexity proportionality.\n\n## Component Inventory (1,581 prod LOC, 1,542 test LOC, 475 Nix LOC)\n- config/ (193 LOC) — YAML parsing, validation, indexed lookups — MATCHED\n- authn/ (123 LOC) — Keycloak JWT validation — MATCHED\n- authz/ (235 LOC) — OPA embedded + Rego policy — MATCHED\n- vault/ (95 LOC) — OpenBao KV v2 wrapper — SLIGHTLY INCOMPLETE (no health check)\n- proxy/ (483 LOC) — Gateway, handlers, placeholder, sanitizer — MATCHED\n- workflows/ (303 LOC) — Temporal workflows + activities — OVER (dead code)\n- audit/ (50 LOC) — Search attribute definitions — MATCHED\n\n## Interface Audit — All Complete\n- authn.Verifier: Single-method VerifyToken — complete for forward-proxy authn\n- authz.Evaluator: Single-method Evaluate — complete for binary gate authorization\n- vault.SecretStore: FetchCredential — slightly incomplete (missing HealthCheck)\n- config.Config: LookupCredential, IsAllowedDomain — complete\n- proxy.Gateway: NewGateway + http.Handler — complete and well-designed\n\n## Over-Engineering\n1. ProxyRequestWorkflow + FetchAndForward are dead code (~600 LOC production + test)\n2. FetchAndForward rebuilds HTTP request from scratch, discarding headers/body/query — would be buggy if invoked\n3. CredentialType enum exists but has no behavioral dispatch (MINOR — acceptable as documentation)\n\n## Under-Engineering\n1. HIGH: No body size limits in Extract() and ScrubCredentials() — OOM risk via io.ReadAll on unbounded bodies\n2. HIGH: Compressed responses bypass scrubbing (Content-Encoding: gzip not handled)\n3. MODERATE: No vault health check at startup — confusing error at request time\n4. MODERATE: Vault token is static string only — no AppRole/renewal (acceptable for MVP)\n5. MINOR: No rate limiting (acceptable for MVP)\n6. MINOR: Temporal audit failure silently logged, no metrics\n7. MODERATE: Response scrubbing only handles exact string matching (no base64/URL-encoded variants)\n\n## Complexity Scorecard\n8 packages matching 5 architectural components + config + audit + main = PROPORTIONAL\nNo God objects, no micro-packages. Package structure aligns with architecture.\nOnly deviation: unused Temporal workflow code inflates audit component.","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:27:57.517420745-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:27:57.517420745-08:00","dependencies":[{"issue_id":"nix-openclaw-vm-g5f","depends_on_id":"nix-openclaw-vm-oxd","type":"blocks","created_at":"2026-02-17T09:31:01.821585968-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-g5f","depends_on_id":"nix-openclaw-vm-hm3","type":"blocks","created_at":"2026-02-17T09:31:02.719929063-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-g5f","depends_on_id":"nix-openclaw-vm-r42","type":"blocks","created_at":"2026-02-17T09:31:03.573957959-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-g5f","depends_on_id":"nix-openclaw-vm-dwl","type":"blocks","created_at":"2026-02-17T09:31:04.561992567-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-hm3","title":"Handle compressed responses in credential scrubbing","description":"If upstream sends Content-Encoding: gzip, ScrubCredentials scrubs compressed bytes — credential strings won't match and will pass through unscrubbed. Fix: set Accept-Encoding: identity on outbound requests (via goproxy OnRequest handler) to prevent compressed responses needing scrubbing. ~5 lines.","status":"open","priority":1,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:14.00283115-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:28:14.00283115-08:00"}
{"id":"nix-openclaw-vm-irv","title":"Study Keycloak OIDC integration patterns for credential proxy","description":"Study Keycloak's OIDC/OAuth2 implementation to understand how credential-proxy will integrate. Focus areas: realm configuration, client credential grants, service account setup, JWKS endpoint, realm_access.roles claim structure, token exchange flows, and how to configure a realm for agent authentication. Understand the admin REST API for programmatic setup in NixOS modules.","notes":"Research completed. Report written to docs/research/keycloak.Rmd. Key findings: (1) Realms provide full tenant isolation with independent keys/users/roles -- ideal for per-VM agent isolation. (2) client_credentials flow is correct for service accounts; credproxy-auth.sh implementation is sound. (3) realm_access.roles extraction in oidc.go is correct but groups claim requires explicit GroupMembershipMapper. (4) Audience must be configured via AudienceProtocolMapper for aud verification to pass. (5) NixOS has services.keycloak module with realmFiles for declarative realm import. (6) Token exchange (RFC 8693) is not needed for current architecture. (7) resource_access extraction should be added for per-client role scoping.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:16:24.60270627-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:29:13.329894396-08:00","closed_at":"2026-02-17T08:29:13.329894396-08:00","close_reason":"Research completed, reports written to docs/research/"}
{"id":"nix-openclaw-vm-lm1","title":"Study OSS patterns from proposal research to improve credential-proxy","description":"Clone and study OSS projects from the proposal's research findings. Extract design patterns, interfaces, and security practices to improve our credential-proxy. Key repos: secretless-broker (provider/connector pattern), goproxy (handler patterns), octelium (policy-as-code), oathkeeper (mutators/rules), peta-core (JIT decryption), vultrino (alias-based refs).","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:08:36.05937192-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:29:23.125244408-08:00","closed_at":"2026-02-17T08:29:23.125244408-08:00","close_reason":"All 11 OSS and infrastructure study sub-tickets completed, research reports written to docs/research/","dependencies":[{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-bhw","type":"blocks","created_at":"2026-02-17T08:12:31.707974452-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-wzj","type":"blocks","created_at":"2026-02-17T08:12:31.73764208-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-d6c","type":"blocks","created_at":"2026-02-17T08:12:31.765293887-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-6h5","type":"blocks","created_at":"2026-02-17T08:12:31.792940754-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-mot","type":"blocks","created_at":"2026-02-17T08:12:31.820664366-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-m6g","type":"blocks","created_at":"2026-02-17T08:12:31.846791547-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-5x1","type":"blocks","created_at":"2026-02-17T08:12:31.875463608-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-irv","type":"blocks","created_at":"2026-02-17T08:16:48.984245578-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-34h","type":"blocks","created_at":"2026-02-17T08:16:49.011310115-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-qfp","type":"blocks","created_at":"2026-02-17T08:16:49.036977639-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-lm1","depends_on_id":"nix-openclaw-vm-3xk","type":"blocks","created_at":"2026-02-17T08:16:49.063674323-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-m6g","title":"Study Agent Gateway RBAC and header patterns","description":"Study agentgateway/agentgateway for RBAC model, JWT-based auth, header manipulation patterns, and MCP/A2A gateway architecture. Key areas: how they compose auth middleware, header injection/removal, per-route policies. Compare with our authn/authz pipeline.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:14.685122906-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.767206429-08:00","closed_at":"2026-02-17T08:16:09.767206429-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-mot","title":"Study Vultrino alias-based credential references","description":"Study zachyking/vultrino for alias-based credential references, MCP server integration, and WASM plugin architecture. Key areas: how aliases map to credentials, plugin extensibility model, client-side integration patterns. Compare with our placeholder UUID approach.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:12.410460005-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.76286416-08:00","closed_at":"2026-02-17T08:16:09.76286416-08:00","close_reason":"Study completed with detailed analysis reports"}
{"id":"nix-openclaw-vm-na4","title":"REVIEW 2: Test quality and coverage","description":"# Review 2: Test Quality and Coverage\n\nReviewed all test files in credential-proxy/ for mock discipline, fixture usage, integration coverage, and brittleness.\n\n## Strengths\n- SUT is never mocked — all tests exercise real production code\n- Gateway integration tests (gateway_test.go) are genuinely end-to-end through full goproxy handler chain\n- OPA tests use real policy evaluation, loading actual .rego from disk\n- Package-level constants for shared placeholder/secret values\n- Test-to-production ratio: 0.98:1\n\n## Mock Analysis — All Correct\n- proxy/placeholder_test.go, proxy/sanitizer_test.go: No mocks needed (pure functions)\n- authz/engine_test.go: Real OPAEvaluator with real Rego policy, no mocks\n- authn/oidc_test.go: Real helper functions, no mocks (OIDCVerifier.VerifyToken not tested — reasonable, requires live Keycloak)\n- workflows/activities_test.go: Real Activities methods, mocks only for dependencies (vault, OPA)\n- proxy/gateway_test.go: Real Gateway with real goproxy MITM, mocks only for dependencies (authn, authz, vault, Temporal)\n\n## Integration Coverage Gaps\n1. No Temporal workflow tests — ProxyRequestWorkflow and AuditWorkflow have zero coverage\n2. No HTTPS CONNECT integration test — production-critical TLS MITM path untested\n3. No config/config_test.go — validation edge cases untested\n4. No vault/client_test.go — KV v2 response parsing untested\n5. No test for connTokens cleanup in handleResponse (memory leak regression)\n6. No audit/search_attributes_test.go (low priority — trivial logic)\n\n## Fixture Analysis\n- Within-package: well-centralized (package-level consts, helper functions)\n- Cross-package: mock types duplicated (mockEvaluator, mockStore in both gateway_test.go and activities_test.go)\n- Config: two separate testConfig() helpers with different inline YAML\n\n## Brittleness Hotspots\n- String-based error assertions in activities_test.go and gateway_test.go\n- Should use typed Temporal errors (temporal.NewNonRetryableApplicationError) for type-based assertions","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:27:40.067869746-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:27:40.067869746-08:00","dependencies":[{"issue_id":"nix-openclaw-vm-na4","depends_on_id":"nix-openclaw-vm-o29","type":"blocks","created_at":"2026-02-17T09:30:59.103186909-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-na4","depends_on_id":"nix-openclaw-vm-c5x","type":"blocks","created_at":"2026-02-17T09:30:59.909297197-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-na4","depends_on_id":"nix-openclaw-vm-5hx","type":"blocks","created_at":"2026-02-17T09:31:00.879349748-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-o29","title":"Add ProxyRequestWorkflow tests with testsuite.TestWorkflowEnvironment","description":"Test the new ProxyRequestWorkflow that orchestrates the full lifecycle:\n\n1. Happy path: authn → authz → fetch+inject → response signal → completion\n2. Auth failure: ValidateIdentity fails → workflow returns denied, no further activities\n3. Authz denial: EvaluatePolicy denies → workflow returns denied, no FetchAndInject\n4. Inject failure: FetchAndInject fails (vault error) → workflow returns error\n5. Signal timeout: workflow times out waiting for response_complete signal (60s)\n6. Search attributes: verify all attributes set at each phase\n\nUse testsuite.TestWorkflowEnvironment with mock activities. RequestRegistry integration tests should use a real registry + local activities.","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:19.528257288-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:55:19.273139807-08:00"}
{"id":"nix-openclaw-vm-oxd","title":"Add body size limits to Extract() and ScrubCredentials()","description":"Both Extract() and ScrubCredentials() call io.ReadAll() on unbounded request/response bodies. Malicious agent or large API response could OOM the proxy. Add configurable MaxBodySize (e.g., 10MB default) to Config and use io.LimitReader. ~20 lines of change.","status":"open","priority":1,"issue_type":"bug","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:11.369189131-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:28:11.369189131-08:00"}
{"id":"nix-openclaw-vm-pci","title":"Research: Temporal usage in proxy/agent orchestration (awesome-temporal)","description":"Search awesome-temporal and broader ecosystem for projects using Temporal in domains similar to ours: credential proxies, agent orchestration, security pipelines, access control. Write research report to docs/research/. Update AGENTS.md design references table.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:37:37.502360244-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:42:22.150237513-08:00","closed_at":"2026-02-17T09:42:22.150237513-08:00","close_reason":"Research report written to docs/research/temporal-agent-orchestration.Rmd, AGENTS.md updated"}
{"id":"nix-openclaw-vm-qfp","title":"Study Temporal workflow patterns for credential proxy audit","description":"Study Temporal's architecture and Go SDK to understand how credential-proxy will use it for audit workflows. Focus areas: workflow vs activity distinction, search attributes (custom typed), event history (what gets persisted vs sealed), workflow ID design patterns, task queue architecture, retry policies, worker lifecycle, dev server (temporal-cli), and visibility/query APIs for forensic analysis.","notes":"Research completed. Report written to docs/research/temporal.Rmd. Key findings: (1) Current secret isolation design is correct - vault paths safe in event history, secrets only in activity memory. (2) All 4 custom Keyword search attributes fit within SQLite dev server limits (10 max). (3) Auth denials should use temporal.NewNonRetryableApplicationError. (4) Worker needs explicit MaxConcurrentActivityExecutionSize limits. (5) Visibility API supports SQL-like queries for forensic analysis. (6) Dev server registers search attrs via --search-attribute flags at startup. (7) Workflow IDs should consider deterministic patterns for deduplication. (8) Production needs dedicated namespace with retention policy.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:16:31.877250423-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:29:13.338721161-08:00","closed_at":"2026-02-17T08:29:13.338721161-08:00","close_reason":"Research completed, reports written to docs/research/"}
{"id":"nix-openclaw-vm-r42","title":"Add vault health check at startup","description":"NewOpenBaoClient succeeds without connecting — vault reachability issues surface as confusing 'credential resolution failed' at request time. Add a Sys().Health() or test FetchCredential call during run() after client init. ~10 lines.","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:28:16.436289477-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:28:16.436289477-08:00"}
{"id":"nix-openclaw-vm-sil","title":"REVIEW 1: Correctness to proposal/URD","description":"# Review 1: Correctness (Spirit and Technicality)\n\nReviewed the implementation plan (7xk) against the PROPOSAL (35e) and URD (whp).\n\n## Matches (17 confirmed)\n- M1: Language (Go) — matches URD Q5/Q6\n- M2: Proxy mode (goproxy forward proxy with MITM) — matches URD Q14\n- M3: Transport (VSOCK via mdlayher/vsock) — matches URD Q17\n- M4: Credential pattern (opaque UUID placeholders) — matches URD Q3/Q7\n- M5: Authentication (Keycloak OIDC JWT via coreos/go-oidc) — matches URD Q25/Q26\n- M6: Authorization (OPA embedded with Rego) — matches URD Q24\n- M7: Domain binding (fail-closed, two enforcement layers) — matches URD Q3\n- M8: Response sanitization (credential scrubbing) — matches URD Q3\n- M9: Temporal from day 1 — matches URD Q1 (but see G1)\n- M10: Deployment (systemd service on host) — matches URD Q2\n- M11: Temporal hosting (temporal-cli dev server) — matches URD Q8\n- M12: Guest client (shell wrapper) — matches URD Q4\n- M13: OpenBao client with DI interface — matches proposal\n- M14: CA cert generation at runtime (IMPROVED over proposal — private keys never in /nix/store)\n- M15: Provisioning via env vars — partial match URD Q9\n- M16: 5-component architecture in single Go binary — matches proposal\n- M17: OpenBao read-only policy — matches proposal\n- M18: MITM CA installed in guest — matches proposal\n- M19: Redirect-following disabled (enhancement beyond spec)\n\n## Gaps\n- G1: Temporal reduced to fire-and-forget audit (proposal said each request = workflow) — ProxyRequestWorkflow is dead code\n- G2: BLOCKING — Rego policies not bundled into Nix package (no postInstall step)\n- G3: fw_cfg provisioning not implemented (URD said both env vars + fw_cfg)\n- G4: Phase 5 VM network lockdown (nftables) not implemented — security gap\n- G5: Retry policy says 2 attempts, proposal said 3 (moot — dead code)\n- G6: Timestamp search attribute missing (Temporal provides implicitly)\n- G7: BLOCKING — vendorHash = null with no vendor directory breaks Nix build\n- G8: No modifications to existing openclaw-vm modules (standalone approach is arguably cleaner)\n- G9: JSONL audit logging delegated to slog + Temporal (acceptable)\n\n## Contradictions\n- C1: vsock.Listen API — implementation is correct, proposal pseudocode was wrong\n- C2: Temporal is audit-only, not request-orchestrating (see G1)\n- C3: Package naming auth/ → authn/ (cosmetic improvement)\n\n## Ambiguities (likely bugs)\n- A2: OPA identity mismatch — Rego expects input.identity.roles but Keycloak JWTs have realm_access.roles. Tests mask this by constructing identity with top-level roles key. LIKELY BUG that would deny all requests in production.\n- A5: Response sanitization does not handle compressed responses","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T09:27:26.780524876-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T09:27:26.780524876-08:00","dependencies":[{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-52l","type":"blocks","created_at":"2026-02-17T09:30:54.479671027-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-1l8","type":"blocks","created_at":"2026-02-17T09:30:55.323021688-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-14h","type":"blocks","created_at":"2026-02-17T09:30:56.314804896-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-ffs","type":"blocks","created_at":"2026-02-17T09:30:57.264632943-08:00","created_by":"David Huu Pham"},{"issue_id":"nix-openclaw-vm-sil","depends_on_id":"nix-openclaw-vm-cgg","type":"blocks","created_at":"2026-02-17T09:30:58.10160719-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-whp","title":"URE: Credential proxy scope and MVP","description":"## User Requirements Elicitation — Credential Proxy Security Layer\n\n### Session 1: Initial Requirements Interview\n\n#### URE Q1: MVP Scope\n**Q:** \"What is the MVP scope? Should Phase 1 focus on just the proxy + OpenBao domain binding, or do you also want Temporal orchestration in the MVP?\"\n- (1) Proxy + domain binding only — MVP: VSOCK listener, OpenBao credential fetch, domain binding check, header injection, JSONL audit. Add Temporal later.\n- (2) Include Temporal from start — Build on Temporal from day 1: each proxy request = workflow execution, audit trail via workflow history, event replay built-in.\n- (3) Temporal for audit only — Simple proxy handles requests directly, but logs events to Temporal for audit trail and replay. Hybrid approach.\n\n**A:** \"Include Temporal from start\"\n\n#### URE Q2: Deployment Model\n**Q:** \"For deployment: should the credential proxy run as a standalone systemd service on the host, or inside a container (Podman) like OpenBao?\"\n- (1) Systemd service (Recommended) — Native binary, systemd hardening (like the existing gateway). Simpler, less overhead, direct VSOCK access.\n- (2) Podman container — Containerized like OpenBao. More isolation but adds complexity for VSOCK passthrough.\n- (3) Decide later — Design the NixOS module to support both, decide during implementation.\n\n**A:** \"Systemd service (Recommended)\"\n\n#### URE Q3: Response Templating\n**Q:** \"How important is response templating (agent requests specific fields, proxy strips the rest) for MVP? The agent-sandbox.md spec includes it but it adds complexity.\"\n- (1) Essential for MVP — Agent should never see fields it didn't request (PII protection, minimizing attack surface).\n- (2) Defer to Phase 2 — MVP passes full response through. Add field filtering later. Domain binding is the critical security layer.\n\n**A:** \"Essential for MVP — Agent should never see fields it didn't request (PII protection, minimizing attack surface). But also, the response should NOT contain any auth / secrets. It should just contain that placeholder string. I imagine something similar to vaultwarden, where the secret has a templated form `agent-vault-\u003cuuid\u003e`, and the proxy searches for this, ingests it, replaces it on the proxy-side, and responses all replace the auth with this string when returned to the agent.\"\n\n#### URE Q4: Guest-Side Client\n**Q:** \"Should the guest-side client be a proper CLI tool, or is a simple shell wrapper (e.g., around socat/curl) sufficient for MVP?\"\n- (1) Shell wrapper (socat+curl) — Minimal: shell script that sends JSON over VSOCK via socat. Quick to build, easy to debug.\n- (2) Proper CLI tool — Compiled binary with arg parsing, error handling, structured output. More robust but more work.\n- (3) Library/SDK — Import-able library the agent's code calls directly. Most ergonomic but heaviest to build.\n\n**A:** \"Shell wrapper (socat+curl)\"\n\n#### URE Q5: Language Preference (Free-form)\n**Q:** (Prompted by initial plan proposing Rust)\n\n**A:** \"Whoa. I don't know about using Rust. Why would that be the case? I think using Zig, Gleam/Elixir, or Golang would be better. Let's consider. Which language has decent support for Keycloak and OpenBao? I also don't want to re-implement this 'secret-to-domain' allowable mapping, or even the proxy itself if I can avoid it. Let's see what exists already. I'm particularly interested in trying to use Temporal on the backend, as this will help with building the audit trail, the event sourcing, and the event-driven system for the proxy.\"\n\n#### URE Q6: Language Confirmation (after research)\n**Q:** \"Given the research, Go is the only language with production-grade support for all three key dependencies (Temporal, OpenBao, OIDC). Are you okay with Go, or do you want to explore a polyglot approach (e.g., Go for the proxy, Gleam/Elixir for something else)?\"\n- (1) Go (Recommended) — Monolingual. First-party Vault client, tier 1 Temporal SDK, excellent OIDC + VSOCK + Nix support.\n- (2) Polyglot approach — Go for the proxy core, but use another language for some component (e.g., Gleam for a future API layer).\n- (3) Need more info — I want to dig deeper into one of the alternatives before deciding.\n\n**A:** \"Go (Recommended)\"\n\n#### URE Q7: Placeholder Pattern\n**Q:** \"For the credential placeholder pattern: should placeholders be per-credential-ref (e.g., `{{vault:openclaw/api/key}}`) or opaque UUIDs (e.g., `agent-vault-a1b2c3d4`) that map to credentials via a separate config?\"\n- (1) Opaque UUIDs — Agent sees `agent-vault-\u003cuuid\u003e`. Mapping from UUID to credential ref + domain is stored in proxy config. Agent can't infer what the credential is.\n- (2) Structured refs — Agent sees `{{vault:path/to/secret}}`. More readable, agent knows what credential it's using, but leaks the secret path.\n- (3) Agent-chosen aliases — Agent uses human-readable aliases like `my-api-key`. Proxy maps alias to credential ref + domain. Flexible but requires alias management.\n\n**A:** \"Opaque UUIDs\"\n\n#### URE Q8: Temporal Deployment\n**Q:** \"For Temporal deployment on NixOS: `temporal-cli` is in nixpkgs and includes a dev server with SQLite. For production, you'd want PostgreSQL-backed. Which path for the MVP?\"\n- (1) temporal-cli dev server — Single binary, SQLite, includes web UI. Simplest. Good enough for single-host with a few VMs. Can migrate to PostgreSQL later.\n- (2) Podman container — Use official temporalio/auto-setup Docker image in Podman. More production-like but adds container dependency.\n- (3) Full PostgreSQL setup — Build a proper NixOS module for Temporal with PostgreSQL backend. Most work upfront but most production-ready.\n\n**A:** \"temporal-cli dev server\"\n\n#### URE Q9: Credential Provisioning\n**Q:** \"How should placeholder-to-credential mappings be provisioned to the agent inside the VM? The agent needs to know which placeholder string to use for which service.\"\n- (1) Environment variables — Inject placeholders as env vars (e.g., ANTHROPIC_API_KEY=agent-vault-abc123). Agent code uses them naturally.\n- (2) Config file via fw_cfg — JSON config file passed through QEMU fw_cfg (like existing openclaw-config). Lists all available placeholders and their target services.\n- (3) Query proxy at boot — Agent asks the proxy 'what credentials do I have?' over VSOCK and gets back a list of placeholder aliases and their allowed domains.\n\n**A:** \"Can do (1) and (2).\"\n\n#### URE Q10: Transport Protocol\n**Q:** \"For the VSOCK transport, should the proxy act as an HTTP forward proxy (agent sets HTTP_PROXY env var, needs MITM TLS for HTTPS) or use a simple JSON RPC (agent sends {url, method, headers, body} and proxy makes the actual request)?\"\n- (1) JSON RPC (Recommended) — Simple POST to proxy with request details as JSON. No TLS MITM needed. Clean placeholder substitution. Matches your shell wrapper preference.\n- (2) HTTP forward proxy — Standard HTTP proxy (CONNECT tunneling). More transparent but requires MITM CA cert for HTTPS inspection. Complex.\n- (3) Both modes — JSON RPC for MVP, add forward proxy mode later for agents that want transparent proxying.\n\n**A:** \"JSON RPC (Recommended)\"\n\n#### URE Q11: User Directive on Solution Research (Free-form)\n\n**A:** \"Agent-native and agentic software / MCP open-source projects are generally terrible. Look for pre-existing and established solutions that were well-accepted by the security community for our problem in a NON-agentic scenario. This is inherently a non-agentic problem.\"\n\n#### URE Q12: Build vs Wrap (Octelium)\n**Q:** \"Given the research, Octelium (Go, 3.4k stars, AGPLv3) is the closest existing solution with 'secretless access' and Go implementation. Should we evaluate integrating/wrapping Octelium, or build custom since our requirements (VSOCK, Temporal, placeholder pattern) diverge enough?\"\n- (1) Build custom (Recommended) — Our requirements (VSOCK, Temporal, placeholder pattern, domain binding) are sufficiently unique. Borrow design patterns from Octelium/Peta/Vultrino but build our own ~500 lines of Go core logic.\n- (2) Evaluate Octelium first — Clone Octelium, read its credential injection code, and assess if we can wrap/extend it. Risk: AGPLv3 license, may not be worth the effort if VSOCK+Temporal don't fit.\n- (3) Evaluate Peta Core first — Clone Peta, read its vault/injection code. Risk: TypeScript (not Go), ELv2 license, may not fit our architecture.\n- (4) Hybrid approach — Use Octelium as the access gateway layer and bolt Temporal + custom VSOCK listener on top. Most integration work but most reuse.\n\n**A:** \"Evaluate Octelium first\"\n\n#### URE Q13: Additional Research\n**Q:** \"Is there anything else you'd like me to research before finalizing the plan? The research confirmed no existing solution covers our needs, and Go + custom proxy is the path.\"\n- (1) Research is sufficient — You've seen enough. Let's finalize the plan and move to implementation.\n- (2) Dig into Vultrino source — Clone zachyking/vultrino and study its architecture in detail — borrow design patterns for our Go implementation.\n- (3) Explore goproxy more — Investigate whether elazarl/goproxy could serve as the proxy foundation (forward proxy mode instead of JSON RPC).\n- (4) Something else — I want to research a specific topic before we proceed.\n\n**A:** \"Explore goproxy more\"\n\n#### URE Q14: Proxy Mode (after goproxy research)\n**Q:** \"Given goproxy's capabilities, should we use it as a transparent forward proxy (agent just sets HTTP_PROXY and makes normal requests) or stick with JSON RPC? The forward proxy approach means zero agent code changes but requires MITM TLS with a custom CA cert installed in the VM.\"\n- (1) Forward proxy (goproxy) — Agent sets HTTP_PROXY env var, makes normal requests. goproxy does MITM TLS, placeholder substitution, domain enforcement. Requires installing custom CA cert in VM.\n- (2) JSON RPC (current plan) — Agent uses credproxy wrapper to send structured JSON. No TLS MITM needed. More explicit but requires agent to use the wrapper.\n- (3) Both modes — Build on goproxy as foundation. Support both forward proxy mode AND a /proxy JSON RPC endpoint. Agent can use whichever suits its needs.\n- (4) Need more info — I want to understand the tradeoffs better before deciding.\n\n**A:** \"Forward proxy (goproxy)\"\n\n#### URE Q15: Credential Pattern + Implementation (Rejected)\n**Q:** \"Secretless Broker uses a 'transparent proxy' pattern where the agent doesn't know about credentials AT ALL (just sets http_proxy). Your placeholder pattern (agent-vault-uuid) gives the agent explicit control over where credentials go. Which approach do you prefer?\" / \"For the proxy implementation: should we wrap/extend Secretless Broker (reuse its Vault provider, connector system, HTTP proxy), or build a custom thin proxy using the Go vault/api client directly (~500 lines)?\"\n\n**A:** (REJECTED — user wanted clarification first)\n\n#### URE Q16: Clarification Request\n**Q:** \"What would you like to clarify about the credential pattern choice (transparent proxy vs placeholder) or the implementation approach (Secretless Broker vs custom)?\"\n- (1) Explain transparent proxy more\n- (2) Explain placeholder pattern more\n- (3) Explain Secretless limitations\n- (4) I have a different idea\n(Multi-select)\n\n**A:** \"Explain transparent proxy more, Explain Secretless limitations, Can I self-host Secretless Broker? This all needs to be self-hostable\"\n\n#### URE Q17: Transport (VSOCK vs TAP)\n**Q:** \"Should the proxy listen on VSOCK (direct hypervisor channel, no IP networking) or on the TAP bridge IP (10.88.0.1:18790, reuse existing network, simpler)? The VM already has a TAP interface for host communication.\"\n- (1) TAP bridge (simpler) — Proxy listens on 10.88.0.1:18790. VM sets HTTP_PROXY=http://10.88.0.1:18790. Reuses existing TAP network. nftables restricts VM to only reach the proxy. No socat needed.\n- (2) VSOCK (more isolated) — Proxy listens on VSOCK CID:4 port:18790. Adds socat bridge in VM. Physically impossible for traffic to escape. But adds the socat bridge complexity.\n- (3) Both (belt and suspenders) — Proxy listens on both. TAP for the forward proxy (HTTP_PROXY). VSOCK as a fallback/admin channel. Maximum flexibility.\n\n**A:** \"VSOCK (more isolated)\"\n\n#### URE Q18: Secretless Broker Approach (Premature)\n**Q:** \"Given Secretless Broker's gaps (no response sanitization, no Temporal, weak domain binding, no rate limiting), which approach do you prefer?\"\n\n**A:** \"So far have been given no details on Secretless Broker, what it is\"\n\n#### URE Q19: Build vs Wrap (after Secretless explanation)\n**Q:** \"Now that you understand Secretless Broker: should we use it as the credential injection layer and build our custom features on top, or build our own proxy that borrows its patterns?\"\n- (1) Use Secretless + add layers — Run Secretless as the credential injection proxy. Build a Go middleware service in front that adds: VSOCK listener, domain binding enforcement, Temporal audit, response sanitization, rate limiting. Two processes, most code reuse.\n- (2) Custom proxy, inspired by SB — Build our own single Go binary (~500 lines core). Use vault/api directly for OpenBao. Borrow Secretless design (connector configs, provider abstraction) but own the full stack. One process, full control.\n- (3) Fork Secretless Broker — Fork the repo, add our features (VSOCK, domain binding, Temporal, response sanitization) directly into the codebase. Most reuse but we maintain a fork.\n- (4) Clone and evaluate first — Before deciding, clone the Secretless Broker repo to ~/codebases/ and read the actual Go code. Understand the architecture hands-on before committing to an approach.\n\n**A:** \"Use Secretless + add layers\"\n\n#### URE Q20: Response Sanitization Conflict\n**Q:** \"Given the response sanitization conflict with Secretless Broker, which tradeoff do you prefer?\"\n- (1) Single Go binary (current plan) — Our proxy fetches creds from OpenBao, injects into requests, AND scrubs from responses. One process, full control. Uses goproxy for HTTP proxy + mdlayher/vsock for transport. This is what the current plan file already describes.\n- (2) Secretless + skip sanitization — Use Secretless for injection. Accept that API responses may leak credentials. Rely on domain binding to limit exposure. Simpler (Secretless handles Vault), but weaker security.\n- (3) Secretless + parallel fetch — Use Secretless for injection AND separately fetch creds from OpenBao in our middleware for sanitization. Two Vault lookups per request (one by Secretless, one by us). Redundant but keeps separation.\n- (4) Clone Secretless, evaluate — Before deciding, clone the Secretless Broker repo and read how its credential provider works. Maybe we can extract the provider interface as a library.\n\n**A:** \"Single Go binary (current plan)\"\n\n### Session 2: Deeper Research and Architecture Refinement\n\n#### ExitPlanMode Rejection 1: Existing Solutions Research\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"Still need to do research about what exists, and how we can avoid re-implementing this. For example, vaultwarden exists. How is it different from OpenBao? Any other auth proxies exist that do NOT expose ANY secrets AT ALL to the clients?\"\n\n#### ExitPlanMode Rejection 2: Online Research Needed\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"Still need to do research. Still have not looked online and seen what exists.\"\n\n#### ExitPlanMode Rejection 3: VSOCK Purpose\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"Why do we even need VSOCK? What's the purpose or point of VSOCK?\"\n\n#### ExitPlanMode Rejection 4: Secretless vs goproxy\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"If we use Secretless Broker, do we need goproxy?\"\n\n#### ExitPlanMode Rejection 5: Envoy Inquiry\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"So, what about Envoy + ext_authz? What is that? What does that do? why was it deemed too heavyweight?\"\n\n### Session 3: Continued Deep Research\n\n#### ExitPlanMode Rejection 6: OpenBao vs Vaultwarden\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"This is looking very good indeed. However, does OpenBao not handle the 'secret-to-domain' mapping already? or does Vaultwarden? Why do we use OpenBao instead of Vaultwarden?\"\n\n#### ExitPlanMode Rejection 7: OpenBao Extensions\n**Q:** (ExitPlanMode — attempt to finalize plan)\n\n**A (Rejection):** \"In some sense, the agent is a human, and it essentially needs a secretless broker-style password manager for use in the CLI and developing applications. OpenBao has nice attributes though. Has there been no attempts at extending OpenBao with this application-level logic?\"\n\n#### URE Q21: Riptides + Boundary Investigation\n**Q:** \"Riptides is the closest existing solution to what you described. Want me to dig deeper into it before we finalize, or are you satisfied that the custom goproxy approach is the right path given our specific requirements (VSOCK, response sanitization, Temporal audit, NixOS)?\"\n- (1) Finalize with goproxy — The research is thorough. Custom Go proxy with goproxy + OpenBao + Temporal is the right call — nothing existing covers all our requirements.\n- (2) Investigate Riptides — Dig deeper into Riptides — licensing, source availability, how kernel-level injection works, whether it could work inside a microVM with VSOCK.\n- (3) Investigate Boundary — Dig deeper into HashiCorp Boundary's credential injection — it's the 'official' Vault ecosystem approach even if HTTP API support is pending.\n\n**A:** \"Investigate deeper into both Riptides and Boundary. Is there an open-source alternative to Boundary? Must be self-hostable. Surprised the security and privacy communities haven't developed anything here yet.\"\n\n#### URE Q22: Ready to Finalize?\n**Q:** \"The research is thorough across 17 solutions. The gap is real — no OSS tool provides outbound HTTPS credential injection + response sanitization + VSOCK + audit. Ready to finalize the custom Go proxy plan, or is there another direction you want explored?\"\n- (1) Finalize plan — Research is complete. The custom Go proxy (goproxy + OpenBao + Temporal over VSOCK) fills a genuine gap. Ready to approve and move to implementation.\n- (2) Explore more — There's another solution category or specific tool I want investigated before committing.\n\n**A:** \"Explore more\"\n\n#### URE Q23: What to Explore\n**Q:** \"What area or tool would you like me to investigate further?\"\n- (1) Riptides deeper — Check if the kernel module could work in our microVM, or if their tokenex/SPIFFE approach is worth adopting without the kernel module.\n- (2) eBPF-based approach — Could we use eBPF (like Cilium, Falco, or custom) for transparent credential injection instead of a userspace proxy? Kernel-level but open source.\n- (3) Secretless Broker fork — Could we fork Secretless Broker and add HTTPS MITM + response sanitization + VSOCK rather than building from scratch?\n- (4) WASM/plugin proxy — Investigate proxy architectures with plugin systems (WASM, Go plugins) for extensibility — e.g., could we build something others could extend?\n(Multi-select)\n\n**A:** \"eBPF-based approach, Well, I think that we don't need a SINGLE tool that does both inbound and outbound secrets management and scrubbing. Couldn't we just have a gateway that delegates its inbound requests to the best-fitting inbound tool, and then outbound requests to the best-fitting outbound tool\"\n\n#### URE Q24: Architecture Decision\n**Q:** \"The composable gateway pattern is a better architecture than the original monolithic proxy. Do you want me to update the plan with this architecture, or dig into anything else?\"\n- (1) Update plan — Adopt composable gateway architecture. Single Go binary with CONNECT-based routing: outbound (goproxy + credential injection) and inbound (pluggable auth handler). Finalize plan.\n- (2) eBPF defense-in-depth — Also add an eBPF enforcement layer spec to the plan — guest-side eBPF program that blocks all outbound traffic except to proxy port.\n- (3) More research — There's something else I want explored before updating the plan.\n(Multi-select)\n\n**A:** \"Update plan, How is Pomerium versus Oathkeeper versus the other tools we've explored? It seems like our application will have 5 components: (1) the secret vault whose access MUST require authentication via (2) Keycloak auth from an OIDC JWT that then MUST be checked for (3) authorization application protocol that determines what secrets the authenticated identity can access and for what domain/protocol/purpose, who receives requests from a (4) inbound handler, and then sends out to a (5) outbound handler?\"\n\n#### URE Q25: Agent Authentication\n**Q:** \"For agent-to-proxy authentication, VSOCK CID gives implicit identity (the hypervisor assigns it, can't be spoofed from inside the VM). Is CID-based identity sufficient for MVP, or do you want full Keycloak OIDC JWT authentication from the agent through the proxy?\"\n- (1) VSOCK CID for MVP (Recommended) — CID is hypervisor-enforced, can't be spoofed. Each VM has a unique CID. Sufficient for single-agent or known-agent scenarios. Add OIDC later if multi-agent with different trust levels.\n- (2) Full OIDC from start — Agent authenticates to Keycloak, gets JWT, presents it in proxy-auth header. More complex but supports multi-agent with fine-grained identity from day 1.\n- (3) Both — CID + OIDC — Use CID for transport-level identity (which VM), OIDC for application-level identity (which agent/role). Defense in depth.\n\n**A:** \"Both — CID + OIDC\"\n\n#### URE Q26: OIDC Revision (Free-form)\n**Q:** (Unprompted user correction following Q25)\n\n**A:** \"Wait actually nevermind, we should only require the Keycloak OIDC JWT\"\n\n---\n\n### Derived Requirements Summary\n\n| Requirement | Decision | Source |\n|------------|----------|--------|\n| Language | Go | Q5, Q6 |\n| Orchestration | Temporal from day 1 (temporal-cli dev server) | Q1, Q8 |\n| Credential pattern | Placeholder substitution (opaque UUIDs: `agent-vault-\u003cuuid\u003e`) | Q3, Q7 |\n| Proxy mode | HTTP forward proxy (goproxy + MITM TLS) | Q14 |\n| Transport | VSOCK (physically isolated) | Q17 |\n| Provisioning | Env vars + fw_cfg config | Q9 |\n| Deployment | Systemd service on host | Q2 |\n| Guest client | Shell wrapper (socat+curl) | Q4 |\n| Domain binding | Fail-closed enforcement | Q3 |\n| Response sanitization | Essential — scrub credentials from responses | Q3, Q20 |\n| Authentication | Keycloak OIDC JWT only (not CID) | Q25, Q26 |\n| Authorization | OPA embedded (Rego policies) | Q24 |\n| Architecture | 5-component composable gateway (single Go binary) | Q23, Q24 |\n| Build vs buy | Custom proxy (no existing solution fits) | Q11, Q12, Q19, Q20, Q21, Q22, Q23 |\n| Self-hostable | Required | Q16, Q21 |\n| Existing solutions | \"Agent-native / MCP projects are generally terrible. Look for pre-existing and established solutions.\" | Q11 |","notes":"\n### Session 4: Temporal Architecture Refinement\n\n#### URE Q27: Temporal Role (Free-form, user-initiated)\n**Q:** (Unprompted — user challenge to existing architecture)\n\n**A:** \"Yeah sure, the goproxy owns the actual Http information, but then Temporal should handle orchestration for TRYING TO USE THE PROXY TO BEGIN WITH shouldn't it?\"\n\n**Design impact:** Changed Temporal's role from fire-and-forget audit logger to access decision orchestrator. The inline authn → authz → vault fetch pipeline in goproxy handlers must be refactored into Temporal activities.\n\n#### URE Q28: Temporal Ecosystem Research (User directive)\n**Q:** (Unprompted — user directive)\n\n**A:** \"Yes. Should also look at the official awesome-temporal repo and find a project that uses Temporal in a similar application domain as we are aiming for. Many agent projects are also using Temporal now. Put this in the docs/research, and create a research task for this similar to others.\"\n\n**Result:** Research report written to docs/research/temporal-agent-orchestration.Rmd. Key finding: no existing project combines Temporal + forward proxy for credential injection. Patterns adopted from temporal-ai-agent (workflow-as-orchestrator), durable-mcp (external calls as durable activities), ai-iceberg-demo (Auth0/identity + Temporal).\n\n#### URE Q29: Temporal Full Lifecycle (User correction)\n**Q:** (Unprompted — user correction to updated plan)\n\n**A:** \"Temporal shouldn't just be integrated in terms of the requests. It should be integrated with the response handling, scrubbing, and secret retrieval too.\"\n\n**Design impact:** Expanded Temporal's scope from access-decision-only to full request lifecycle. New pattern: signal-based completion where workflow stays alive, goproxy signals 'response_complete' after scrubbing. Vault fetch moved into FetchAndInject local activity (secrets via RequestRegistry, never serialized to Temporal).\n\n#### URE Q30: Secrets Safety Confirmation\n**Q:** (Unprompted — user confirmation of constraint)\n\n**A:** \"This is true though: Secret values NEVER appear in Temporal event history.\"\n\n**Design impact:** Confirmed as hard requirement. FetchAndInject local activity accesses secrets through in-process RequestRegistry (sync.Map). Activity input is {requestID, placeholders}, output is {credentialCount}. No secrets in serialized I/O.\n\n---\n\n### Session 4 Derived Requirements\n\n| Requirement | Decision | Source |\n|------------|----------|--------|\n| Temporal role | Full lifecycle orchestrator (not just audit) | Q27, Q29 |\n| Temporal scope | Authn, authz, vault fetch, injection, response scrub audit | Q29 |\n| Secrets in Temporal | NEVER — hard constraint, use RequestRegistry for in-process bridging | Q30 |\n| Signal pattern | Workflow stays alive; goproxy signals response_complete | Q29 |\n| RequestRegistry | sync.Map bridging goproxy ↔ Temporal local activities | Q29 |\n| Ecosystem research | Temporal agent projects surveyed (awesome-temporal, temporal-community) | Q28 |\n","status":"open","priority":1,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T01:20:11.995480103-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T10:54:45.264175546-08:00","labels":["aura:user:elicit"],"dependencies":[{"issue_id":"nix-openclaw-vm-whp","depends_on_id":"nix-openclaw-vm-35e","type":"blocks","created_at":"2026-02-17T09:03:09.451283908-08:00","created_by":"David Huu Pham"}]}
{"id":"nix-openclaw-vm-wzj","title":"Study goproxy (elazarl) handler patterns","description":"Study elazarl/goproxy for handler/condition chaining, MITM TLS patterns, and request/response modification. Key areas: how conditions compose (DstHostIs, ReqHostIs), how HandleConnect/OnRequest/OnResponse pipeline works, custom CA configuration, UserData passing between handlers. Improve our handlers.go patterns.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-17T08:12:05.218348814-08:00","created_by":"David Huu Pham","updated_at":"2026-02-17T08:16:09.749287207-08:00","closed_at":"2026-02-17T08:16:09.749287207-08:00","close_reason":"Study completed with detailed analysis reports"}
