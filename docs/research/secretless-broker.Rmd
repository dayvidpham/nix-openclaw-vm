---
title: "CyberArk Secretless Broker - Architecture Pattern Analysis"
date: "2026-02-17"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

## Overview

This report documents findings from a thorough study of the
[CyberArk Secretless Broker](https://github.com/cyberark/secretless-broker)
codebase, conducted to identify design patterns relevant to the
**credential-proxy** project. The credential-proxy is a Go MITM forward proxy
that listens on VSOCK, intercepts HTTPS via MITM, detects placeholder strings
(`agent-vault-<uuid>`) in request headers and body, replaces them with real
credentials from OpenBao vault, enforces domain binding, scrubs credentials from
responses, and records audit via Temporal workflows.

The study examined seven architectural areas: Provider Architecture, Connector
Architecture, Handler Pipeline, Configuration Model, Error Handling, Testing
Patterns, and Security Patterns (credential zeroization). For each area, we
identify the concrete patterns found in Secretless, cite source files and line
numbers, and evaluate what to adopt, adapt, or explicitly avoid in the
credential-proxy.

All file paths reference the cloned Secretless Broker repository at
`~/codebases/cyberark/secretless-broker/` and the credential-proxy source at
`~/codebases/dayvidpham/nix-openclaw-vm/credential-proxy/`.


## Provider Architecture

### Pattern: Factory-Based Registration with Unified Interface

Secretless abstracts secret backends behind a minimal `Provider` interface,
registered via a compile-time factory map. Each backend (Vault, Conjur, AWS
Secrets Manager, environment variables, files, Kubernetes secrets, literal
values, macOS Keychain) implements the same two-method interface.

**Source files:**

- `internal/plugin/v1/provider.go` (lines 16--23): Interface definition
- `internal/providers/providers.go` (lines 17--26): Factory registration map
- `internal/providers/vault/provider.go`: HashiCorp Vault implementation

```go
// Provider interface -- minimal, single responsibility
// File: internal/plugin/v1/provider.go
type Provider interface {
    GetName() string
    GetValues(ids ...string) (map[string]ProviderResponse, error)
}

type ProviderOptions struct {
    Name string
}

// ProviderResponse wraps both value and error per credential
type ProviderResponse struct {
    Value []byte
    Error error
}
```

```go
// Factory registration -- compile-time, no runtime reflection
// File: internal/providers/providers.go
var ProviderFactories = map[string]func(plugin_v1.ProviderOptions) (plugin_v1.Provider, error){
    "aws":        awsProvider.ProviderFactory,
    "conjur":     conjurProvider.ProviderFactory,
    "env":        envProvider.ProviderFactory,
    "file":       fileProvider.ProviderFactory,
    "keychain":   keychainProvider.ProviderFactory,
    "kubernetes": kubernetesProvider.ProviderFactory,
    "literal":    literalProvider.ProviderFactory,
    "vault":      vaultProvider.ProviderFactory,
}
```

### Helper: Batch Resolution from Single-Value Providers

Most providers implement `GetValue(id string) ([]byte, error)` for a single
secret, then delegate batch resolution to a shared helper:

```go
// File: internal/plugin/v1/provider.go (lines 35--53)
func GetValues(
    p singleValueProvider,
    ids ...string,
) (map[string]ProviderResponse, error) {
    responses := map[string]ProviderResponse{}
    for _, id := range ids {
        if _, ok := responses[id]; ok {
            continue  // deduplicate
        }
        pr := ProviderResponse{}
        pr.Value, pr.Error = p.GetValue(id)
        responses[id] = pr
    }
    return responses, nil
}
```

Individual credential failures are captured _inside_ `ProviderResponse.Error`
rather than halting the batch (fail-through, not fail-fast).

### Vault Provider: ID Parsing with Field Navigation

The Vault provider parses secret IDs using `#` as a separator between the secret
path and the field path within the returned JSON object:

```go
// File: internal/providers/vault/provider.go (lines 49--57)
func parseVaultID(id string) (string, string) {
    tokens := strings.SplitN(id, "#", 2)
    switch len(tokens) {
    case 1:
        return tokens[0], DefaultField  // "value"
    default:
        return tokens[0], tokens[1]
    }
}
```

Examples: `kv/database#password` extracts the `password` field;
`secret/data/database#data.value` navigates nested objects.

### Comparison with credential-proxy

Our `vault.SecretStore` interface serves the same role:

```go
// File: credential-proxy/vault/client.go
type SecretStore interface {
    FetchCredential(ctx context.Context, vaultPath string) (*CredentialValue, error)
}
```

This is correct but narrower: it fetches one credential at a time and carries
`context.Context` (which Secretless lacks). The credential-proxy does not need
multiple backend support today, so the simpler interface is appropriate. If
multi-backend support becomes necessary, adopt the factory registration pattern.


## Connector Architecture

### Pattern: Protocol-Specific Connectors with Credential Injection

Secretless defines separate connector interfaces for HTTP and TCP protocols.
HTTP connectors receive an `*http.Request` and a `CredentialValuesByID` map,
then mutate the request to inject authentication.

**Source files:**

- `pkg/secretless/plugin/connector/http/http.go` (lines 9--38): HTTP connector interface
- `internal/plugin/connectors/http/generic/connector.go`: Generic HTTP connector
- `internal/plugin/connectors/http/generic/config.go`: Template-based config
- `internal/plugin/connectors/http/basicauth/plugin.go`: Basic auth connector

```go
// HTTP Connector interface
type Connector interface {
    Connect(
        request *http.Request,
        credentialValuesByID connector.CredentialValuesByID,
    ) error
}
```

### Generic Connector: Template-Based Header Injection

The generic HTTP connector uses Go `text/template` to render credential values
into HTTP headers, query parameters, and OAuth1 signatures:

```go
// File: internal/plugin/connectors/http/generic/config.go
type config struct {
    CredentialPatterns map[string]*regexp.Regexp
    Headers           map[string]*template.Template
    OAuth1Secrets     map[string]*template.Template
    QueryParams       map[string]*template.Template
    ForceSSL          bool
}

func (c *config) validate(credsByID connector.CredentialValuesByID) error {
    for requiredCred, pattern := range c.CredentialPatterns {
        credVal, ok := credsByID[requiredCred]
        if !ok {
            return fmt.Errorf("missing required credential: %q", requiredCred)
        }
        if !pattern.Match(credVal) {
            return fmt.Errorf(
                "credential %q doesn't match pattern %q", requiredCred, pattern,
            )
        }
    }
    return nil
}
```

### Resources Interface for Dependency Injection

Connectors receive dependencies through a `Resources` interface rather than
direct struct injection:

```go
// File: pkg/secretless/plugin/connector/resources.go
type Resources interface {
    Config() []byte
    Logger() log.Logger
}
```

### Comparison with credential-proxy

The credential-proxy uses a fundamentally different approach: instead of
per-service connector plugins, it scans the entire request for placeholder
strings and replaces them. This is simpler and appropriate for a MITM proxy.

The credential-proxy's `config.Credential` struct with explicit `placeholder`,
`type`, `vault_path`, `bound_domain`, `header_name`, and `header_prefix` fields
is superior to Secretless's template approach because:

- Each credential's destination is explicit and auditable
- Domain binding is a first-class security constraint
- No template injection surface exists


## Handler Pipeline

### Pattern: Sequential Request Processing

Secretless processes HTTP requests through a sequential pipeline without
middleware chains:

**Source file:** `internal/plugin/connectors/http/proxy_service.go` (lines 156--207)

```
ServeHTTP(ResponseWriter, *Request)
  |-- validateProxyServerRules()       // Check CONNECT, absolute URLs
  |-- selectSubservice()               // Match request URL to service
  |-- retrieveCredentials()            // Call CredentialsRetriever
  |-- connector.Connect(request, creds)  // Inject auth
  +-- handleRequest()                  // Forward to backend
      |-- Remove proxy-specific headers
      |-- transport.RoundTrip()        // Make request to backend
      +-- copyHeaders() + writeBody()  // Return response to client
```

Key details:

- Errors at any step return HTTP 500 immediately (fail-closed)
- Response body is streamed via `io.Copy` (not buffered)
- Proxy-specific headers (Hop-by-hop) are stripped before forwarding

### Credential Lifecycle in the Pipeline

The credential retrieval and zeroization happen at known points:

```go
// File: internal/plugin/connectors/http/proxy_service.go (lines 186--202)
creds, err := subservice.RetrieveCredentials()
defer internal.ZeroizeCredentials(creds)  // Clear after use

err = subservice.Connector.Connect(r, creds)
proxy.handleRequest(w, r)
```

### Comparison with credential-proxy

The credential-proxy's `GatewayHandler` follows an analogous sequential flow
with additional MITM-specific stages:

```
HandleConnect(clientConn)
  |-- TLS ClientHello intercept
  |-- Generate cert for SNI
  |-- Establish TLS with client
  |-- Extract(request)            // Find placeholders
  |-- Resolve(placeholders)       // Get credentials from vault
  |-- ReplaceInRequest()          // Inject credentials
  |-- Forward to backend
  +-- Sanitize response           // Remove credentials from response
```

The sequential approach is correct for credential injection. The credential-proxy
adds response sanitization, which Secretless does not perform.


## Configuration Model

### Pattern: Versioned YAML with Parse-Time Validation

Secretless uses a versioned YAML configuration (v1 deprecated, v2 current)
with validation performed at parse time.

**Source files:**

- `pkg/secretless/config/v2/config.go`: Top-level config
- `pkg/secretless/config/v2/service.go`: Service definition
- `pkg/secretless/config/v2/credential.go`: Credential definition

```yaml
# Secretless v2 configuration example
version: "2"
services:
  my-postgres:
    connector: pg
    listenOn: tcp://localhost:5432
    credentials:
      address:
        from: vault
        get: secret/postgres/url
      username:
        from: env
        get: PG_USER
      password:
        from: literal
        get: "hardcoded"
    config: |
      sslmode: require

  my-http-api:
    connector: generic_http
    listenOn: tcp://localhost:8080
    credentials:
      api_key:
        from: vault
        get: secret/api/key
    config:
      authenticationStrategy: bearer
      headers:
        Authorization: "Bearer {{ .api_key }}"
```

```go
// File: pkg/secretless/config/v2/service.go (lines 47--58)
type Service struct {
    Debug           bool
    Connector       string
    ConnectorConfig connectorConfig
    Credentials     []*Credential
    ListenOn        NetworkAddress
    Name            string
}

type Credential struct {
    Name string  // Local name in this service
    From string  // Provider (vault, env, etc.)
    Get  string  // ID to fetch from provider
}
```

### Comparison with credential-proxy

The credential-proxy configuration is superior in several respects:

```go
// File: credential-proxy/config/config.go
type Credential struct {
    Placeholder  string         `yaml:"placeholder"`
    Type         CredentialType `yaml:"type"`
    VaultPath    string         `yaml:"vault_path"`
    BoundDomain  string         `yaml:"bound_domain"`
    HeaderName   string         `yaml:"header_name"`
    HeaderPrefix string         `yaml:"header_prefix"`
}
```

Advantages over Secretless:

- **Domain binding** is explicit (`BoundDomain`); Secretless has no equivalent
- **Credential type** is an enum (`CredentialType`), not hidden in templates
- **Header injection** is explicit (`HeaderName`, `HeaderPrefix`), not template-rendered
- **Parse-time indexes** enable O(1) lookups: `credentialIndex map[string]*Credential` and `domainIndex map[string]bool`

Both systems validate at parse time (fail-closed at startup).


## Error Handling

### Pattern: Fail-Through Error Collection with Deterministic Output

Secretless collects errors from multiple providers and credentials without
halting on the first failure:

**Source file:** `internal/plugin/resolver.go` (lines 129--181)

```go
func (resolver *Resolver) Resolve(credentials []*config_v2.Credential) (map[string][]byte, error) {
    result := make(map[string][]byte)
    errorStrings := make([]string, 0, len(credentials))

    credentialsByProvider := groupCredentialsByProvider(credentials)

    for providerID, credentialsForProvider := range credentialsByProvider {
        provider, providerResponses, errStr := resolver.resolveForProvider(
            providerID, credentialsForProvider,
        )
        if errStr != "" {
            log.Println(errStr)
            errorStrings = append(errorStrings, errStr)
            continue  // Don't stop, keep trying other providers
        }

        for _, credential := range credentialsForProvider {
            credentialName := credential.Name
            secretValue := providerResponses[credential.Get].Value
            result[credentialName] = secretValue
        }
    }

    if len(errorStrings) > 0 {
        sort.Strings(errorStrings)  // Deterministic output
        err = fmt.Errorf(strings.Join(errorStrings, "\n"))
    }

    return result, err
}
```

### Provider-Level Error Isolation

Individual credential resolution errors are captured per-response:

```go
// File: internal/plugin/resolver.go (lines 74--125)
func (resolver *Resolver) resolveForProvider(
    providerID string,
    credentials []*config_v2.Credential,
) (plugin_v1.Provider, map[string]plugin_v1.ProviderResponse, string) {
    provider, err := resolver.Provider(providerID)
    // ...
    providerResponses, err := provider.GetValues(secretIds...)
    if err != nil {
        hasErrors = true
        providerErrStrings = append(providerErrStrings, err.Error())
    }

    for _, providerResponse := range providerResponses {
        if providerResponse.Error != nil {
            hasErrors = true
            providerErrStrings = append(providerErrStrings, providerResponse.Error.Error())
        }
    }

    if hasErrors {
        sort.Strings(providerErrStrings)
        errInfo := fmt.Sprintf(
            "ERROR: Resolving credentials from provider '%s' failed: %v",
            provider.GetName(),
            strings.Join(providerErrStrings, ", "),
        )
        return nil, nil, errInfo
    }

    return provider, providerResponses, ""
}
```

### Recommendations for credential-proxy

Adopt typed errors for different failure modes:

```go
// Recommended typed errors for credential-proxy

// PlaceholderExtractionError -- malformed request
type PlaceholderExtractionError struct {
    RequestURL string
    Detail     string
}

// CredentialResolutionError -- vault or config error
type CredentialResolutionError struct {
    Placeholder string
    VaultPath   string
    Cause       error
}

// DomainBindingError -- security policy violation
type DomainBindingError struct {
    Placeholder  string
    TargetDomain string
    BoundDomain  string
}

func (e DomainBindingError) Error() string {
    return fmt.Sprintf("credential %s bound to %s but request targets %s",
        e.Placeholder, e.BoundDomain, e.TargetDomain)
}

// VaultConnectionError -- transient error, retry candidate
type VaultConnectionError struct {
    Address string
    Cause   error
}
```

Note: Secretless uses bare string errors (`fmt.Errorf("ERROR: ...")`). The
credential-proxy already uses error wrapping (`fmt.Errorf("...: %w", err)`)
which is the correct Go idiom. Do not regress to bare strings.


## Testing Patterns

### Pattern: Interface Mocking with testify

Secretless uses `testify/mock` for provider interface mocking:

**Source file:** `internal/plugin/v1/provider_mock.go`

### Pattern: Table-Driven Tests with Declarative Cases

```go
// File: internal/plugin/connectors/http/generic/connector_test.go
var testCases = []struct {
    description string
    cfg         *config
    request     *http.Request
    creds       connector.CredentialValuesByID
    expErrStr   string
}{
    {
        description: "happy path",
        cfg:         plainConfig(),
        creds: connector.CredentialValuesByID{
            "username": []byte("someuser"),
            "key":      []byte("someKey"),
        },
    },
    {
        description: "missing username",
        expErrStr:   `missing required credential: "username"`,
    },
}
```

### Pattern: Sample Data Helpers

```go
func sampleOauth1ConfigYAML() []byte {
    return []byte(`
      oauth1:
        consumer_key: "{{ .consumer_key }}"
    `)
}

func plainConfig() *config {
    cfg, err := sampleConfig()
    if err != nil {
        panic(err)  // Panic in test helpers is acceptable
    }
    return cfg
}
```

### Recommendations for credential-proxy

For `vault.SecretStore`, mock the interface:

```go
type MockSecretStore struct {
    mock.Mock
}

func (m *MockSecretStore) FetchCredential(
    ctx context.Context,
    path string,
) (*CredentialValue, error) {
    args := m.Called(ctx, path)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*CredentialValue), args.Error(1)
}
```

Avoid: Secretless's `empty_test.go` files (no-op tests to verify package
compilation). Modern Go tooling does not require these.

Avoid: Elaborate test harnesses that start real Vault instances. Mock at the
`SecretStore` interface boundary for unit tests; use integration tests with
ephemeral OpenBao instances for end-to-end coverage.


## Security Patterns: Credential Zeroization

### Pattern: Explicit Memory Zeroization After Use

Secretless has a formal zeroization design proposal and implementation to
minimize credential lifetime in memory.

**Source files:**

- `internal/proxy_service.go` (lines 8--17): `ZeroizeCredentials` implementation
- `design/zeroization.md`: Design proposal

```go
// File: internal/proxy_service.go
func ZeroizeCredentials(backendCredentials map[string][]byte) {
    for _, credentialBytes := range backendCredentials {
        for i := range credentialBytes {
            credentialBytes[i] = 0
        }
    }
}
```

Usage at the call site:

```go
creds, err := subservice.RetrieveCredentials()
defer internal.ZeroizeCredentials(creds)  // Zeroize as soon as handler returns
```

### Zeroization Design Considerations (from `design/zeroization.md`)

The Secretless design document identifies key constraints:

1. **Byte slices are mutable and zeroizable.** Secrets arrive from the wire as
   `[]byte` and can be overwritten in-place.

2. **Strings in Go are immutable.** Attempting to modify a string via
   reflection causes a panic. Mutable strings require byte-slice-backed
   construction via `unsafe.Pointer`:

```go
// Byte-bound string: the string shares memory with the byte slice.
// Zeroizing the byte slice also zeroizes the string.
func ByteBoundString(b []byte) string {
    header := (*reflect.SliceHeader)(unsafe.Pointer(&b))
    bytesHeader := &reflect.StringHeader{
        Data: header.Data,
        Len:  header.Len,
    }
    return *(*string)(unsafe.Pointer(bytesHeader))
}
```

3. **Avoid `append` for credential concatenation.** Resizing a slice copies data
   to new memory; the old memory is left for GC (not zeroed). Use pre-allocated
   concatenation instead:

```go
func ConcatBytes(bss ...[]byte) []byte {
    size := 0
    for _, bs := range bss {
        size += len(bs)
    }
    newByteSlice := make([]byte, size)
    i := 0
    for _, bs := range bss {
        for _, b := range bs {
            newByteSlice[i] = b
            i++
        }
    }
    return newByteSlice
}
```

4. **Secret journey tracking.** The proposal recommends using
   `context.Context` to store a registry of all secret derivatives, enabling
   centralized zeroization when the context is cancelled.

```
Resolver.#Resolve -> Provider.#GetValues |-> Handler -> Listener -> Target Backend
                                         |
                                         |-> EventNotifier.#ResolveSecret
```

### Recommendations for credential-proxy

The credential-proxy should adopt zeroization with the following approach:

- Represent credentials internally as `[]byte` rather than `string` wherever possible
- Use `defer zeroize(creds)` immediately after credential retrieval
- Track byte-slice derivatives to ensure all copies are zeroed
- Use `ByteBoundString` if string conversion is unavoidable (e.g., for HTTP header values)
- Avoid `append` when constructing credential-bearing buffers

The current `vault.CredentialValue` uses `string` fields (`Key`, `HeaderName`,
`HeaderPrefix`). Consider converting `Key` to `[]byte` to enable zeroization.


## Summary: Patterns and Adoption Recommendations

```{r summary_table, echo=FALSE, eval=TRUE, results='asis'}
patterns <- data.frame(
  Aspect = c(
    "Provider Abstraction",
    "Credential Injection",
    "Domain Binding",
    "Request Processing",
    "Error Handling",
    "Configuration",
    "Testing",
    "Credential Zeroization",
    "Plugin System",
    "Config Reload"
  ),
  Secretless_Pattern = c(
    "Factory-based registration map",
    "Go text/template rendering",
    "None",
    "Sequential handler pipeline",
    "Fail-through collection, sorted output",
    "Versioned YAML with parse-time validation",
    "Interface mocks + testify + table-driven",
    "Manual byte-slice zeroing via defer",
    "Runtime shared-object (.so) loading",
    "Hot-reload via ConfigurationManager"
  ),
  Credential_Proxy_Current = c(
    "Direct SecretStore interface",
    "Explicit placeholder replacement",
    "Explicit BoundDomain in config",
    "Sequential MITM stages",
    "Per-stage error returns",
    "YAML with parse-time validation + indexes",
    "Interface mocks",
    "Response sanitizer",
    "Compile-time (no plugins)",
    "Startup-only"
  ),
  Recommendation = c(
    "Adopt factory pattern if multi-backend needed",
    "Keep current -- simpler, no template injection risk",
    "Keep current -- security advantage over Secretless",
    "Keep current -- adequate for scope",
    "Adopt fail-through + typed errors",
    "Keep current -- superior to Secretless",
    "Adopt more table-driven tests",
    "Adopt byte-slice zeroization with defer",
    "Do NOT add plugins -- unnecessary complexity",
    "Do NOT add hot-reload -- unnecessary complexity"
  ),
  stringsAsFactors = FALSE
)
knitr::kable(patterns, col.names = c("Aspect", "Secretless Pattern",
  "Credential-Proxy Current", "Recommendation"))
```


## Key Takeaways for credential-proxy

### Patterns to Adopt

1. **Fail-through error collection with sorted, deterministic output.**
   When multiple placeholders exist, resolve all of them and collect errors
   rather than failing on the first. This aids debugging in production.

2. **Typed errors for distinct failure modes.** Create `DomainBindingError`,
   `CredentialResolutionError`, `VaultConnectionError`, and
   `PlaceholderExtractionError` types. This enables callers to make
   domain-appropriate decisions (retry transient errors, reject policy
   violations).

3. **Credential zeroization via `defer` immediately after retrieval.**
   Use `[]byte` for credential storage, zeroize with a simple loop, and
   avoid `append` or string conversion of secret data.

4. **Lazy provider instantiation with mutex protection** if multi-backend
   support is added. Secretless's `Resolver.Provider()` method is a clean
   example of thread-safe lazy initialization.

5. **Resources interface for handler dependency injection.** Bundle
   `Config`, `VaultStore`, `Logger`, and `AuditClient` behind a single
   interface to simplify testing and reduce constructor parameter lists.

6. **Table-driven tests with declarative cases** for all credential
   resolution and domain binding scenarios.

### Patterns to Explicitly Avoid

1. **Runtime plugin loading.** Shared-object plugins add complexity without
   benefit for a controlled MITM proxy deployment. Keep compile-time
   registration.

2. **Go template-based credential injection.** Templates introduce injection
   risk and are harder to audit than explicit `HeaderName`/`HeaderPrefix`
   mappings.

3. **Configuration versioning and hot-reload.** The credential-proxy loads
   config once at startup. Adding hot-reload introduces race conditions
   between config changes and in-flight requests, and complicates the audit
   trail.

4. **Bare string errors.** Secretless uses `fmt.Errorf("ERROR: ...")` without
   wrapping. The credential-proxy already uses `%w` for error wrapping,
   which is correct.

### Areas Where credential-proxy Is Already Superior

- **Domain binding** as a first-class security constraint
- **Request body credential detection and response sanitization** (Secretless
  only injects into headers, never sanitizes responses)
- **HTTPS MITM support** via VSOCK (Secretless is a forward/reverse proxy
  without transparent MITM)
- **Audit logging** via Temporal workflows (Secretless has only a basic
  `EventNotifier` interface)
